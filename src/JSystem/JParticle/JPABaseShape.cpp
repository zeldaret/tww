//
// Generated by dtk
// Translation Unit: JPABaseShape.cpp
//

#include "JSystem/JParticle/JPABaseShape.h"
#include "JSystem/JKernel/JKRHeap.h"
#include "JSystem/JUtility/JUTAssert.h"

GXBlendMode JPABaseShape::stBlendMode[4] = {
    GX_BM_NONE,
    GX_BM_BLEND,
    GX_BM_LOGIC,
};

GXBlendFactor JPABaseShape::stBlendFactor[10] = {
    GX_BL_ZERO,
    GX_BL_ONE,
    GX_BL_SRC_COLOR,
    GX_BL_INV_SRC_COLOR,
    GX_BL_DST_COLOR,
    GX_BL_INV_DST_COLOR,
    GX_BL_SRC_ALPHA,
    GX_BL_INV_SRC_ALPHA,
    GX_BL_DST_ALPHA,
    GX_BL_INV_DST_ALPHA,
};

GXLogicOp JPABaseShape::stLogicOp[16] = {
    GX_LO_CLEAR,
    GX_LO_SET,
    GX_LO_COPY,
    GX_LO_INV_COPY,
    GX_LO_NOOP,
    GX_LO_INV,
    GX_LO_AND,
    GX_LO_NAND,
    GX_LO_OR,
    GX_LO_NOR,
    GX_LO_XOR,
    GX_LO_EQUIV,
    GX_LO_REV_AND,
    GX_LO_INV_AND,
    GX_LO_REV_OR,
    GX_LO_INV_OR,
};

GXCompare JPABaseShape::stCompare[8] = {
    GX_NEVER,
    GX_LESS,
    GX_LEQUAL,
    GX_EQUAL,
    GX_NEQUAL,
    GX_GEQUAL,
    GX_GREATER,
    GX_ALWAYS,
};

GXAlphaOp JPABaseShape::stAlphaOp[4] = {
    GX_AOP_AND,
    GX_AOP_OR,
    GX_AOP_XOR,
    GX_AOP_XNOR,
};

GXTevColorArg JPABaseShapeArc::stTevColorArg[6][4] = {
    { GX_CC_ZERO, GX_CC_TEXC, GX_CC_ONE,  GX_CC_ZERO },
    { GX_CC_ZERO, GX_CC_C0,   GX_CC_TEXC, GX_CC_ZERO },
    { GX_CC_C0,   GX_CC_ONE,  GX_CC_TEXC, GX_CC_ZERO },
    { GX_CC_C1,   GX_CC_C0,   GX_CC_TEXC, GX_CC_ZERO },
    { GX_CC_ZERO, GX_CC_TEXC, GX_CC_C0,   GX_CC_C1   },
    { GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_C0   },
};

GXTevAlphaArg JPABaseShapeArc::stTevAlphaArg[2][4] = {
    { GX_CA_ZERO, GX_CA_TEXA, GX_CA_A0,   GX_CA_ZERO },
    { GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_A0   },
};

class JPAColorRegAnmKey {
public:
    s16 m00;
    GXColor m02;
};

/* 80256F88-80257248       .text makeColorTable__FP17JPAColorRegAnmKeyiiP7JKRHeap */
GXColor* makeColorTable(JPAColorRegAnmKey* pKey, int keyNum, int frmNum, JKRHeap* pHeap) {
    GXColor* colTbl = (GXColor*)JKRHeap::alloc((frmNum + 1) * sizeof(GXColor), 4, pHeap);
    JUT_ASSERT(0x5d, colTbl);
    
    f32 f3, f4, f5, f6;
    f3 = f4 = f5 = f6 = 0.0f;
    f32 f0, f7, f8, f9;
    f0 = pKey[0].m02.r;
    f7 = pKey[0].m02.g;
    f8 = pKey[0].m02.b;
    f9 = pKey[0].m02.a;
    int key = 0;
    for (int i = 0; i < frmNum+1; i++) {
        if (pKey[key].m00 == i) {
            colTbl[i] = pKey[key].m02;
            f0 = pKey[key].m02.r;
            f7 = pKey[key].m02.g;
            f8 = pKey[key].m02.b;
            f9 = pKey[key].m02.a;
            key++;
            if (key < keyNum) {
                f32 f2 = 1.0f / (pKey[key].m00 - pKey[key-1].m00);
                f3 = (pKey[key].m02.r - f0) * f2;
                f4 = (pKey[key].m02.g - f7) * f2;
                f5 = (pKey[key].m02.b - f8) * f2;
                f6 = (pKey[key].m02.a - f9) * f2;
            } else {
                f3 = f4 = f5 = f6 = 0.0f;
            }
        } else {
            f0 += f3;
            colTbl[i].r = f0;
            f7 += f4;
            colTbl[i].g = f7;
            f8 += f5;
            colTbl[i].b = f8;
            f9 += f6;
            colTbl[i].a = f9;
        }
    }
    
    return colTbl;
}

static void dummy() {
    OSReport("texTable");
    OSReport("(*((s16*) (bin + 20))) != 0");
    OSReport("(*((s16*) (bin + 22))) != 0");
}

/* 80257248-80257508       .text __ct__15JPABaseShapeArcFPCUcP7JKRHeap */
JPABaseShapeArc::JPABaseShapeArc(const u8* data, JKRHeap* pHeap) {
    pBsd = reinterpret_cast<const JPABaseShapeData*>(data+0x0C);
    mColLoopOffset = (pBsd->mFlags & 0x0800) ? 0xFFFF : 0;
    mTexLoopOffset = (pBsd->mFlags & 0x2000) ? 0xFFFF : 0;

    BOOL isEnableGlobalColAnm = ((pBsd->mFlags & 0x1000) || getType() == JPAType_Stripe || getType() == JPAType_StripeCross) ? TRUE : FALSE;
    BOOL isEnableGlobalTexAnm = ((pBsd->mFlags & 0x4000) || getType() == JPAType_Stripe || getType() == JPAType_StripeCross) ? TRUE : FALSE;
    mGlobalAnmFlags = isEnableGlobalColAnm << 1 | isEnableGlobalTexAnm << 0;

    if (isEnableTextureAnm() && getTextureAnmKeyNum() != 0)
        mpTexAnmIdxArr = (const u8*)(data + 0x60);
    else
        mpTexAnmIdxArr = NULL;

    if (isEnablePrmAnm()) {
        JUT_ASSERT(0x11f, pBsd->prmAnmKeyNum != 0);
        mpPrmColorArr = makeColorTable((JPAColorRegAnmKey*)(data + pBsd->mPrmAnimDataOffs), pBsd->prmAnmKeyNum, pBsd->mColorRegAnmMaxFrm, pHeap);
    } else {
        mpPrmColorArr = NULL;
    }

    if (isEnableEnvAnm()) {
        JUT_ASSERT(0x127, pBsd->envAnmKeyNum != 0);
        mpEnvColorArr = makeColorTable((JPAColorRegAnmKey*)(data + pBsd->mEnvAnimDataOffs), pBsd->envAnmKeyNum, pBsd->mColorRegAnmMaxFrm, pHeap);
    } else {
        mpEnvColorArr = NULL;
    }
}
