//
// Generated by dtk
// Translation Unit: d_a_kt.cpp
//

#include "d/actor/d_a_kt.h"
#include "d/d_bg_s_gnd_chk.h"
#include "d/d_com_inf_game.h"
#include "d/d_procname.h"
#include "d/d_s_play.h"
#include "d/actor/d_a_player.h"
#include "f_op/f_op_actor_mng.h"
#include "m_Do/m_Do_controller_pad.h"
#include "m_Do/m_Do_mtx.h"

float kt_scale = 1.5f;

/* 00000078-000001BC       .text kotori_draw__FP8kt_class */
void kotori_draw(kt_class* i_this) {
    /* Nonmatching */
    kt_scale = g_regHIO.mChild[0].mFloatRegs[0] + 1.0f;
    MtxTrans(i_this->current.pos.x, i_this->current.pos.y + i_this->mLiftY, i_this->current.pos.z, false);
    cMtx_YrotM(*calc_mtx, i_this->current.angle.y);
    cMtx_XrotM(*calc_mtx, i_this->mAngleRoll);
    cMtx_ZrotM(*calc_mtx, i_this->current.angle.z);
    f32 scaleMag = kt_scale * 0.2f;
    MtxScale(scaleMag, scaleMag, scaleMag, true);
    J3DModel* model = i_this->mpModel;
    model->setBaseTRMtx(*calc_mtx);
    mDoExt_modelUpdate(model);
    if (i_this->mWingScale < 10.0f) {
        MtxTrans(0.0, 130.0f, 80.0f, true);
        MtxScale(1.0f, i_this->mWingScale, 1.0f, true);
        i_this->mpModelWing->setBaseTRMtx(*calc_mtx);
        mDoExt_modelUpdate(i_this->mpModelWing);
    }
}

/* 000001BC-000001E0       .text daKt_Draw__FP8kt_class */
static BOOL daKt_Draw(kt_class* i_this) {
    kotori_draw(i_this);
    return TRUE;
}

/* 000001E0-000011D4       .text kotori_move__FP8kt_class */
void kotori_move(kt_class* i_this) {
    /* Nonmatching */
    daPy_py_c* player = (daPy_py_c*)dComIfGp_getPlayer(0);
    bool dispWing = false;
    u8 ret = 0;
    dBgS_GndChk gndChk;

    f32 dx = player->current.pos.x - i_this->current.pos.x;
    f32 dz = player->current.pos.z - i_this->current.pos.z;
    f32 dist_xz = sqrtf(dx*dx + dz*dz);
    cLib_addCalcAngleS2(&i_this->mAngleRoll, 0, 2, g_regHIO.mChild[0].mShortRegs[4] + 0x1000);

    f32 vx = i_this->mTargetPos.x - i_this->current.pos.x;
    f32 vy = i_this->mTargetPos.y - i_this->current.pos.y;
    f32 vz = i_this->mTargetPos.z - i_this->current.pos.z;
    s16 angleX = cM_atan2s(vx, vz);
    s16 angleY = -cM_atan2s(vy, sqrtf(vx*vx + vz*vz));

    cXyz headTopPos = player->getHeadTopPos();
    f32 dist;
    cXyz offs;
    cXyz pt;

    switch (i_this->mState) {
    case 0:
        i_this->mSpeedFwd = kt_scale * 20.0f + 30.0f;
        if (CPad_CHECK_TRIG_LEFT(0) && fopAcM_GetParam(i_this) == 1000) {
            i_this->mTargetPos.x = i_this->current.pos.x;
            i_this->mTargetPos.y = i_this->current.pos.y + 500.0f;
            i_this->mTargetPos.z = i_this->current.pos.z;
            i_this->mState = 2;
            i_this->mSpeedLerp = 0.0f;
        } else {
            if (i_this->mTimer[2] == 0) {
                i_this->mState = 1;
                offs.x = 0.0f;
                offs.y = 0.0f;
                offs.z = g_regHIO.mChild[0].mFloatRegs[13] * 100.0f + 3000.0f;
                cMtx_YrotS(*calc_mtx, i_this->shape_angle.y);

                MtxPosition(&offs, &pt);
                i_this->mTargetPosHome.x = player->current.pos.x + pt.x + cM_rndFX(g_regHIO.mChild[0].mFloatRegs[14] + 200.0f);
                i_this->mTargetPosHome.y = player->current.pos.y + 1000.0f;
                i_this->mTargetPosHome.z = player->current.pos.z + pt.z + cM_rndFX(g_regHIO.mChild[0].mFloatRegs[14] + 200.0f);

                gndChk.SetPos(&i_this->mTargetPosHome);
                i_this->mTargetPosHome.y = dComIfG_Bgsp()->GroundCross(&gndChk);
                if (i_this->mTargetPosHome.y == -100000000.0f)
                    i_this->mTargetPosHome = player->current.pos;
                i_this->mTargetPos = i_this->mTargetPosHome;
                i_this->mSpeedLerp = 0.0f;
            } else if (i_this->mTimer[0] == 0) {
                i_this->mTimer[0] = cM_rndF(250.0f) + 60.0f;
                i_this->mTargetPos.x = i_this->mTargetPosHome.x + cM_rndFX(2000.0f);
                i_this->mTargetPos.z = i_this->mTargetPosHome.z + cM_rndFX(2000.0f);
                i_this->mTargetPos.y = i_this->mTargetPosHome.y + cM_rndFX(1000.0f);
                i_this->mSpeedLerp = 0.0f;
            }

            cLib_addCalc2(&i_this->mSpeedLerp, 1.0f, 1.0f, 0.1f);
        }
        goto calc_012;
    case 1:
        dist = sqrtf(vx*vx + vy*vy + vz*vz);
        if (dist < g_regHIO.mChild[0].mFloatRegs[1] * 10.0f + 800.0f) {
            i_this->mState = 8;
        }
        cLib_addCalc2(&i_this->mSpeedLerp, 3.0f, 1.0f, 0.1f);
calc_012:
        cLib_addCalcAngleS2(&i_this->current.angle.y, angleX, 10, (s16)((g_regHIO.mChild[0].mFloatRegs[0] * 10.0f + 500.0f) * i_this->mSpeedLerp));
        cLib_addCalcAngleS2(&i_this->current.angle.x, angleY, 10, (s16)((g_regHIO.mChild[0].mFloatRegs[0] * 10.0f + 500.0f) * i_this->mSpeedLerp));
        offs.x = 0.0f;
        offs.y = 0.0f;
        offs.z = i_this->mSpeedFwd;
        mDoMtx_YrotS(*calc_mtx, i_this->current.angle.y);
        mDoMtx_XrotM(*calc_mtx, i_this->current.angle.x);
        MtxPosition(&offs, &i_this->mSpeedVel);
        i_this->current.pos.x += i_this->mSpeedVel.x;
        i_this->current.pos.y += i_this->mSpeedVel.y;
        i_this->current.pos.z += i_this->mSpeedVel.z;
        if (i_this->mLiftYTimer >= 0.0f)
            dispWing = true;
        ret = 2;
        break;
    case 8:
        cLib_addCalcAngleS2(&i_this->current.angle.y, angleX, 10, (s16)((g_regHIO.mChild[0].mFloatRegs[0] * 10.0f + 1500.0f) * i_this->mSpeedLerp));
        cLib_addCalc0(&i_this->mSpeedLerp, g_regHIO.mChild[0].mFloatRegs[4], 1.0f);
        cLib_addCalc0(&i_this->mSpeedFwd, g_regHIO.mChild[0].mFloatRegs[5], 1.0f);
        offs.x = 0.0f;
        offs.y = 0.0f;
        offs.z = i_this->mSpeedFwd;
        mDoMtx_YrotS(*calc_mtx, i_this->current.angle.y);
        MtxPosition(&offs, &i_this->mSpeedVel);
        i_this->current.pos.x += i_this->mSpeedVel.x;
        i_this->current.pos.z += i_this->mSpeedVel.z;
        cLib_addCalc2(&i_this->current.pos.y, i_this->mGroundY, g_regHIO.mChild[0].mFloatRegs[6] + 0.3f, g_regHIO.mChild[0].mFloatRegs[7] + 20.0f);
        if (fabsf(i_this->current.pos.y - i_this->mGroundY) < 1.0f) {
            i_this->current.pos.y = i_this->mGroundY;
            i_this->mState = 10;
        }
        dispWing = true;
        ret = 1;
        break;
    case 2:
        i_this->mTargetPos = headTopPos;
        i_this->mTargetPos.y += 200.0f;
        dist = sqrtf(vx*vx + vy*vy + vz*vz);
        if (dist < g_regHIO.mChild[0].mFloatRegs[1] * 10.0f + 800.0f) {
            i_this->mState = 9;
        }
        cLib_addCalc2(&i_this->mSpeedLerp, 3.0f, 1.0f, 0.1f);
        goto calc_012;
        break;
    case 9:
        i_this->mTargetPos = headTopPos;
        i_this->mTargetPos.y += 100.0f;
        cLib_addCalcAngleS2(&i_this->current.angle.y, angleX, 10, (s16)((g_regHIO.mChild[0].mFloatRegs[0] * 10.0f + 1500.0f) * i_this->mSpeedLerp));
        cLib_addCalc0(&i_this->mSpeedLerp, g_regHIO.mChild[0].mFloatRegs[4], 1.0f);
        cLib_addCalc0(&i_this->mSpeedFwd, g_regHIO.mChild[0].mFloatRegs[5], 1.0f);
        offs.x = 0.0f;
        offs.y = 0.0f;
        offs.z = i_this->mSpeedFwd;
        mDoMtx_YrotS(*calc_mtx, i_this->current.angle.y);
        MtxPosition(&offs, &i_this->mSpeedVel);
        i_this->current.pos.x += i_this->mSpeedVel.x;
        i_this->current.pos.z += i_this->mSpeedVel.z;
        cLib_addCalc2(&i_this->current.pos.y, i_this->mGroundY, g_regHIO.mChild[0].mFloatRegs[6] + 0.3f, g_regHIO.mChild[0].mFloatRegs[7] + 20.0f);
        if (fabsf(i_this->current.pos.y - i_this->mGroundY) < 1.0f) {
            i_this->current.pos.y = i_this->mGroundY;
            i_this->mState = 20;
        }
        dispWing = true;
        ret = 1;
        break;
    case 20:
        i_this->mTargetPos = headTopPos;
        cLib_addCalc2(&i_this->current.pos.x, i_this->mTargetPos.x, 1.0f, i_this->mSpeedLerp);
        cLib_addCalc2(&i_this->current.pos.y, i_this->mTargetPos.y, 1.0f, i_this->mSpeedLerp / 2.0f);
        cLib_addCalc2(&i_this->current.pos.z, i_this->mTargetPos.z, 1.0f, i_this->mSpeedLerp);
        cLib_addCalc2(&i_this->mSpeedLerp, 1000.0f, 1.0f, g_regHIO.mChild[0].mFloatRegs[16] + 10.0f);
        cLib_addCalcAngleS2(&i_this->current.angle.y, player->shape_angle.y, 2, 0x1000);
        if (fabsf(i_this->current.pos.y - i_this->mTargetPos.y) > 1.0f)
            dispWing = true;
        if (CPad_CHECK_TRIG_LEFT(0)) {
            i_this->mState = 0;
            i_this->mTimer[0] = 0;
            i_this->mLiftYTimer = cM_rndFX(10.0f) + 10.0f;
            i_this->mTargetPosHome.y += 2000.0f;
            i_this->current.angle.x = -0x2000;
            i_this->mTimer[2] = g_regHIO.mChild[0].mShortRegs[5] + 300;
        }
        break;
    case 10:
        i_this->mLiftY += i_this->mLiftYTimer;
        i_this->mLiftYTimer -= g_regHIO.mChild[0].mFloatRegs[9] * 0.1f + 5.0f;
        if (i_this->mLiftY <= 0.0f) {
            i_this->mLiftYTimer = g_regHIO.mChild[0].mFloatRegs[9] + 15.0f;
            i_this->mLiftY = 0.0f;
        }
        cLib_addCalcAngleS2(&i_this->current.angle.y, angleX, 10, (s16)(g_regHIO.mChild[0].mFloatRegs[0] * 10.0f + 500.0f));
        if (i_this->mTimer[1] == 0 && i_this->mLiftY <= 0.0f) {
            i_this->mTimer[1] = 20.0f + cM_rndF(20.0f);
            i_this->mState = 11;
        }
        offs.x = 0.0f;
        offs.y = 0.0f;
        offs.z = g_regHIO.mChild[0].mFloatRegs[11] + 10.0f;
        mDoMtx_YrotS(*calc_mtx, i_this->current.angle.y);
        MtxPosition(&offs, &i_this->mSpeedVel);
        i_this->current.pos.x += i_this->mSpeedVel.x;
        i_this->current.pos.z += i_this->mSpeedVel.z;
        goto calc_11;
        break;
    case 11:
        if (i_this->mTimer[0] == 0) {
            i_this->mTimer[0] = cM_rndF(2.0f) + 10.0f + g_regHIO.mChild[0].mFloatRegs[12];
        }
        if (i_this->mTimer[0] > g_regHIO.mChild[0].mShortRegs[1] + 8) {
            cLib_addCalcAngleS2(&i_this->mAngleRoll, g_regHIO.mChild->mShortRegs[2] + 0x3000, 2, g_regHIO.mChild->mShortRegs[3] + 0x2000);
        }
        if (i_this->mTimer[1] == 0) {
            i_this->mTimer[1] = 20.0f + cM_rndF(50.0f);
            i_this->mState = 10;
            i_this->mTargetPos.x += cM_rndFX(1000.0f);
            i_this->mTargetPos.y += cM_rndFX(1000.0f);
        }
calc_11:
        i_this->current.pos.y -= 5.0f;
        if (!i_this->mHitGround || dx < (g_regHIO.mChild[0].mFloatRegs[15] * 100.0f + 1500.0f)) {
            i_this->mState = 0;
            i_this->mTimer[0] = 0;
            i_this->mLiftYTimer = 10.0f + cM_rndFX(10.0f);
            i_this->mTargetPosHome.y += 2000.0f;
            i_this->current.angle.x = -0x2000;
            i_this->mTimer[2] = g_regHIO.mChild[0].mShortRegs[5] + 300;
        }
        break;
    }

    i_this->mHitGround = false;
    if (i_this->mState >= 8) {
        Vec pos;
        pos.x = i_this->current.pos.x;
        pos.y = i_this->current.pos.y + 1000.0f;
        pos.z = i_this->current.pos.z;
        gndChk.SetPos(&pos);
        i_this->mGroundY = dComIfG_Bgsp()->GroundCross(&gndChk);
        if (i_this->current.pos.y <= i_this->mGroundY) {
            i_this->current.pos.y = i_this->mGroundY;
            i_this->mHitGround = true;
        }
    }

    if (ret == 2) {
        i_this->mLiftY += i_this->mLiftYTimer;
        i_this->mLiftYTimer -= 1.0f;
        if (i_this->mLiftY <= 0.0f) {
            i_this->mLiftYTimer = cM_rndF(5.0f) + 15.0f;
        }
    } else if (ret == 1) {
        cLib_addCalc0(&i_this->mLiftY, 0.0f, 1.0f);
        i_this->mLiftYTimer = 0.0f;
    }

    if (dispWing) {
        i_this->mWingScale = cM_ssin(i_this->mWingTimer);
    } else {
        i_this->mWingScale = 100.0f;
    }
}

/* 000011D4-00001240       .text daKt_Execute__FP8kt_class */
static BOOL daKt_Execute(kt_class* i_this) {
    i_this->mWingTimer = i_this->mWingTimer + 0x5e76 + g_regHIO.mChild[0].mShortRegs[0];
    for (s32 i = 0; i < (s32)ARRAY_SIZE(i_this->mTimer); i++)
        if (i_this->mTimer[i] != 0)
            --i_this->mTimer[i];
    kotori_move(i_this);
    return TRUE;
}

/* 00001240-00001248       .text daKt_IsDelete__FP8kt_class */
static BOOL daKt_IsDelete(kt_class* i_this) {
    return TRUE;
}

/* 00001248-00001278       .text daKt_Delete__FP8kt_class */
static BOOL daKt_Delete(kt_class* i_this) {
    dComIfG_resDelete(&i_this->mPhs, "Kt");
    return TRUE;
}

/* 00001278-0000134C       .text daKt_solidHeapCB__FP10fopAc_ac_c */
static BOOL daKt_solidHeapCB(fopAc_ac_c* i_ac) {
    kt_class* i_this = (kt_class*)i_ac;

    J3DModelData* modelData = (J3DModelData*)dComIfG_getObjectRes("Kt", 0x0B);
    i_this->mpModel = mDoExt_J3DModel__create(modelData, 0x10000, 0x11020203);

    J3DModelData* modelDataWing = (J3DModelData*)dComIfG_getObjectRes("Kt", 0x0A);
    i_this->mpModelWing = mDoExt_J3DModel__create(modelDataWing, 0x10000, 0x11020203);

    return modelData != NULL && modelDataWing != NULL && i_this->mpModel != NULL && i_this->mpModelWing != NULL;
}

/* 0000134C-00001530       .text daKt_Create__FP10fopAc_ac_c */
static s32 daKt_Create(fopAc_ac_c* i_ac) {
    s32 rt;
    kt_class* i_this = (kt_class*)i_ac;
    fopAcM_SetupActor(i_this, kt_class);

    rt = dComIfG_resLoad(&i_this->mPhs, "Kt");
    if (rt == cPhs_COMPLEATE_e) {
        if (fopAcM_entrySolidHeap(i_this, daKt_solidHeapCB, 0)) {
            s32 num = fopAcM_GetParam(i_this);
            if (num < 1000) {
                i_this->current.pos.y = g_regHIO.mChild[0].mFloatRegs[0] * 10.0f + 2500.0f;
                fopAcM_SetParam(i_this, 1000);
                for (s32 i = 0; i < num; i++) {
                    fopAcM_prm_class* appen = fopAcM_CreateAppend();
                    appen->mPos = i_this->current.pos;
                    appen->mAngle.set(0, 0, 0);
                    appen->mParameter = 1001 + i;
                    fpcM_Create(PROC_KT, NULL, appen);
                }
            }

            i_this->mpModel->setBaseScale(i_this->scale);
            i_this->mpModelWing->setBaseScale(i_this->scale);
            i_this->current.pos.y += 2500.0f;
            i_this->mTargetPosHome = i_this->mHomePos = i_this->current.pos;
            i_this->mTimer[2] = g_regHIO.mChild[0].mShortRegs[5] + 500;
        } else {
            rt = cPhs_ERROR_e;
        }
    }

    return rt;
}
