//
// Generated by dtk
// Translation Unit: d_a_shop_item.cpp
//

#include "d/actor/d_a_shop_item.h"
#include "f_op/f_op_actor_mng.h"
#include "JSystem/JKernel/JKRHeap.h"
#include "d/d_procname.h"
#include "d/d_com_inf_game.h"
#include "d/d_s_play.h"
#include "d/d_item.h"
#include "d/d_item_data.h"
#include "d/actor/d_a_item.h"
#include "m_Do/m_Do_mtx.h"
#include "m_Do/m_Do_lib.h"

const char daShopItem_c::m_cloth_arcname[] = "Cloth";
const f32 daShopItem_c::m_cullfar_max = 5000.0f;

char* daShopItem_c::getShopArcname() {
    u8 type = fopAcM_GetParamBit(fopAcM_GetParam(this), 8, 4);
    if(type == 1 || (type == 0 && mModelType[m_itemNo] == 0x01)) {
        return dItem_data::getFieldArc(m_itemNo);
    }
    else {
        return dItem_data::getArcname(m_itemNo);
    }
}

s16 daShopItem_c::getShopBmdIdx() {
    u8 type = fopAcM_GetParamBit(fopAcM_GetParam(this), 8, 4);
    if(type == 1 || (type == 0 && mModelType[m_itemNo] == 0x01)) {
        return dItem_data::getFieldBmdIdx(m_itemNo);
    }
    else {
        return dItem_data::getBmdIdx(m_itemNo);
    }
}

void daShopItem_c::CreateInit() {
    mCullMtx = field_0x64C;
    fopAcM_setCullSizeBox(this, -100.0f, 0.0f, -100.0f, 100.0f, 200.0f, 100.0f);
    if(mDoLib_clipper::mSystemFar > 1.0f) {
        mCullSizeFar = 5000.0f / mDoLib_clipper::mSystemFar;
    }
    show();

    mScale = getData()[m_itemNo].mScale;
    orig.pos = current.pos;
    set_mtx();

    if(isDaizaItem(m_itemNo)) {
        tevType = TEV_TYPE_ACTOR;
    }
    else {
        tevType = (TevType)0x5C;
    }

    mpModel->setUserArea(0);
}

BOOL daShopItem_c::clothCreate() {
    if(isUseClothPacket(m_itemNo)) {
        dCloth_packet_c* (*clothFunc[4])(ResTIMG*, ResTIMG*, dKy_tevstr_c*, cXyz**) = {dClothVobj03_create, dClothVobj04_create, dClothVobj05_create, dClothVobj07_0_create};
        u32 clothRes[4] = {0x20, 0x21, 0x22, 0x23};

        switch(m_itemNo) {
            case HEROS_FLAG:
                field_0x648 = 0;
                break;
            case TAIRYO_FLAG:
                field_0x648 = 1;
                break;
            case SALES_FLAG:
                field_0x648 = 2;
                break;
            case RED_FLAG:
            default:
                field_0x648 = 3;
        }

        ResTIMG* shopArc = (ResTIMG*)dComIfG_getObjectRes(getShopArcname(), clothRes[field_0x648]);
        ResTIMG* clothArc = (ResTIMG*)dComIfG_getObjectRes(m_cloth_arcname, 3);

        field_0x644 = (*clothFunc[field_0x648])(shopArc, clothArc, &mTevStr, 0);
        if (field_0x644 == 0) {
            return 0;
        }
    }
    else {
        field_0x644 = 0;
    }
    
    return 1;
}

void daShopItem_c::set_mtx() {
    mpModel->setBaseScale(mScale);
    MTXTrans(mDoMtx_stack_c::get(), current.pos.x, current.pos.y, current.pos.z);
    mDoMtx_stack_c::ZXYrotM(current.angle.x, current.angle.y, current.angle.z);
    MTXCopy(mDoMtx_stack_c::get(), field_0x64C);

    const Vec& temp1 = getData()[m_itemNo].field_0x0C;
    mDoMtx_stack_c::transM(temp1.x, temp1.y, temp1.z);
    const SVec& temp2 = getData()[m_itemNo].field_0x18;
    mDoMtx_stack_c::ZXYrotM(temp2.x, temp2.y, temp2.z);
    mpModel->setBaseTRMtx(mDoMtx_stack_c::get());

    if(field_0x644 != 0) {
        // I have no clue why Nintendo would do this but it works
        cXyz local[4];
        cXyz local2[4];

        local2[3].set(0.0f, g_regHIO.mChild[10].mFloatRegs[15] + 94.0f, 0.0f);
        local[0].set(0.0f, g_regHIO.mChild[10].mFloatRegs[15] + 94.0f, 0.0f);
        local2[2].set(0.0f, g_regHIO.mChild[10].mFloatRegs[15] + 94.0f, 0.0f);
        local[1].set(0.0f, g_regHIO.mChild[10].mFloatRegs[15] + 94.0f, 0.0f);
        local2[1].set(0.0f, g_regHIO.mChild[10].mFloatRegs[15] + 97.5f, 0.0f);
        local[2].set(0.0f, g_regHIO.mChild[10].mFloatRegs[15] + 97.5f, 0.0f);
        local2[0].set(0.0f, g_regHIO.mChild[10].mFloatRegs[15] + 94.0f, 0.0f);
        local[3].set(0.0f, g_regHIO.mChild[10].mFloatRegs[15] + 94.0f, 0.0f);

        mDoMtx_stack_c::transM(local[field_0x648]);
        mDoMtx_stack_c::YrotM(0x4000);
        field_0x644->setScale(mScale);
        field_0x644->setMtx(mDoMtx_stack_c::get());
    }
}

bool daShopItem_c::_execute() {
    animPlay(1.0f, 1.0f, 1.0f, 1.0f, 1.0f);
    set_mtx();

    return true;
}

bool daShopItem_c::_draw() {
    if(chkDraw() == 0) return 1;

    if(m_itemNo == WATER_STATUE || m_itemNo == POSTMAN_STATUE) {
        mpModel->getModelData()->getJointTree().getJointNodePointer(0)->setMtxCalc(0);
    }
    DrawBase();
    
    if(field_0x644 != 0) field_0x644->cloth_draw();

    return true;
}

void daShopItem_c::settingBeforeDraw() {
    if(isBomb(m_itemNo) || (m_itemNo == BOMB_BAG) || (m_itemNo == HUMMER) || m_itemNo == SMALL_KEY || m_itemNo == PRESIDENT_STATUE) {
        dDlst_texSpecmapST(&mEyePos, &mTevStr, mpModel->getModelData(), 1.0f);
    }
}

void daShopItem_c::setTevStr() {
    g_env_light.settingTevStruct(tevType, &current.pos, &mTevStr);
    g_env_light.setLightTevColorType(mpModel, &mTevStr);
    for(int i = 0; i < 2; i++) {
        if(mpModelArrow[i] != 0) {
            g_env_light.setLightTevColorType(mpModelArrow[i], &mTevStr);
        }
    }
    
}

static int daShopItem_Create(void* i_this) {
    return static_cast<daShopItem_c*>(i_this)->_create();
}

int daShopItem_c::_create() {
    fopAcM_SetupActor(this, daShopItem_c);
    
    m_itemNo = fopAcM_GetParamBit(fopAcM_GetParam(this), 0, 8);
    
    const char* arcName = getShopArcname();
    if (getShopBmdIdx() == -1 || arcName == 0) {
        m_itemNo = GREEN_RUPEE;
    }

    arcName = getShopArcname();
    int result = dComIfG_resLoad(&mPhs, arcName);
    if(result != cPhs_COMPLEATE_e) {
        return result;
    }
    else {
        int result2 = cPhs_COMPLEATE_e;
        if(isUseClothPacket(m_itemNo)) {
            result2 = dComIfG_resLoad(&field_0x63C, m_cloth_arcname);
        }

        if(result2 != cPhs_COMPLEATE_e) {
            return result2;
        }
        else if(result == cPhs_COMPLEATE_e && result2 == cPhs_COMPLEATE_e) {
            u8 type = fopAcM_GetParamBit(fopAcM_GetParam(this), 8, 4);
            if(type == 2 || (type == 0 && mModelType[m_itemNo] == 0x02)) {
                if(fopAcM_entrySolidHeap(this, CheckItemCreateHeap, dItem_data::getHeapSize(m_itemNo)) == 0) {
                    return cPhs_ERROR_e;
                }
            }
            else if(type == 1 || (type == 0 && mModelType[m_itemNo] == 0x01)) {
                if(fopAcM_entrySolidHeap(this, CheckFieldItemCreateHeap, dItem_data::getFieldHeapSize(m_itemNo)) == 0) {
                    return cPhs_ERROR_e;
                }
            }
            else {
                if(fopAcM_entrySolidHeap(this, CheckItemCreateHeap, dItem_data::getHeapSize(m_itemNo)) == 0) {
                    return cPhs_ERROR_e;
                }
            }

            CreateInit();
        }
    }
    
    return result;
}

static BOOL daShopItem_Delete(void* i_this) {
    daShopItem_c* inst = static_cast<daShopItem_c*>(i_this);

    if(isUseClothPacket(inst->m_itemNo)) {
        dComIfG_resDelete(&inst->field_0x63C, daShopItem_c::m_cloth_arcname);
    }
    inst->DeleteBase(inst->getShopArcname());

    return 1;
}

static BOOL daShopItem_Draw(void* i_this) {
    return static_cast<daShopItem_c*>(i_this)->_draw();
}

static BOOL daShopItem_Execute(void* i_this) {
    return static_cast<daShopItem_c*>(i_this)->_execute();
}

static bool daShopItem_IsDelete(void*) {
    return true;
}

static actor_method_class daShopItemMethodTable = {
    (process_method_func)daShopItem_Create,
    (process_method_func)daShopItem_Delete,
    (process_method_func)daShopItem_Execute,
    (process_method_func)daShopItem_IsDelete,
    (process_method_func)daShopItem_Draw,
};

actor_process_profile_definition g_profile_ShopItem = {
    fpcLy_CURRENT_e,
    7,
    fpcPi_CURRENT_e,
    PROC_ShopItem,
    &g_fpcLf_Method.mBase,
    sizeof(daShopItem_c),
    0,
    0,
    &g_fopAc_Method.base,
    0x00FE,
    &daShopItemMethodTable,
    fopAcStts_CULL_e | fopAcStts_UNK4000_e | fopAcStts_UNK40000_e,
    fopAc_ACTOR_e,
    fopAc_CULLBOX_CUSTOM_e,
};
