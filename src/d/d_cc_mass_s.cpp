//
// Generated by dtk
// Translation Unit: d_cc_mass_s.cpp
//

#include "d/d_cc_mass_s.h"
#include "d/d_cc_d.h"
#include "JSystem/JUtility/JUTAssert.h"
#include "SSystem/SComponent/c_bg_s.h"
#include "SSystem/SComponent/c_math.h"
#include "f_op/f_op_actor.h"

/* 800AC810-800AC920       .text __ct__12dCcMassS_MngFv */
dCcMassS_Mng::dCcMassS_Mng() {
    Ct();
}

/* 800AC920-800AC96C       .text Ct__12dCcMassS_MngFv */
void dCcMassS_Mng::Ct() {
    mFlag = 0;
    mResultCam = 0;
    mCamTopPos.x = 0.0f;
    mCamTopPos.y = -G_CM3D_F_INF;
    mCamTopPos.z = 0.0f;
    mCamBottomPos.x = 0.0f;
    mCamBottomPos.y = -G_CM3D_F_INF;
    mCamBottomPos.z = 0.0f;
    Clear();
}

/* 800AC96C-800ACCB8       .text Prepare__12dCcMassS_MngFv */
void dCcMassS_Mng::Prepare() {
    cM3dGAab area;
    area.ClearForMinMax();
    cCcD_ShapeAttr* attr;
    for (dCcMassS_Obj* mass = mMassObjs; mass < mMassObjs + mMassObjCount; mass++) {
        cCcD_Obj* pobj = mass->GetObj();
        JUT_ASSERT(61, pobj != NULL);
        attr = pobj->GetShapeAttr();
        attr->CalcAabBox();
        area.SetMinMax(attr->GetWorkAab());
    }
    for (dCcMassS_Obj* mass = mMassAreas; mass < mMassAreas + mMassAreaCount; mass++) {
        cCcD_Obj* parea = mass->GetObj();
        JUT_ASSERT(73, parea != NULL);
        attr = parea->GetShapeAttr();
        attr->CalcAabBox();
        area.SetMinMax(attr->GetWorkAab());
    }
    if (mFlag & 1) {
        mCpsAttr.CalcAabBox();
        attr = &mCpsAttr;
        area.SetMinMax(attr->GetWorkAab());
    }
    mDivideArea.SetArea(area);
    for (dCcMassS_Obj* mass = mMassObjs; mass < mMassObjs + mMassObjCount; mass++) {
        cCcD_Obj* pobj = mass->GetObj();
        JUT_ASSERT(93, pobj != NULL);
        cCcD_ShapeAttr* shape = pobj->GetShapeAttr();
        cCcD_DivideInfo* divideInfo = mass->GetPDivideInfo();
        mDivideArea.CalcDivideInfo(divideInfo, shape->GetWorkAab(), 0);
    }
    for (dCcMassS_Obj* mass = mMassAreas; mass < mMassAreas + mMassAreaCount; mass++) {
        cCcD_Obj* parea = mass->GetObj();
        JUT_ASSERT(104, parea != NULL);
        cCcD_ShapeAttr* shape = parea->GetShapeAttr();
        cCcD_DivideInfo* divideInfo = mass->GetPDivideInfo();
        mDivideArea.CalcDivideInfo(divideInfo, shape->GetWorkAab(), 0);
    }
    if (mFlag & 1) {
        mDivideArea.CalcDivideInfo(&mDivideInfo, mCpsAttr.GetWorkAab(), 0);
    }
    mCamTopPos.x = 0.0f;
    mCamTopPos.y = -G_CM3D_F_INF;
    mCamTopPos.z = 0.0f;
    mCamTopDist = G_CM3D_F_INF;
    mCamBottomPos.x = 0.0f;
    mCamBottomPos.y = -G_CM3D_F_INF;
    mCamBottomPos.z = 0.0f;
    mCamBottomDist = G_CM3D_F_INF;
}

/* 800ACCB8-800AD17C       .text Chk__12dCcMassS_MngFP4cXyzPP10fopAc_ac_cP15dCcMassS_HitInf */
u32 dCcMassS_Mng::Chk(cXyz* r29, fopAc_ac_c** r30, dCcMassS_HitInf* r31) {
    cCcD_DivideInfo divideInfo;
    u32 r26 = 0;
    *r30 = NULL;
    mCylAttr.SetC(*r29);
    mCylAttr.CalcAabBox();
    mDivideArea.CalcDivideInfoOverArea(&divideInfo, mCylAttr.GetWorkAab());
    r31->ClearPointer();
    
    if (field_0x128 & 8) {
        for (dCcMassS_Obj* mass = mMassAreas; mass < mMassAreas + mMassAreaCount; mass++) {
            if (!mass->GetPDivideInfo()->Chk(divideInfo)) {
                continue;
            }
            
            cCcD_Obj* pobj = mass->GetObj();
            JUT_ASSERT(174, pobj != NULL);
            cCcD_ShapeAttr* shape = pobj->GetShapeAttr();
            
            f32 sp10;
            if (pobj->ChkCoSet() && mCylAttr.CrossCo(*shape, &sp10)) {
                r26 |= 0x04;
                *r30 = pobj->GetStts()->GetActor();
                if (r31) {
                    r31->SetAreaHitObj(pobj);
                }
                dCcMassS_ObjCallback callback = mass->GetAreaCheckFunc();
                if (callback) {
                    callback(pobj->GetStts()->GetActor(), r29, mResultCamBit);
                }
            }
        }
    }
    
    for (dCcMassS_Obj* mass = mMassObjs; mass < mMassObjs + mMassObjCount; mass++) {
        if (!mass->GetPDivideInfo()->Chk(divideInfo)) {
            continue;
        }
        
        cCcD_Obj* pobj = mass->GetObj();
        dCcD_GObjInf* inf = (dCcD_GObjInf*)pobj->GetGObjInf();
        JUT_ASSERT(214, pobj != NULL);
        cCcD_ShapeAttr* shape = pobj->GetShapeAttr();
        cXyz temp;
        if (pobj->ChkAtSet() && !inf->ChkAtNoMass() &&
            mCylAttr.CrossAtTg(*shape, &temp) && (field_0x128 & 0x1)
        ) {
            r26 |= 0x01;
            *r30 = pobj->GetStts()->GetActor();
            if (r31) {
                r31->SetAtHitObj(pobj);
            }
        }
        
        f32 sp10;
        if (pobj->ChkCoSet() && mCylAttr.CrossCo(*shape, &sp10) && (field_0x128 & 0x02)) {
            r26 |= 0x02;
            *r30 = pobj->GetStts()->GetActor();
            
            if (field_0x128 & 0x10) {
                Vec vec;
                VECSubtract(&(*r30)->current.pos, r29, &vec);
                vec.y = 0;
                f32 vecMag = VECMag(&vec);
                if (cM3d_IsZero(vecMag)) {
                    vec.x = 1;
                } else {
                    VECScale(&vec, &vec, sp10 / vecMag);
                }
                pobj->GetStts()->PlusCcMove(vec.x, vec.y, vec.z);
            }
            
            if (r31) {
                r31->SetCoHitObj(pobj);
                r31->SetCoHitLen(sp10);
            }
        }
    }
    
    f32 temp;
    if ((mFlag & 1) && mDivideInfo.Chk(divideInfo) && mCylAttr.CrossCo(mCpsAttr, &temp)) {
        mResultCam |= 1;
        mResultCam |= 1 << (mResultCamBit + 1);
        
        if ((mResultCam & 2) || (mResultCam & 8)) {
            f32 plusH = r29->y + mCylAttr.GetH();
            cXyz sp1c;
            sp1c.x = r29->x;
            sp1c.y = plusH;
            sp1c.z = r29->z;
            
            if (mCamTopPos.y < 20.0f + plusH) {
                f32 startDist = VECSquareDistance(&sp1c, mCpsAttr.GetStartP());
                if (mCamTopDist > startDist) {
                    mCamTopDist = startDist;
                    mCamTopPos = sp1c;
                }
            }
            if (mCamBottomPos.y < 20.0f + plusH) {
                f32 endDist = VECSquareDistance(&sp1c, mCpsAttr.GetEndP());
                if (mCamBottomDist > endDist) {
                    mCamBottomDist = endDist;
                    mCamBottomPos = sp1c;
                }
            }
        }
    }
    
    return r26;
}

/* 800AD17C-800AD234       .text Clear__12dCcMassS_MngFv */
void dCcMassS_Mng::Clear() {
    mMassObjCount = 0;
    mMassAreaCount = 0;
    for (int i = 0; i < ARRAY_SIZE(mMassObjs); i++) {
        mMassObjs[i].Clear();
    }
    for (int i = 0; i < ARRAY_SIZE(mMassAreas); i++) {
        mMassAreas[i].Clear();
    }
    mCylAttr.SetR(0.0f);
    mCylAttr.SetH(0.0f);
    field_0x128 = 0;
    mResultCamBit = 4;
}

/* 800AD234-800AD310       .text Set__12dCcMassS_MngFP8cCcD_ObjUc */
void dCcMassS_Mng::Set(cCcD_Obj* i_obj, u8 i_priority) {
    if (mMassObjCount >= (s32)ARRAY_SIZE(mMassObjs)) {
        for (int i = 0; i < (s32)ARRAY_SIZE(mMassObjs); i++) {
            int priority = mMassObjs[i].GetPriority();
            if (priority > i_priority || (priority == i_priority && cM_rndF(1.0f) < 0.5f)) {
                mMassObjs[i].Set(i_obj, i_priority, NULL);
                return;
            }
        }
    } else {
        mMassObjs[mMassObjCount].Set(i_obj, i_priority, NULL);
        mMassObjCount++;
    }
}

/* 800AD310-800AD384       .text SetAreaChk__12dCcMassS_MngFP8cCcD_ObjUcPFP10fopAc_ac_cP4cXyzUl_v */
void dCcMassS_Mng::SetAreaChk(cCcD_Obj* p_obj, u8 i_priority, dCcMassS_ObjCallback callback) {
    if (mMassAreaCount >= 2) {
        for (int i = 0; i < (s32)ARRAY_SIZE(mMassAreas); i++) {
            if (mMassAreas[i].GetPriority() > i_priority) {
                mMassAreas[i].Set(p_obj, i_priority, callback);
                return;
            }
        }
    } else {
        mMassAreas[mMassAreaCount].Set(p_obj, i_priority, callback);
        mMassAreaCount++;
    }
}

/* 800AD384-800AD3D4       .text SetCam__12dCcMassS_MngFRC8cM3dGCps */
void dCcMassS_Mng::SetCam(const cM3dGCps& cps) {
    mCpsAttr.SetCps(cps);
    mFlag |= 0x1;
    mResultCam = 0;
}

/* 800AD3D4-800AD3DC       .text GetResultCam__12dCcMassS_MngCFv */
u32 dCcMassS_Mng::GetResultCam() const {
    return mResultCam;
}

/* 800AD3DC-800AD3F8       .text GetCamTopPos__12dCcMassS_MngFP3Vec */
void dCcMassS_Mng::GetCamTopPos(Vec* outPos) {
    *outPos  = mCamTopPos;
}
