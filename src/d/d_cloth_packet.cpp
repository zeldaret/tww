//
// Generated by dtk
// Translation Unit: d_cloth_packet.cpp
//

#include "d/dolzel.h" // IWYU pragma: keep
#include "d/d_cloth_packet.h"

/* 80062D5C-800630B0       .text __ct__15dCloth_packet_cFP7ResTIMGiiffP12dKy_tevstr_cPP4cXyz */
dCloth_packet_c::dCloth_packet_c(
    ResTIMG* i_toonimage, int flyGridSize, int hoistGridSize, float flyLength, float hoistLength, dKy_tevstr_c* tevstr, cXyz** posArr
) {
    JUT_ASSERT(43, i_toonimage != NULL);

    GXInitTexObj(
        &mToonTex,
        (u8*)i_toonimage + i_toonimage->imageOffset,
        i_toonimage->width,
        i_toonimage->height,
        (GXTexFmt)i_toonimage->format,
        (GXTexWrapMode)i_toonimage->wrapS,
        (GXTexWrapMode)i_toonimage->wrapT,
        i_toonimage->mipmapCount > 1
    );
    GXInitTexObjLOD(
        &mTexObj,
        (GXTexFilter)i_toonimage->minFilter,
        (GXTexFilter)i_toonimage->magFilter,
        i_toonimage->minLOD * 0.125f,
        i_toonimage->maxLOD * 0.125f,
        i_toonimage->LODBias * 0.01f,
        i_toonimage->biasClamp,
        i_toonimage->doEdgeLOD,
        (GXAnisotropy)i_toonimage->maxAnisotropy
    );

    mFlyGridSize = flyGridSize;
    mHoistGridSize = hoistGridSize;
    mFlyLength = flyLength;
    mHoistLength = hoistLength;
    mpTevstr = tevstr;
    mCurArr = 0;

    setMtx(g_mDoMtx_identity);

    if (posArr == NULL) {
        mpPosArr[0] = new cXyz[mFlyGridSize * mHoistGridSize];
        mpPosArr[1] = new cXyz[mFlyGridSize * mHoistGridSize];
    } else {
        mpPosArr[0] = posArr[0];
        mpPosArr[1] = posArr[1];
    }
    mpNrmArr[0] = new cXyz[mFlyGridSize * mHoistGridSize];
    mpNrmArr[1] = new cXyz[mFlyGridSize * mHoistGridSize];
    mpNrmArrBack[0] = new cXyz[mFlyGridSize * mHoistGridSize];
    mpNrmArrBack[1] = new cXyz[mFlyGridSize * mHoistGridSize];
    mpSpeedArr = new cXyz[mFlyGridSize * mHoistGridSize];
}

dCloth_packet_c::~dCloth_packet_c() {
}

/* 8006310C-8006313C       .text default_factor_checkCB__FP15dCloth_packet_cii */
void default_factor_checkCB(dCloth_packet_c*, int, int) {
    /* Nonmatching */
}

/* 8006313C-8006337C       .text init__15dCloth_packet_cFv */
void dCloth_packet_c::init() {
    /* Nonmatching */
}

/* 8006337C-80063400       .text setGlobalWind__15dCloth_packet_cFP4cXyz */
void dCloth_packet_c::setGlobalWind(cXyz* wind) {
    Mtx mtx;
    MTXCopy(mMtx, mtx);
    // FIXME: Is there a better way to set the translation?
    mtx[2][3] = 0.0f;
    mtx[1][3] = 0.0f;
    mtx[0][3] = 0.0f;
    MTXCopy(mtx, mDoMtx_stack_c::get());
    MTXInverse(mDoMtx_stack_c::get(), mDoMtx_stack_c::get());
    MTXMultVec(mDoMtx_stack_c::get(), wind, &mGlobalWind);
}

/* 80063400-80063728       .text cloth_move__15dCloth_packet_cFv */
void dCloth_packet_c::cloth_move() {
    /* Nonmatching */
    cXyz wind = mGlobalWind;
    wind *= mWindSpeed + mWindSpeedWave * cM_ssin(mWave);

    cXyz* pPosOld = mpPosArr[mCurArr];
    cXyz* pNrmOld = mpNrmArr[mCurArr];
    mCurArr ^= 1;
    cXyz* pPosNew = mpPosArr[mCurArr];

    // FIXME: Subtle math differences here.
    const float distFly = mFlyLength / (f32)(mFlyGridSize - 1) * mFlyFlex;
    const float distHoist = mHoistLength / (f32)(mHoistGridSize - 1) * mHoistFlex;
    const float distBoth = std::sqrtf(distFly * distFly + distHoist * distHoist);

    for (int y = 0; y < mHoistGridSize; y++) {
        for (int x = 0; x < mFlyGridSize; x++) {
            const cXyz factor = getFactor(pPosOld, pNrmOld, &wind, distFly, distHoist, distBoth, x, y);
            mpSpeedArr[x + y * mFlyGridSize] += factor;
            mpSpeedArr[x + y * mFlyGridSize] *= mDrag;

            pPosNew[x + y * mFlyGridSize] = pPosOld[x + y * mFlyGridSize];
            pPosNew[x + y * mFlyGridSize] += mpSpeedArr[x + y * mFlyGridSize];
        }
    }

    setNrm();

    DCStoreRangeNoSync(mpPosArr[mCurArr], mFlyGridSize * mHoistGridSize * sizeof(cXyz));
    DCStoreRangeNoSync(mpNrmArr[mCurArr], mFlyGridSize * mHoistGridSize * sizeof(cXyz));
    DCStoreRangeNoSync(mpNrmArrBack[mCurArr], mFlyGridSize * mHoistGridSize * sizeof(cXyz));
}

/* 80063728-800638E4       .text draw__15dCloth_packet_cFv */
void dCloth_packet_c::draw() {
    /* Nonmatching */
}

/* 800638E4-80063A10       .text get_cloth_anim_sub_factor__FP4cXyzP4cXyzP4cXyzff */
void get_cloth_anim_sub_factor(cXyz* pPos, cXyz* pOther, cXyz* pDst, float restDist, float springFactor) {
    /* Nonmatching */
    // FIXME: Logic seems right, but the function stack and ordering are slightly off.
    const cXyz diff = *pOther - *pPos;
    cXyz norm = diff.normZP();
    const float dist = pPos->abs(*pOther);
    norm *= (dist - restDist) * springFactor;
    *pDst += norm;
}

/* 80063A10-80063D84       .text getFactor__15dCloth_packet_cFP4cXyzP4cXyzP4cXyzfffii */
cXyz dCloth_packet_c::getFactor(cXyz* pPos, cXyz* pNrm, cXyz* pSpeed, float distFly, float distHoist, float distBoth, int x, int y) {
    /* Nonmatching */
    if (mpFactorCheckCB(this, x, y) != 0) {
        return cXyz::Zero;
    }

    cXyz pos = pPos[x + y * mFlyGridSize];
    const float speedDotNrm = VECDotProduct(pSpeed, &pNrm[x + y * mFlyGridSize]);
    cXyz ret = pNrm[x + y * mFlyGridSize] * speedDotNrm;

    // FIXME: Somehow the neighbor checks use a bitfield, and the bit flags are in static memory.
    const bool hasLeftNeighbor = x != 0;
    const bool hasRightNeighbor = x != mFlyGridSize - 1;
    const bool hasTopNeighbor = y != 0;
    const bool hasBottomNeighbor = y != mHoistGridSize - 1;
    if (hasLeftNeighbor) {
        get_cloth_anim_sub_factor(&pos, &pPos[x - 1 + y * mFlyGridSize], &ret, distFly, mSpring);
    }
    if (hasRightNeighbor) {
        get_cloth_anim_sub_factor(&pos, &pPos[x + 1 + y * mFlyGridSize], &ret, distFly, mSpring);
    }
    if (hasTopNeighbor) {
        get_cloth_anim_sub_factor(&pos, &pPos[x + (y - 1) * mFlyGridSize], &ret, distHoist, mSpring);
    }
    if (hasBottomNeighbor) {
        get_cloth_anim_sub_factor(&pos, &pPos[x + (y + 1) * mFlyGridSize], &ret, distHoist, mSpring);
    }
    if (hasLeftNeighbor && hasTopNeighbor) {
        get_cloth_anim_sub_factor(&pos, &pPos[x - 1 + (y - 1) * mFlyGridSize], &ret, distBoth, mSpring);
    }
    if (hasLeftNeighbor && hasBottomNeighbor) {
        get_cloth_anim_sub_factor(&pos, &pPos[x - 1 + (y + 1) * mFlyGridSize], &ret, distBoth, mSpring);
    }
    if (hasRightNeighbor && hasTopNeighbor) {
        get_cloth_anim_sub_factor(&pos, &pPos[x + 1 + (y - 1) * mFlyGridSize], &ret, distBoth, mSpring);
    }
    if (hasRightNeighbor && hasBottomNeighbor) {
        get_cloth_anim_sub_factor(&pos, &pPos[x + 1 + (y + 1) * mFlyGridSize], &ret, distBoth, mSpring);
    }

    return ret;
}

/* 80063D84-800642D0       .text setNrm__15dCloth_packet_cFv */
void dCloth_packet_c::setNrm() {
    /* Nonmatching */
    cXyz *pPos = mpPosArr[mCurArr];
    cXyz *pNrm = mpNrmArr[mCurArr];
    mWave += mWaveSpeed;
    field_0xF0 += field_0xF2;

    for (int y = 0; y < mHoistGridSize; y++) {
        for (int x = 0; x < mFlyGridSize; x++) {
            cXyz pos = pPos[x + y * mFlyGridSize];
            cXyz total = cXyz::Zero;
            if (x != 0) {
                // FIXME: y Â± 1 is lifted out of the conditionals and reused when it should be calculated in-place.
                //  This makes the stack not match either.
                cXyz x_diff = pPos[x - 1 + y * mFlyGridSize] - pos;
                if (y != 0) {
                    cXyz y_diff = pPos[x + (y - 1) * mFlyGridSize] - pos;
                    cXyz prod = y_diff.outprod(x_diff);
                    cXyz norm = prod.normZP();
                    total += norm;
                }
                if (y != mHoistGridSize - 1) {
                    cXyz y_diff = pPos[x + (y + 1) * mFlyGridSize] - pos;
                    cXyz prod = x_diff.outprod(y_diff);
                    cXyz norm = prod.normZP();
                    total += norm;
                }
            }
            if (x != mFlyGridSize - 1) {
                cXyz x_diff = pPos[x + 1 + y * mFlyGridSize] - pos;
                if (y != 0) {
                    cXyz y_diff = pPos[x + (y - 1) * mFlyGridSize] - pos;
                    cXyz prod = x_diff.outprod(y_diff);
                    cXyz norm = prod.normZP();
                    total += norm;
                }
                if (y != mHoistGridSize - 1) {
                    cXyz y_diff = pPos[x + (y + 1) * mFlyGridSize] - pos;
                    cXyz prod = y_diff.outprod(x_diff);
                    cXyz norm = prod.normZP();
                    total += norm;
                }
            }

            total = total.normZP();

            mDoMtx_YrotS(mDoMtx_stack_c::get(), mRotateY * cM_ssin(mWave + mRipple * (x + y)));
            cXyz temp;
            MTXMultVec(mDoMtx_stack_c::get(), &total, &temp);
            pNrm[x + mFlyGridSize * y] = temp.normZP();
        }
    }

    // Set all back normals to the negative front normals.
    cXyz* pNrmBack = mpNrmArrBack[mCurArr];
    for (int y = 0; y < mHoistGridSize; y++) {
        for (int x = 0; x < mFlyGridSize; x++) {
            pNrmBack->x = -pNrm->x;
            pNrmBack->y = -pNrm->y;
            pNrmBack->z = -pNrm->z;
            pNrmBack++;
            pNrm++;
        }
    }
}

/* 800642D0-800642FC       .text setMtx__15dCloth_packet_cFPA4_f */
void dCloth_packet_c::setMtx(Mtx mtx) {
    MTXCopy(mtx, mMtx);
}

/* 800642FC-80064330       .text cloth_draw__15dCloth_packet_cFv */
void dCloth_packet_c::cloth_draw() {
    /* Nonmatching */
}

/* 80064330-8006441C       .text TexObjInit__15dCloth_packet_cFP7ResTIMG */
void dCloth_packet_c::TexObjInit(ResTIMG*) {
    /* Nonmatching */
}

/* 8006441C-80064444       .text TexObjLoad__15dCloth_packet_cFv */
void dCloth_packet_c::TexObjLoad() {
    /* Nonmatching */
}

/* 80064444-80064718       .text TevSetting__15dCloth_packet_cFv */
void dCloth_packet_c::TevSetting() {
    /* Nonmatching */
}

/* 80064718-8006487C       .text plot__15dCloth_packet_cFv */
void dCloth_packet_c::plot() {
    /* Nonmatching */
}

/* 8006487C-800649C4       .text dCloth_packet_create__FP7ResTIMGP7ResTIMGiiffP12dKy_tevstr_cPP4cXyz */
dCloth_packet_c* dCloth_packet_create(ResTIMG*, ResTIMG*, int, int, float, float, dKy_tevstr_c*, cXyz**) {
    /* Nonmatching */
}

/* 800649C4-80064C98       .text TevSetting__18dCloth_packetXlu_cFv */
void dCloth_packetXlu_c::TevSetting() {
    /* Nonmatching */
}

/* 80064C98-80064CF8       .text cloth_draw__18dCloth_packetXlu_cFv */
void dCloth_packetXlu_c::cloth_draw() {
    /* Nonmatching */
}

/* 80064CF8-80064E48       .text dCloth_packetXlu_create__FP7ResTIMGP7ResTIMGiiffP12dKy_tevstr_cPP4cXyz */
dCloth_packetXlu_c* dCloth_packetXlu_create(ResTIMG*, ResTIMG*, int, int, float, float, dKy_tevstr_c*, cXyz**) {
    /* Nonmatching */
}

void* dClothVobj03_c::top_pointer;
void* dClothVobj04_c::top_pointer;
void* dClothVobj05_c::top_pointer;
void* dClothVobj07_0_c::top_pointer;

const s32 dClothVobj03_c::cloth_counter = -1;
const s32 dClothVobj04_c::cloth_counter = -1;
const s32 dClothVobj05_c::cloth_counter = -1;
const s32 dClothVobj07_0_c::cloth_counter = -1;

/* 80064E48-80064F0C       .text cloth_copy__14dClothVobj03_cFv */
void dClothVobj03_c::cloth_copy() {
    /* Nonmatching */
}

/* 80064F0C-80065020       .text init__14dClothVobj03_cFv */
void dClothVobj03_c::init() {
    /* Nonmatching */
}

/* 80065020-8006515C       .text cloth_move__14dClothVobj03_cFv */
void dClothVobj03_c::cloth_move() {
    /* Nonmatching */
}

/* 8006515C-80065268       .text TexObjInit__14dClothVobj03_cFP7ResTIMG */
void dClothVobj03_c::TexObjInit(ResTIMG*) {
    /* Nonmatching */
}

/* 80065268-800652A8       .text TexObjLoad__14dClothVobj03_cFv */
void dClothVobj03_c::TexObjLoad() {
    /* Nonmatching */
}

/* 800652A8-800653F4       .text dClothVobj03_create__FP7ResTIMGP7ResTIMGP12dKy_tevstr_cPP4cXyz */
dClothVobj03_c* dClothVobj03_create(ResTIMG*, ResTIMG*, dKy_tevstr_c*, cXyz**) {
    /* Nonmatching */
}

/* 800653F4-800654B8       .text cloth_copy__14dClothVobj04_cFv */
void dClothVobj04_c::cloth_copy() {
    /* Nonmatching */
}

/* 800654B8-800655CC       .text init__14dClothVobj04_cFv */
void dClothVobj04_c::init() {
    /* Nonmatching */
}

/* 800655CC-80065700       .text cloth_move__14dClothVobj04_cFv */
void dClothVobj04_c::cloth_move() {
    /* Nonmatching */
}

/* 80065700-8006580C       .text TexObjInit__14dClothVobj04_cFP7ResTIMG */
void dClothVobj04_c::TexObjInit(ResTIMG*) {
    /* Nonmatching */
}

/* 8006580C-8006584C       .text TexObjLoad__14dClothVobj04_cFv */
void dClothVobj04_c::TexObjLoad() {
    /* Nonmatching */
}

/* 8006584C-80065998       .text dClothVobj04_create__FP7ResTIMGP7ResTIMGP12dKy_tevstr_cPP4cXyz */
dClothVobj04_c* dClothVobj04_create(ResTIMG*, ResTIMG*, dKy_tevstr_c*, cXyz**) {
    /* Nonmatching */
}

/* 80065998-80065A5C       .text cloth_copy__14dClothVobj05_cFv */
void dClothVobj05_c::cloth_copy() {
    /* Nonmatching */
}

/* 80065A5C-80065B70       .text init__14dClothVobj05_cFv */
void dClothVobj05_c::init() {
    /* Nonmatching */
}

/* 80065B70-80065CA0       .text cloth_move__14dClothVobj05_cFv */
void dClothVobj05_c::cloth_move() {
    /* Nonmatching */
}

/* 80065CA0-80065DAC       .text TexObjInit__14dClothVobj05_cFP7ResTIMG */
void dClothVobj05_c::TexObjInit(ResTIMG*) {
    /* Nonmatching */
}

/* 80065DAC-80065DEC       .text TexObjLoad__14dClothVobj05_cFv */
void dClothVobj05_c::TexObjLoad() {
    /* Nonmatching */
}

/* 80065DEC-80065DF8       .text dClothVobj05_VtxFactorCB__FP15dCloth_packet_cii */
void dClothVobj05_VtxFactorCB(dCloth_packet_c*, int, int) {
    /* Nonmatching */
}

/* 80065DF8-80065F50       .text dClothVobj05_create__FP7ResTIMGP7ResTIMGP12dKy_tevstr_cPP4cXyz */
dClothVobj05_c* dClothVobj05_create(ResTIMG*, ResTIMG*, dKy_tevstr_c*, cXyz**) {
    /* Nonmatching */
}

/* 80065F50-80066014       .text cloth_copy__16dClothVobj07_0_cFv */
void dClothVobj07_0_c::cloth_copy() {
    /* Nonmatching */
}

/* 80066014-80066128       .text init__16dClothVobj07_0_cFv */
void dClothVobj07_0_c::init() {
    /* Nonmatching */
}

/* 80066128-8006625C       .text cloth_move__16dClothVobj07_0_cFv */
void dClothVobj07_0_c::cloth_move() {
    /* Nonmatching */
}

/* 8006625C-80066368       .text TexObjInit__16dClothVobj07_0_cFP7ResTIMG */
void dClothVobj07_0_c::TexObjInit(ResTIMG*) {
    /* Nonmatching */
}

/* 80066368-800663A8       .text TexObjLoad__16dClothVobj07_0_cFv */
void dClothVobj07_0_c::TexObjLoad() {
    /* Nonmatching */
}

/* 800663A8-800663B4       .text dClothVobj07_0_VtxFactorCB__FP15dCloth_packet_cii */
void dClothVobj07_0_VtxFactorCB(dCloth_packet_c*, int, int) {
    /* Nonmatching */
}

/* 800663B4-8006650C       .text dClothVobj07_0_create__FP7ResTIMGP7ResTIMGP12dKy_tevstr_cPP4cXyz */
dClothVobj07_0_c* dClothVobj07_0_create(ResTIMG*, ResTIMG*, dKy_tevstr_c*, cXyz**) {
    /* Nonmatching */
}
