//
// Generated by dtk
// Translation Unit: d_kankyo_rain.cpp
//

#include "d/d_kankyo_rain.h"
#include "d/d_bg_s_gnd_chk.h"
#include "d/d_bg_s_roof_chk.h"
#include "d/d_com_inf_game.h"
#include "d/d_kankyo.h"
#include "d/d_kankyo_wether.h"
#include "d/d_procname.h"
#include "d/d_snap.h"
#include "f_op/f_op_camera_mng.h"
#include "f_op/f_op_kankyo_mng.h"
#include "m_Do/m_Do_audio.h"
#include "m_Do/m_Do_lib.h"
#include "JSystem/JKernel/JKRHeap.h"

static u32 now_room = -1;

/* 8008AA30-8008AB3C       .text vectle_calc__FP10DOUBLE_POSP4cXyz */
void vectle_calc(DOUBLE_POS* i_pos, cXyz* o_out) {
    double s = sqrt(i_pos->x * i_pos->x + i_pos->y * i_pos->y + i_pos->z * i_pos->z);

    if (s != 0.0) {
        o_out->x = i_pos->x / s;
        o_out->y = i_pos->y / s;
        o_out->z = i_pos->z / s;
    } else {
        o_out->x = 0.0;
        o_out->y = 0.0;
        o_out->z = 0.0;
    }
}

/* 8008AB3C-8008AB94       .text get_vectle_calc__FP4cXyzP4cXyzP4cXyz */
void get_vectle_calc(cXyz* param_0, cXyz* param_1, cXyz* param_2) {
    DOUBLE_POS pos;
    pos.x = param_1->x - param_0->x;
    pos.y = param_1->y - param_0->y;
    pos.z = param_1->z - param_0->z;

    vectle_calc(&pos, param_2);
}

/* 8008AB94-8008ABB4       .text dKyr_get_vectle_calc__FP4cXyzP4cXyzP4cXyz */
void dKyr_get_vectle_calc(cXyz* param_0, cXyz* param_1, cXyz* param_2) {
    get_vectle_calc(param_0, param_1, param_2);
}

/* 8008ABB4-8008AC64       .text dKy_set_eyevect_calc__FP12camera_classP3Vecff */
void dKy_set_eyevect_calc(camera_class* i_camera, Vec* param_1, f32 param_2, f32 param_3) {
    cXyz tmp;
    get_vectle_calc(&i_camera->mLookat.mEye, &i_camera->mLookat.mCenter, &tmp);
    param_1->x = i_camera->mLookat.mEye.x + tmp.x * param_2;
    param_1->y = (i_camera->mLookat.mEye.y + tmp.y * param_3) - 200.0f;
    param_1->z = i_camera->mLookat.mEye.z + tmp.z * param_2;
}

/* 8008AC64-8008AD60       .text dKy_set_eyevect_calc2__FP12camera_classP3Vecff */
void dKy_set_eyevect_calc2(camera_class* i_camera, Vec* param_1, f32 param_2, f32 param_3) {
    cXyz tmp;
    DOUBLE_POS pos;

    pos.x = i_camera->mLookat.mCenter.x - i_camera->mLookat.mEye.x;
    if (param_3 != 0.0f) {
        pos.y = i_camera->mLookat.mCenter.y - i_camera->mLookat.mEye.y;
    } else {
        pos.y = 0.0f;
    }
    pos.z = i_camera->mLookat.mCenter.z - i_camera->mLookat.mEye.z;

    vectle_calc(&pos, &tmp);

    param_1->x = i_camera->mLookat.mEye.x + tmp.x * param_2;
    param_1->y = i_camera->mLookat.mEye.y + tmp.y * param_3;
    param_1->z = i_camera->mLookat.mEye.z + tmp.z * param_2;

    if (param_3 == 0.0f) {
        param_1->y = 0.0f;
    }
}

static inline void dKyr_init_btitex(GXTexObj* i_obj, ResTIMG* i_img) {
    GXInitTexObj(i_obj, (&i_img->format + i_img->imageOffset), i_img->width, i_img->height,
                 (GXTexFmt)i_img->format, (GXTexWrapMode)i_img->wrapS, (GXTexWrapMode)i_img->wrapT,
                 (GXBool)(i_img->mipmapCount > 1));
}

/* 8008AD60-8008AE54       .text dKyr_set_btitex__FP9_GXTexObjP7ResTIMG */
void dKyr_set_btitex(GXTexObj* i_obj, ResTIMG* i_img) {
    GXInitTexObj(i_obj, (&i_img->format + i_img->imageOffset), i_img->width, i_img->height,
                 (GXTexFmt)i_img->format, (GXTexWrapMode)i_img->wrapS, (GXTexWrapMode)i_img->wrapT,
                 (GXBool)(i_img->mipmapCount > 1));

    GXInitTexObjLOD(i_obj, (GXTexFilter)i_img->minFilter, (GXTexFilter)i_img->magFilter,
                    i_img->minLOD * 0.125f, i_img->maxLOD * 0.125f, i_img->LODBias * 0.01f,
                    (GXBool)i_img->biasClamp, (GXBool)i_img->doEdgeLOD,
                    (GXAnisotropy)i_img->maxAnisotropy);

    GXLoadTexObj(i_obj, GX_TEXMAP0);
}

/* 8008AE54-8008B44C       .text dKyr_kamome_move__Fv */
void dKyr_kamome_move() {
    /* Nonmatching */
    WINDEFF_SET * pWind = g_env_light.mpWind;
    camera_class* pCamera = (camera_class*)dComIfGp_getCamera(0);
    dKyw_get_wind_vec();
}

/* 8008B44C-8008B504       .text dKyr_wind_init__Fv */
void dKyr_wind_init() {
    g_env_light.mpWind->mbHasCustomWindPower = false;
    g_env_light.mpWind->field_0x759 = 0;

    for (int i = 0; i < 2; i++) {
        g_env_light.mpWind->mKamomeEff[i].field_0x1e = 0;
        g_env_light.mpWind->mKamomeEff[i].field_0x18 = 0.0f;
        g_env_light.mpWind->mKamomeEff[i].field_0x1c = cM_rndF(1800.0f);
        g_env_light.mpWind->mKamomeEff[i].mpBaseEmitter = NULL;
    }
}

/* 8008B504-8008C4BC       .text dKyr_wind_move__Fv */
void dKyr_wind_move() {
    /* Nonmatching */
}

/* 8008C624-8008C888       .text dKyr_lenzflare_move__Fv */
void dKyr_lenzflare_move() {
    dKankyo_sun_Packet* pSunPkt = g_env_light.mpSunPacket;
    dKankyo_sunlenz_Packet* pLenzPkt = g_env_light.mpSunlenzPacket;
    camera_class* pCamera = (camera_class*)dComIfGp_getCamera(0);

    if (pSunPkt->mVisibility < 0.0001f)
        return;

    cXyz eyeVect;
    cXyz sunDirSmth;
    cXyz camFwd;
    cXyz vectle;
    cXyz projected;
    cXyz center;

    dKy_set_eyevect_calc(pCamera, &eyeVect, 7200.0005f, 7200.0005f);

    dKyr_get_vectle_calc(&eyeVect, pSunPkt->mPos, &sunDirSmth);
    pLenzPkt->mPositions[0] = pSunPkt->mPos[0];
    pLenzPkt->mPositions[1] = pSunPkt->mPos[0];

    mDoLib_project(pLenzPkt->mPositions, &projected);

    center.x = 320.0f;
    center.y = 240.0f;
    center.z = 0.0f;

    dKyr_get_vectle_calc(&center, &projected, &vectle);
    s16 angle = cM_atan2s(vectle.x, vectle.y);

    pLenzPkt->mAngleDeg = angle;
    pLenzPkt->mAngleDeg *= 0.005493164f;
    pLenzPkt->mAngleDeg += 180.0f;

    dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &camFwd);

    f32 size = sunDirSmth.abs(camFwd) * 350.0f + 250.0f;

    for (int i = 2; i < 8; i++) {
        pLenzPkt->mPositions[i].x = pSunPkt->mPos[0].x - sunDirSmth.x * size * i;
        pLenzPkt->mPositions[i].y = pSunPkt->mPos[0].y - sunDirSmth.y * size * i;
        pLenzPkt->mPositions[i].z = pSunPkt->mPos[0].z - sunDirSmth.z * size * i;
    }
}

/* 8008C888-8008C8B8       .text dKyr_moon_arrival_check__Fv */
BOOL dKyr_moon_arrival_check() {
    BOOL ret = false;
    if (g_env_light.mCurTime > 277.5f || g_env_light.mCurTime < 112.5f)
        ret = true;
    return ret;
}

/* 8008C8B8-8008CF68       .text dKyr_sun_move__Fv */
void dKyr_sun_move() {
    /* Nonmatching */
    dKankyo_sun_Packet* pSunPkt = g_env_light.mpSunPacket;
    dKankyo_sunlenz_Packet* pLenzPkt = g_env_light.mpSunlenzPacket;
    camera_class* pCamera = dComIfGp_getCamera(0);

    f32 staringAtSunAmount = 0.0f;
    u8 numPointsVisible = 0, numCenterPointsVisible = 0;
    u32 stType = dStage_stagInfo_GetSTType(dComIfGp_getStageStagInfo());
    cXyz lightDir;
    if (g_env_light.mBaseLightInfluence.mColor.r == 0 && stType != 2) {
        dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &g_env_light.mBaseLightInfluence.mPos, &lightDir);
    } else {
        dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &g_env_light.mSunPos2, &lightDir);
    }

    pSunPkt->mPos[0].x = pCamera->mLookat.mEye.x + lightDir.x * 8000.0f;
    pSunPkt->mPos[0].y = pCamera->mLookat.mEye.y + lightDir.y * 8000.0f;
    pSunPkt->mPos[0].z = pCamera->mLookat.mEye.z + lightDir.z * 8000.0f;

    f32 horizonY = (pSunPkt->mPos[0].y - pCamera->mLookat.mEye.y) / 8000.0f;
    if (horizonY < 0.0f)
        horizonY = 0.0f;
    if (horizonY >= 1.0f)
        horizonY = 1.0f;
    horizonY = 1.0f - horizonY;
    horizonY *= horizonY;
    f32 pulsePos = 1.0f - horizonY;

    if (dComIfGp_getStageStagInfo() != NULL) {
        dComIfGp_getStageStagInfo();
    }

    if (pSunPkt->field_0x3c != 0)
        pSunPkt->field_0x3c--;
    pSunPkt->field_0x3d = false;

    if (g_env_light.mCurTime > 95.7f && g_env_light.mCurTime < 292.5f) {
        f32 borderY = 0.0f;
        s32 numPointsCulled = 0;

        cLib_addCalc(&pSunPkt->mSunAlpha, 1.0f, 0.5f, 0.1f, 0.01f);

        if (pCamera != NULL) {
            borderY = pCamera->mCamera.m5F8;
        }

        cXyz projected;
        mDoLib_project(pSunPkt->mPos, &projected);

        static const cXy sun_chkpnt[] = {
            0.0f, 0.0f,
            -10.0f, -20.0f,
            10.0f, 20.0f,
            -20.0f, 10.0f,
            20.0f, -10.0f,
        };

        for (s32 i = 0; i < 5; i++) {
            f32 screenBottom = 490.0f - borderY;
            cXyz chkpnt;
            chkpnt.x = sun_chkpnt[i].x;
            chkpnt.y = sun_chkpnt[i].y;
            chkpnt.x = projected.x - chkpnt.x;
            chkpnt.y = projected.y - chkpnt.y;

            if (chkpnt.x > 0.0f && chkpnt.x < 640.0 && chkpnt.y > borderY && chkpnt.y < screenBottom) {
                if (pSunPkt->mVizChkData[i] >= 0xFFFFFF) {
                    numPointsVisible++;
                    if (i == 0)
                        numCenterPointsVisible++;
                }

                dComIfGd_peekZ(chkpnt.x, chkpnt.y, &pSunPkt->mVizChkData[i]);
            } else {
                numPointsCulled++;
            }
        }

        if (numPointsCulled != 0 && numPointsVisible != 0 && numCenterPointsVisible != 0) {
            numCenterPointsVisible = 1;
            numPointsVisible = 5;
        }

        if (numPointsVisible != 0) {
            if (pSunPkt->field_0x3c < 5)
                pSunPkt->field_0x3c += 2;
            pSunPkt->field_0x3d = true;
        }

        pLenzPkt->field_0x80 = pLenzPkt->field_0x88;
        pLenzPkt->field_0x84 = pLenzPkt->field_0x8c;
        pLenzPkt->field_0x88 = 1000000000.0f;
        pLenzPkt->field_0x8c = 0.0f;

        cXyz center;
        center.x = 320.0f;
        center.y = 240.0f;
        center.z = 0.0f;
        pLenzPkt->mDistFalloff = center.abs(projected);
        pLenzPkt->mDistFalloff /= 450.0f;
        if (pLenzPkt->mDistFalloff > 1.0f)
            pLenzPkt->mDistFalloff = 1.0f;
        pLenzPkt->mDistFalloff = 1.0f - pLenzPkt->mDistFalloff;
        staringAtSunAmount = (pLenzPkt->mDistFalloff * pLenzPkt->mDistFalloff);
        pLenzPkt->mDistFalloff = 1.0f - staringAtSunAmount;
        staringAtSunAmount = staringAtSunAmount * staringAtSunAmount;
    } else {
        cLib_addCalc(&pSunPkt->mSunAlpha, 0.0f, 0.5f, 0.1f, 0.01f);
        numPointsVisible = 0;
        pSunPkt->field_0x3c = 0;
        pSunPkt->field_0x3d = false;
    }

    if (g_env_light.mColpatWeather != 0 || (g_env_light.mColpatCurr != 0 && g_env_light.mColPatBlend > 0.5f)) {
        numCenterPointsVisible = 0;
        numPointsVisible = 0;
    }

    if (stType == 2) {
        numCenterPointsVisible = 0;
        numPointsVisible = 0;
    }

    if (g_env_light.mCurTime < 120.0f || g_env_light.mCurTime > 270.0f) {
        numCenterPointsVisible = 0;
        numPointsVisible = 0;
    }

    if (numCenterPointsVisible != 0) {
        if (numPointsVisible == 4)
            cLib_addCalc(&pSunPkt->mVisibility, 1.0f, 0.1f, 0.1f, 0.001f);
        if (numPointsVisible <= 3)
            cLib_addCalc(&pSunPkt->mVisibility, 0.0f, 0.1f, 0.2f, 0.001f);
        else
            cLib_addCalc(&pSunPkt->mVisibility, 1.0f, 0.5f, 0.2f, 0.01f);
    } else {
        if (numPointsVisible < 3)
            cLib_addCalc(&pSunPkt->mVisibility, 0.0f, 0.5f, 0.2f, 0.01f);
        else
            cLib_addCalc(&pSunPkt->mVisibility, 1.0f, 0.1f, 0.1f, 0.01f);
    }

    if (numPointsVisible >= 2) {
        g_env_light.mpSunlenzPacket->mbDrawLenzInSky = false;
    } else {
        g_env_light.mpSunlenzPacket->mbDrawLenzInSky = true;
    }

    if (pSunPkt->mPos[0].y > 0.0f && !g_env_light.mpSunlenzPacket->mbDrawLenzInSky) {
        dKy_set_actcol_ratio(1.0f - staringAtSunAmount * pSunPkt->mVisibility);
        dKy_set_bgcol_ratio(1.0f - staringAtSunAmount * pSunPkt->mVisibility);
        dKy_set_fogcol_ratio(pulsePos * staringAtSunAmount * pSunPkt->mVisibility * 0.5f + 1.0f);
        dKy_set_vrboxcol_ratio(pulsePos * staringAtSunAmount * pSunPkt->mVisibility * 0.5f + 1.0f);
    }

    if (dKyr_moon_arrival_check()) {
        f32 alpha = (pSunPkt->mPos[0].y - pCamera->mLookat.mEye.y) / -8000.0f;
        alpha *= alpha;
        alpha *= 6.0f;
        if (alpha > 1.0f)
            alpha = 1.0f;
        cLib_addCalc(&pSunPkt->mMoonAlpha, alpha, 0.2f, 0.01f, 0.001f);
    } else {
        cLib_addCalc(&pSunPkt->mMoonAlpha, 0.0f, 0.2f, 0.01f, 0.001f);
    }
}

/* 8008CF68-8008D0B4       .text dKyr_rain_init__Fv */
void dKyr_rain_init() {
    camera_class * pCamera = dComIfGp_getCamera(0);
    g_env_light.mpRainPacket->mpTxSnow01 = (u8*)dComIfG_getObjectRes("Always", ALWAYS_I8_TX_SNOW01);
    g_env_light.mpRainPacket->mpTxRingAHalf = (u8*)dComIfG_getObjectRes("Always", ALWAYS_BTI_TXA_RING_A_32HAFE);
    g_env_light.mpRainPacket->mCamEyePos = pCamera->mLookat.mEye;
    g_env_light.mpRainPacket->mCamCenterPos = pCamera->mLookat.mCenter;
    g_env_light.mpRainPacket->mCenterDeltaMul = 0.0f;
    g_env_light.mpRainPacket->field_0x3700 = 0.0f;
    g_env_light.mpRainPacket->mSibukiAlpha = 0.0f;
    g_env_light.mpRainPacket->mOverheadFade = 0.0f;
    g_env_light.mpRainPacket->mFwd1Fade = 0.0f;
    g_env_light.mpRainPacket->mFwdFade2 = 0.0f;
    g_env_light.mpRainPacket->mStatus = 0;
    g_env_light.mpRainPacket->mCenterDelta.x = 0.0f;
    g_env_light.mpRainPacket->mCenterDelta.y = 0.0f;
    g_env_light.mpRainPacket->mCenterDelta.z = 0.0f;
    for (u32 i = 0; i < ARRAY_SIZE(g_env_light.mpRainPacket->mEff); i++)
        g_env_light.mpRainPacket->mEff[i].mStatus = 0;
    g_env_light.mpRainPacket->mRainCount = 0;
}

/* 8008D0B4-8008D0DC       .text rain_bg_chk__FP19dKankyo_rain_Packeti */
void rain_bg_chk(dKankyo_rain_Packet* pPkt, int idx) {
    camera_class * pCamera = g_dComIfG_gameInfo.play.mCameraInfo[0].mpCamera;
    pPkt->mEff[idx].field_0x30 = pCamera->mLookat.mCenter.y + -800.0f;
}

/* 8008D0DC-8008D53C       .text overhead_bg_chk__Fv */
bool overhead_bg_chk() {
    /* Nonmatching - regalloc */
    camera_class * pCamera = dComIfGp_getCamera(0);
    bool ret = false;

    dBgS_ObjGndChk_All gndChk;
    dBgS_RoofChk roofChk;
    cXyz pos = pCamera->mLookat.mEye;
    pos.y += 50.0f;
    roofChk.SetPos(pos);

    if (dComIfG_Bgsp()->RoofChk(&roofChk) != 1000000000.0f)
        ret = true;
    pos.y += 10000.0f;
    gndChk.SetPos(&pos);

    if (dComIfG_Bgsp()->GroundCross(&gndChk) > (pCamera->mLookat.mEye.y + 50.0f))
        ret = true;

    return ret;
}

/* 8008D638-8008DAF0       .text forward_overhead_bg_chk__FP4cXyzf */
bool forward_overhead_bg_chk(cXyz* pPos, f32 dist) {
    /* Nonmatching - regalloc */
    camera_class * pCamera = dComIfGp_getCamera(0);
    bool ret = false;

    dBgS_ObjGndChk_All gndChk;
    dBgS_RoofChk roofChk;
    cXyz pos;
    cXyz lookDir;
    dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &lookDir);
    pos.x = pCamera->mLookat.mEye.x + lookDir.x * dist;
    pos.y = pCamera->mLookat.mEye.y + lookDir.y * dist;
    pos.z = pCamera->mLookat.mEye.z + lookDir.z * dist;
    pos.y = pCamera->mLookat.mEye.y + 50.f;

    *pPos = pos;
    roofChk.SetPos(pos);

    if (dComIfG_Bgsp()->RoofChk(&roofChk) != 1000000000.0f)
        ret = true;
    pos.y += 10000.0f;
    gndChk.SetPos(&pos);

    if (dComIfG_Bgsp()->GroundCross(&gndChk) > (pCamera->mLookat.mEye.y + 50.0f))
        ret = true;

    return ret;
}

/* 8008DAF0-8008E79C       .text dKyr_rain_move__Fv */
void dKyr_rain_move() {
    /* Nonmatching */
}

/* 8008E79C-8008F0BC       .text dKyr_housi_move__Fv */
void dKyr_housi_move() {
    /* Nonmatching */
}

/* 8008F0BC-8008F23C       .text dKyr_snow_init__Fv */
void dKyr_snow_init() {
    camera_class * pCamera = dComIfGp_getCamera(0);
    g_env_light.mpSnowPacket = new(0x20) dKankyo_snow_Packet();
    if (g_env_light.mpSnowPacket != NULL) {
        if (strcmp(dComIfGp_getStartStageName(), "Adanmae") != 0) {
            g_env_light.mpSnowPacket->mpTexture = (u8*)dComIfG_getObjectRes("Always", ALWAYS_I8_TX_SNOW01);
        } else {
            g_env_light.mpSnowPacket->mpTexture = (u8*)dComIfG_getStageRes("Stage", "ak_kazanbai00.bti");
        }

        for (u32 i = 0; i < ARRAY_SIZE(g_env_light.mpSnowPacket->mEff); i++)
            g_env_light.mpSnowPacket->mEff[i].mStatus = 0;
        g_env_light.mpSnowPacket->mEffCount = 0;
        g_env_light.mpSnowPacket->mOldEyePos = pCamera->mLookat.mEye;
    }
}

/* 8008F23C-8008F9FC       .text dKyr_snow_move__Fv */
void dKyr_snow_move() {
    /* Nonmatching */
}

/* 8008F9FC-8009065C       .text dKyr_kazanbai_move__Fv */
void dKyr_kazanbai_move() {
    /* Nonmatching */
}

/* 8009065C-80090C68       .text dKyr_kazanbai_tamari_move__Fv */
void dKyr_kazanbai_tamari_move() {
    /* Nonmatching */
}

/* 80090C68-80090D50       .text dKyr_star_init__Fv */
void dKyr_star_init() {
    g_env_light.mpStarPacket = new(0x20) dKankyo_star_Packet();
    if (g_env_light.mpStarPacket != NULL) {
        g_env_light.mpStarPacket->mpTexture = (u8*)dComIfG_getObjectRes("Always", ALWAYS_I8_TX_SNOW01);
        g_env_light.mpStarPacket->mStarEff[0].mSin = 1.0f;
        g_env_light.mpStarPacket->mCount = 0;
    }
}

/* 80090D50-80090DE0       .text dKyr_star_move__Fv */
void dKyr_star_move() {
    dKankyo_star_Packet * pPkt = g_env_light.mpStarPacket;
    pPkt->mCount = g_env_light.mStarCount;
    if (pPkt->mCount != 0) {
        f32 wave = fabsf(cM_fsin(pPkt->mStarEff[0].mAnimCounter));
        pPkt->mStarEff[0].mAnimCounter += 0.01f;
        pPkt->mStarEff[0].mSin = wave;
        cLib_addCalc(&pPkt->mStarEff[0].mSin, wave, 0.5f, 0.1f, 0.01f);
    }
}

/* 80090DE0-80091964       .text wave_move__Fv */
void wave_move() {
    /* Nonmatching */
    dScnKy_env_light_c& envLight = dKy_getEnvlight();
    dStage_FileList_dt_c* fili_p;
    camera_class* pCamera;
    fopAc_ac_c* pPlayer;
    cXyz* windVecP;
    dKankyo_wave_Packet* pPkt;
    f32 seaLevel;
    cXyz newPos2;
    cXyz eyevect;
    cXyz d0;
    cXyz newPos3;
    cXyz windPowVec2;
    cXyz windPowVec;
    cXyz windNrmVec2;
    cXyz vectle;
    cXyz pos;
    cXyz newPos;
    DOUBLE_POS deltaXZ;
    Mtx drawMtx;
    s32 roomNo;
    f32 windPow;
    s32 stageWindY;
    s16 windX;
    s16 windY;

    windPowVec = dKyw_get_wind_vecpow();

    fili_p = NULL;
    pPkt = g_env_light.mpWavePacket;
    pCamera = dComIfGp_getCamera(0);
    pPlayer = dComIfGp_getPlayer(0);

    roomNo = dComIfGp_roomControl_getStayNo();
    if (roomNo >= 0)
        fili_p = dComIfGp_roomControl_getStatusRoomDt(roomNo)->getFileListInfo();

    seaLevel;
    if (fili_p != NULL)
        seaLevel = dStage_FileList_dt_SeaLevel(fili_p);

    if (g_env_light.mWaveChan.mWaveFlatInter >= 1.0f)
        return;

    if (dComIfGd_getView() != NULL) {
        MTXInverse(dComIfGd_getViewRotMtx(), drawMtx);
    } else {
        return;
    }

    dKy_set_eyevect_calc2(pCamera, &eyevect, g_env_light.mWaveChan.mWaveSpawnDist, 0.0f);
    d0.zero();

    windVecP = dKyw_get_wind_vec();
    windPow = dKyw_get_wind_pow();
    windPowVec2 = *windVecP;

    if (dStage_stagInfo_GetSTType(dComIfGp_getStageStagInfo()) == 2) {
        stageWindY = 0;

        if (strcmp(dComIfGp_getStartStageName(), "LinkRM") == 0)
            stageWindY = 0x4000;
        else if (strcmp(dComIfGp_getStartStageName(), "Orichh") == 0)
            stageWindY = -0x4000;
        else if (strcmp(dComIfGp_getStartStageName(), "Ojhous2") == 0)
            stageWindY = 0x7fff;
        else if (strcmp(dComIfGp_getStartStageName(), "Omasao") == 0)
            stageWindY = -0x4000;
        else if (strcmp(dComIfGp_getStartStageName(), "Onobuta") == 0)
            stageWindY = 0x4000;

        if (dComIfGs_getWindX() == -1 && dComIfGs_getWindY() == -1) {
            windX = 0;
            windY = 0;
        } else {
            windX = g_env_light.mWind.mTactWindAngleX;
            windY = g_env_light.mWind.mTactWindAngleY;
        }

        windY += stageWindY;

        windNrmVec2.x = cM_scos(windX) * cM_scos(windY);
        windNrmVec2.y = cM_ssin(windX);
        windNrmVec2.z = cM_scos(windX) * cM_ssin(windY);

        windPowVec.x = 0.6f * windNrmVec2.x;
        windPowVec.y = 0.6f * windNrmVec2.y;
        windPowVec.z = 0.6f * windNrmVec2.z;
        windPowVec2 = windPowVec;
        windPow = 0.6f;
    }

    d0.zero();

    deltaXZ;
    deltaXZ.x = pCamera->mLookat.mCenter.x - pCamera->mLookat.mEye.x;
    deltaXZ.y = 0.0f;
    deltaXZ.z = pCamera->mLookat.mCenter.z - pCamera->mLookat.mEye.z;
    vectle_calc(&deltaXZ, &vectle);

    pPkt->mSkewDir = cM3d_VectorProduct2d(0.0f, 0.0f, -windPowVec2.x, -windPowVec2.z, vectle.x, vectle.z);
    pPkt->mSkewWidth = windPow * (1.0f - fabsf(windPowVec2.y)) * (1.0f - fabsf(windPowVec2.x * vectle.x + windPowVec2.z * vectle.z));
    pPkt->mSkewWidth *= 0.6f * fabsf(pPkt->mSkewDir);

    for (s32 i = 0; i < g_env_light.mWaveChan.mWaveCount; i++) {
        if (g_env_light.mWaveChan.mWaveReset)
            pPkt->mEff[i].mStatus = 0;

        switch (pPkt->mEff[i].mStatus) {
        case 0:
            {
                pPkt->mEff[i].mBasePos.x = eyevect.x;
                pPkt->mEff[i].mBasePos.y = seaLevel;
                pPkt->mEff[i].mBasePos.z = eyevect.z;
                pPkt->mEff[i].mPos.x = cM_rndFX(g_env_light.mWaveChan.mWaveSpawnRadius);
                pPkt->mEff[i].mPos.y = 0.0f;
                pPkt->mEff[i].mPos.z = cM_rndFX(g_env_light.mWaveChan.mWaveSpawnRadius);
                pPkt->mEff[i].mCounter = cM_rndF(65536.0f);
                pPkt->mEff[i].mAlpha = 0.0f;
                pPkt->mEff[i].field_0x32 = cM_rndF(65536.0f);
                pPkt->mEff[i].mStrengthEnv = 1.0f;
                pPkt->mEff[i].mScale = g_env_light.mWaveChan.mWaveScaleRand + cM_rndF(1.0f - g_env_light.mWaveChan.mWaveScaleRand);
                pPkt->mEff[i].mSpeed = pPkt->mEff[i].mScale;
                pPkt->mEff[i].mCounterSpeed = ((1.0f - pPkt->mEff[i].mScale) * 0.05f + 0.02f) * g_env_light.mWaveChan.mWaveCounterSpeedScale;
                pPkt->mEff[i].field_0x30 = 0;
                pPkt->mEff[i].mStatus++;
            }
            // fallthrough
        case 1:
        case 2:
            {
                pPkt->mEff[i].mPos.x += (windPowVec.x * g_env_light.mWaveChan.mWaveSpeed * pPkt->mEff[i].mSpeed) * (pPkt->mEff[i].mStrengthEnv * 0.5f + 0.5f) * (pPkt->mEff[i].mAlpha * 0.8f + 0.2f);
                pPkt->mEff[i].mPos.z += (windPowVec.z * g_env_light.mWaveChan.mWaveSpeed * pPkt->mEff[i].mSpeed) * (pPkt->mEff[i].mStrengthEnv * 0.5f + 0.5f) * (pPkt->mEff[i].mAlpha * 0.8f + 0.2f);
                pPkt->mEff[i].mCounter += pPkt->mEff[i].mCounterSpeed;
                pos.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
                pos.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
                pos.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;
                if (pos.abs(eyevect) > g_env_light.mWaveChan.mWaveSpawnRadius) {
                    pPkt->mEff[i].mBasePos.x = eyevect.x;
                    pPkt->mEff[i].mBasePos.z = eyevect.z;
                    if (pos.abs(eyevect) > (g_env_light.mWaveChan.mWaveSpawnRadius + 350.0f)) {
                        pPkt->mEff[i].mPos.x = cM_rndFX(g_env_light.mWaveChan.mWaveSpawnRadius);
                        pPkt->mEff[i].mPos.z = cM_rndFX(g_env_light.mWaveChan.mWaveSpawnRadius);
                    } else {
                        get_vectle_calc(&pos, &eyevect, &newPos);
                        pPkt->mEff[i].mPos.x = newPos.x * g_env_light.mWaveChan.mWaveSpawnRadius;
                        pPkt->mEff[i].mPos.z = newPos.z * g_env_light.mWaveChan.mWaveSpawnRadius;
                    }
                    pPkt->mEff[i].mAlpha = 0.0f;
                }
                pos.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
                pos.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
                pos.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;

                pPkt->mEff[i].mStrengthEnv = 1.0f;
                for (s32 j = 0; j < 10; j++) {
                    if (envLight.mpWaveInfl[j] == NULL)
                        continue;

                    envLight.mpWaveInfl[j]->mPos.y = pos.y;
                    f32 dist = pos.abs(envLight.mpWaveInfl[j]->mPos);
                    f32 outerRadius = envLight.mpWaveInfl[j]->mOuterRadius;
                    f32 innerRadius = envLight.mpWaveInfl[j]->mInnerRadius;
                    if (dist < outerRadius) {
                        if (dist < innerRadius) {
                            pPkt->mEff[i].mStrengthEnv = 0.0f;
                            break;
                        }

                        f32 range = outerRadius - innerRadius;
                        if (range > 0.0f) {
                            f32 fade = (dist - innerRadius) / range;
                            if (pPkt->mEff[i].mStrengthEnv > fade)
                                pPkt->mEff[i].mStrengthEnv = fade;
                        } else {
                            pPkt->mEff[i].mStrengthEnv = 0.0f;
                        }
                    }
                }

                if (g_env_light.mWaveChan.mWaveFlatInter > 0.0f) {
                    newPos3 = pCamera->mLookat.mEye;
                    newPos3.y = pos.y;

                    f32 dist = pos.abs(newPos3);
                    f32 innerRadius = g_env_light.mWaveChan.mWaveFlatInter * (g_env_light.mWaveChan.mWaveSpawnRadius * 1.5f);
                    f32 outerRadius = innerRadius + 1000.0f;
                    f32 range = outerRadius - innerRadius;
                    if (range > 0.0f) {
                        f32 fade = (dist - innerRadius) / range;
                        if (pPkt->mEff[i].mStrengthEnv > fade)
                            pPkt->mEff[i].mStrengthEnv = fade;
                    } else {
                        pPkt->mEff[i].mStrengthEnv = 0.0f;
                    }
                }

                {
                    newPos3 = pPlayer->current.pos;
                    newPos3.y = pos.y;

                    f32 dist = pos.abs(newPos3);
                    f32 innerRadius = 200.0f;
                    f32 outerRadius = 2000.0f;
                    f32 range = outerRadius - innerRadius;
                    if (dist < outerRadius) {
                        if (innerRadius < dist) {
                            pPkt->mEff[i].mStrengthEnv = 0.0f;
                        } else {
                            f32 fade = (dist - innerRadius) / range;
                            pPkt->mEff[i].mStrengthEnv *= fade;
                        }
                    }
                }
            }
            break;
        case 3:
            {
                pPkt->mEff[i].mStatus = 0;
            }
            break;
        default:
            break;
        }

        {
            newPos2.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
            newPos2.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
            newPos2.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;
            f32 dist = newPos2.abs(pCamera->mLookat.mEye);
            if (dist < 0.0f)
                dist = 0.0f;
            f32 alphaTarget = 1.0f - (dist / (2.0f * g_env_light.mWaveChan.mWaveSpawnDist));
            alphaTarget *= 1.03f;
            alphaTarget *= (f32)sin(pPkt->mEff[i].mCounter);
            if (alphaTarget > 1.0f)
                alphaTarget = 1.0f;
            if (alphaTarget < 0.0f)
                alphaTarget = 0.0f;
            cLib_addCalc(&pPkt->mEff[i].mAlpha, alphaTarget, 0.5f, 0.5f, 0.001f);
            pPkt->mEff[i].mBasePos.y = seaLevel;
        }
    }
}

/* 80091964-80092294       .text cloud_shadow_move__Fv */
void cloud_shadow_move() {
    /* Nonmatching */
}

/* 80092294-80092310       .text light_at_hit_check__FP4cXyz */
BOOL light_at_hit_check(cXyz* pPos) {
    dCcMassS_HitInf hitInfo;
    BOOL ret = FALSE;
    fopAc_ac_c * pActor;
    u32 res = dComIfG_Ccsp()->mMass_Mng.Chk(pPos, &pActor, &hitInfo);
    if (((res & 1) != 0) && (hitInfo.GetAtHitObj()->GetAtType() & AT_TYPE_LIGHT) != 0)
        ret = TRUE;
    return ret;
}

/* 80092310-80092330       .text dKyr_poison_live_check__Fv */
BOOL dKyr_poison_live_check() {
    BOOL ret = FALSE;
    if (g_env_light.mPoisonCount != 0)
        ret = TRUE;
    return ret;
}

/* 80092330-80092448       .text dKyr_poison_light_colision__Fv */
void dKyr_poison_light_colision() {
    /* Nonmatching */
    dKankyo_poison_Packet * pPkt = g_env_light.mpPoisonPacket;
    if (!dKyr_poison_live_check())
        return;

    // inline should match, but doesn't
#if 0
    dComIfG_Ccsp()->mMass_Mng.SetAttr(220.0f, 140.0f, 0x0B, 0x03);
#else
    dCcMassS_Mng * mass = &dComIfG_Ccsp()->mMass_Mng;
    dComIfG_Ccsp()->mMass_Mng.mCylAttr.SetR(220.0f);
    dComIfG_Ccsp()->mMass_Mng.mCylAttr.SetH(140.0f);
    mass->field_0x128 = 0x0B;
    mass->mResultCamBit = 0x03;
#endif

    f32 halfHeight = 70.0f;
    for (s32 i = 0; i < g_env_light.mPoisonCount; i++) {
        cXyz pos = pPkt->mBasePos + pPkt->mEff[i].mPos;
        pos.y -= halfHeight;
        if (light_at_hit_check(&pos) && pPkt->mEff[i].mStatus == 1) {
            pPkt->mEff[i].mStatus = 2;
            pPkt->mEff[i].field_0x2e = 60;
        }
    }
}

/* 80092448-8009258C       .text poison_init__Fv */
void poison_init() {
    g_env_light.mpPoisonPacket = new(0x20) dKankyo_poison_Packet();
    g_env_light.mpPoisonPacket->field_0xbb9c.x = 0.0f;
    g_env_light.mpPoisonPacket->field_0xbb9c.y = 0.0f;
    g_env_light.mpPoisonPacket->field_0xbb9c.z = 0.0f;
    g_env_light.mpPoisonPacket->mCount = 0;
    if (g_env_light.mpPoisonPacket != NULL) {
        g_env_light.mpPoisonPacket->mpTexture = (u8*)dComIfG_getObjectRes("Always", ALWAYS_BTI_AK_SMOKE01);
        for (u32 i = 0; i < ARRAY_SIZE(g_env_light.mpPoisonPacket->mEff); i++)
            g_env_light.mpPoisonPacket->mEff[i].mStatus = 0;
        poison_move();
        now_room = dComIfGp_roomControl_getStayNo();
    }
}

/* 8009258C-800937BC       .text poison_move__Fv */
void poison_move() {
    /* Nonmatching */
}

/* 800937BC-800940D4       .text vrkumo_move__Fv */
void vrkumo_move() {
    /* Nonmatching */
}

/* 800940D4-80094144       .text dKy_wave_chan_init__Fv */
void dKy_wave_chan_init() {
    g_env_light.mWaveChan.mWaveCount = 0;
    g_env_light.mWaveChan.field_0x0 = -1.0f;
    g_env_light.mWaveChan.field_0x4 = 0.0f;
    g_env_light.mWaveChan.field_0x8 = 0.0f;
    g_env_light.mWaveChan.mWaveSpeed = 0.3f;
    g_env_light.mWaveChan.mWaveSpawnDist = 3000.0f;
    g_env_light.mWaveChan.mWaveSpawnRadius = 3150.0f;
    g_env_light.mWaveChan.mWaveReset = 0;
    g_env_light.mWaveChan.mWaveScale = 250.0f;
    g_env_light.mWaveChan.mWaveScaleBottom = 5.0f;
    g_env_light.mWaveChan.mWaveScaleRand = 0.217f;
    g_env_light.mWaveChan.mWaveCounterSpeedScale = 1.6f;
    g_env_light.mWaveChan.field_0x2f = 0;
    g_env_light.mWaveChan.mWaveSpeed = 0.1f;
}

/* 80094144-8009428C       .text snap_sunmoon_proc__FP4cXyzi */
void snap_sunmoon_proc(cXyz* pPos, int type) {
    dSnap_Obj snapObj;
    camera_class * pCamera = dComIfGp_getCamera(0);

    if (dComIfGp_checkPlayerStatus1(0, 0x08) != 0) {
        cXyz pos;
        pos.x = (pPos->x - pCamera->mLookat.mEye.x);
        pos.y = (pPos->y - pCamera->mLookat.mEye.y);
        pos.z = (pPos->z - pCamera->mLookat.mEye.z);
        pos.x *= 10.0f;
        pos.y *= 10.0f;
        pos.z *= 10.0f;
        pos.x += pCamera->mLookat.mEye.x;
        pos.y += pCamera->mLookat.mEye.y;
        pos.z += pCamera->mLookat.mEye.z;

        snapObj.SetGeoSph(pos, 8000.0f);
        if (type == 9)
            snapObj.SetInf(9, NULL, 0xFF, 4, 0x7FFF);
        else if (type == 0)
            snapObj.SetInf(7, NULL, 0xFF, 4, 0x7FFF);
        else
            snapObj.SetInf(8, NULL, 0xFF, 4, 0x7FFF);
        dSnap_RegistSnapObj(snapObj);
    }
}

/* 8009428C-8009514C       .text dKyr_drawSun__FPA4_fP4cXyzR8GXColorPPUc */
void dKyr_drawSun(Mtx drawMtx, cXyz* pPos, GXColor& reg0, u8** pImg) {
    /* Nonmatching */
    dKankyo_sun_Packet* pSunPkt;
    dKankyo_sunlenz_Packet* pSunlenzPkt;
    camera_class* pCamera;
    cXyz pos[4];
    cXyz sunPos;
    cXyz moonPos2;
    cXyz moonPos;
    cXyz vp;
    cXyz lp;
    bool bDrawSun;
    bool bDrawMoon;
    Mtx camMtx;
    Mtx rotMtx;
    GXColor reg1;
    GXTexObj texObj;

    pSunPkt = dKy_getEnvlight().mpSunPacket;
    pSunlenzPkt = dKy_getEnvlight().mpSunlenzPacket;
    pCamera = dComIfGp_getCamera(0);

    bDrawMoon = false;
    bDrawSun = false;
    if (pSunPkt->mSunAlpha > 0.0f)
        bDrawSun = true;
    if (pSunPkt->mMoonAlpha > 0.0f)
        bDrawMoon = true;

    if (bDrawSun | bDrawMoon) {
        sunPos = *pPos;

        u32 stType = dStage_stagInfo_GetSTType(dComIfGp_getStageStagInfo());
        if (dKy_getEnvlight().mBaseLightInfluence.mColor.r == 0 && stType != 2) {
            if (dKy_getEnvlight().mCurTime > 285.0f || dKy_getEnvlight().mCurTime < 105.0f)
                bDrawMoon = false;

            moonPos2 = *pPos;
        } else {
            moonPos.x = -(pPos->x - pCamera->mLookat.mEye.x);
            moonPos.y = -(pPos->y - pCamera->mLookat.mEye.y);
            moonPos.z = -(pPos->z - pCamera->mLookat.mEye.z);

            moonPos2.x = moonPos.x + pCamera->mLookat.mEye.x;
            moonPos2.y = moonPos.y + pCamera->mLookat.mEye.y;
            moonPos2.z = moonPos.z + pCamera->mLookat.mEye.z;
        }

        int dayofweek = dKy_get_dayofweek();
        if (dComIfGs_getTime() < 180.0f) {
            if (dayofweek != 0)
                dayofweek--;
            else
                dayofweek = 6;
        }

        s32 texidx;
        f32 flipX;
        switch (dayofweek) {
        case 0: texidx = 0; flipX = 1.0f; break;
        case 1: texidx = 1; flipX = 1.0f; break;
        case 2: texidx = 2; flipX = 1.0f; break;
        case 3: texidx = 3; flipX = 1.0f; break;
        case 4: texidx = 3; flipX = -1.0f; break;
        case 5: texidx = 2; flipX = -1.0f; break;
        case 6: texidx = 1; flipX = -1.0f; break;
        }

        reg0.r = dKy_getEnvlight().mFogColor.r;
        reg0.g = dKy_getEnvlight().mFogColor.g;
        reg0.b = dKy_getEnvlight().mFogColor.b;
        reg0.a = 0xFF;

        reg1.r = 0x00;
        reg1.g = 0x00;
        reg1.b = 0x00;
        reg1.a = 0xFF;

        if (dComIfGd_getView() != NULL) {
            MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
        } else {
            if (pSunPkt->field_0x3c < 5)
                pSunPkt->field_0x3c += 2;
            pSunPkt->field_0x3d = true;
            return;
        }

        dKyr_set_btitex(&texObj, (ResTIMG*)pImg[texidx]);

        GXSetNumChans(0);
        GXSetTevColor(GX_TEVREG0, reg0);
        GXSetTevColor(GX_TEVREG1, reg1);
        GXSetNumTexGens(1);
        GXSetTexCoordGen2(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY, GX_FALSE, GX_PTIDENTITY);
        GXSetNumTevStages(1);
        GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
        GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
        GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
        GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
        GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
        GXSetZMode(GX_TRUE, GX_LEQUAL, GX_FALSE);
        GXSetNumIndStages(0);
        GXSetCullMode(GX_CULL_NONE);

        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
        GXClearVtxDesc();
        GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
        GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);

        if (bDrawMoon == true) {
            cXyz camfwd;
            f32 dayscale[7] = { 1.0f, 0.83f, 0.6f, 0.6f, 0.6f, 0.6f, 0.83f, };

            snap_sunmoon_proc(&moonPos2, texidx);
            dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &camfwd);

            f32 cam_distXZ = sqrtf(camfwd.x*camfwd.x + camfwd.z*camfwd.z);
            f32 cam_theta = atan2f(camfwd.x, camfwd.z);
            f32 cam_phi = atan2f(camfwd.y, cam_distXZ);

            f32 moon_distXZ = sqrtf(moonPos.x*moonPos.x + moonPos.z*moonPos.z);
            f32 moon_theta = atan2f(moonPos.x, moonPos.z);
            f32 moon_phi = atan2f(moonPos.y, moon_distXZ);

            f32 angle = 45.0f + (((moon_theta - cam_theta) / -8.0f) * moon_phi) * 360.0f;
            MTXRotDeg(rotMtx, 'Z', angle);
            MTXConcat(camMtx, rotMtx, camMtx);
            GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
            GXSetCurrentMtx(GX_PNMTX0);

            reg0.r = 0xF3;
            reg0.g = 0xFF;
            reg0.b = 0x94;

            f32 size = 700.0f;
            reg0.a = pSunPkt->mMoonAlpha * 255.0f;
            GXSetTevColor(GX_TEVREG0, reg0);

            for (s32 j = 0; j < 2; j++) {
                if (j == 1) {
                    GXInitTexObj(&texObj, pSunlenzPkt->mpTexSnow01, 64, 64, GX_TF_I8, GX_CLAMP, GX_CLAMP, GX_FALSE);
                    GXInitTexObjLOD(&texObj, GX_LINEAR, GX_LINEAR, 0.0f, 0.0f, 0.0f, GX_FALSE, GX_FALSE, GX_ANISO_1);
                    GXLoadTexObj(&texObj, GX_TEXMAP0);
                    size *= 1.7f;
                    reg0.a = pSunPkt->mMoonAlpha * 76.0f;
                    reg0.r = 0xFF;
                    reg0.g = 0xFF;
                    reg0.b = 0xCF;
                    reg1.r = 0xC5;
                    reg1.g = 0x69;
                    reg1.b = 0x23;
                    MTXRotDeg(rotMtx, 'Z', 50.0f * flipX);
                    MTXConcat(camMtx, rotMtx, camMtx);
                    GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
                    GXSetCurrentMtx(GX_PNMTX0);
                }

                GXSetTevColor(GX_TEVREG0, reg0);
                GXSetTevColor(GX_TEVREG1, reg1);

                vp.x = -size * flipX;
                vp.y = size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[0].x = moonPos2.x + lp.x;
                pos[0].y = moonPos2.y + lp.y;
                pos[0].z = moonPos2.z + lp.z;

                vp.x = size * flipX;
                vp.y = size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[1].x = moonPos2.x + lp.x;
                pos[1].y = moonPos2.y + lp.y;
                pos[1].z = moonPos2.z + lp.z;

                if (texidx == 0) {
                    vp.x = size * flipX;
                    vp.y = -size;
                } else {
                    vp.x = size * flipX * dayscale[dayofweek];
                    vp.y = -size * dayscale[dayofweek];
                }
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[2].x = moonPos2.x + lp.x;
                pos[2].y = moonPos2.y + lp.y;
                pos[2].z = moonPos2.z + lp.z;

                vp.x = -size * flipX;
                vp.y = -size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[3].x = moonPos2.x + lp.x;
                pos[3].y = moonPos2.y + lp.y;
                pos[3].z = moonPos2.z + lp.z;

                GXBegin(GX_QUADS, GX_VTXFMT0, 4);
                GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
                GXTexCoord2s16(0, 0);
                GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
                GXTexCoord2s16(0xFF, 0);
                GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
                GXTexCoord2s16(0xFF, 0xFF);
                GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
                GXTexCoord2s16(0, 0xFF);
                GXEnd();
            }
        }

        if (bDrawSun == true) {
            cXyz camfwd;
            snap_sunmoon_proc(&sunPos, 9);

            f32 sun_distXZ = sqrtf(sunPos.x*sunPos.x + sunPos.z*sunPos.z);
            f32 sun_theta = atan2f(sunPos.x, sunPos.z);
            f32 sun_phi = atan2f(sunPos.y, sun_distXZ);

            dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &camfwd);

            f32 cam_distXZ = sqrtf(camfwd.x*camfwd.x + camfwd.z*camfwd.z);
            f32 cam_theta = atan2f(camfwd.x, camfwd.z);
            f32 cam_phi = atan2f(camfwd.y, cam_distXZ);

            MTXRotDeg(rotMtx, 'Z', -50.0f + (360.0f * ((sun_theta - cam_theta) / -8.0f)));
            MTXConcat(camMtx, rotMtx, camMtx);
            GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
            GXSetCurrentMtx(GX_PNMTX0);

            reg0.r = 0xFF;
            reg0.g = 0xFF;
            reg0.b = 0xF1;

            reg1.r = 0xF1;
            reg1.g = 0x91;
            reg1.b = 0x49;

            f32 dist = 1.0f - pSunlenzPkt->mDistFalloff;
            f32 size = 575.0f;
            if (pSunPkt->mVisibility > 0.0f)
                size += 500.0f * (dist * dist) * pSunPkt->mVisibility;

            for (s32 j = 0; j < 2; j++) {
                if (j == 0) {
                    dKyr_set_btitex(&texObj, (ResTIMG*)pImg[4]);
                    reg0.a = pSunPkt->mSunAlpha * 255.0f;
                } else {
                    GXInitTexObj(&texObj, pSunlenzPkt->mpTexSnow01, 64, 64, GX_TF_I8, GX_CLAMP, GX_CLAMP, GX_FALSE);
                    GXInitTexObjLOD(&texObj, GX_LINEAR, GX_LINEAR, 0.0f, 0.0f, 0.0f, GX_FALSE, GX_FALSE, GX_ANISO_1);
                    GXLoadTexObj(&texObj, GX_TEXMAP0);
                    size *= 1.6f;
                    reg0.a = pSunPkt->mSunAlpha * 76.0f;
                }

                GXSetTevColor(GX_TEVREG0, reg0);
                GXSetTevColor(GX_TEVREG1, reg1);

                vp.x = -size * flipX;
                vp.y = size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[0].x = sunPos.x + lp.x;
                pos[0].y = sunPos.y + lp.y;
                pos[0].z = sunPos.z + lp.z;

                vp.x = size * flipX;
                vp.y = size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[1].x = sunPos.x + lp.x;
                pos[1].y = sunPos.y + lp.y;
                pos[1].z = sunPos.z + lp.z;

                vp.x = size * flipX;
                vp.y = -size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[2].x = sunPos.x + lp.x;
                pos[2].y = sunPos.y + lp.y;
                pos[2].z = sunPos.z + lp.z;

                vp.x = -size * flipX;
                vp.y = -size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[3].x = sunPos.x + lp.x;
                pos[3].y = sunPos.y + lp.y;
                pos[3].z = sunPos.z + lp.z;

                GXBegin(GX_QUADS, GX_VTXFMT0, 4);
                GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
                GXTexCoord2s16(0, 0);
                GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
                GXTexCoord2s16(0xFF, 0);
                GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
                GXTexCoord2s16(0xFF, 0xFF);
                GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
                GXTexCoord2s16(0, 0xFF);
                GXEnd();
            }
        }
#if VERSION != VERSION_JPN
        J3DShape::resetVcdVatCache();
#endif
    }
}

/* 8009514C-80095E8C       .text dKyr_drawLenzflare__FPA4_fP4cXyzR8GXColorPPUc */
void dKyr_drawLenzflare(Mtx drawMtx, cXyz* pPos, GXColor& color, u8** pImg) {
    /* Nonmatching */
}

/* 80095E8C-8009682C       .text dKyr_drawRain__FPA4_fPPUc */
void dKyr_drawRain(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
    dKankyo_rain_Packet* pPkt = g_env_light.mpRainPacket;
    camera_class* pCamera = dComIfGp_getCamera(0);

    Mtx camMtx;
    cXyz pos[4];
    cXyz windvec;
    cXyz vp;
    cXyz lp;
    cXyz p;
    cXyz dummy;
    cXyz tilt;
    Mtx rotMtx;
    GXColor reg0, reg1;

    windvec = dKyw_get_wind_vecpow();

    static u32 rot = 0;

    if (g_env_light.mSnowCount == 0) {
        dummy.set(0.0f, -2.0f, 0.0f);

        if (pPkt->mRainCount != 0) {
            reg0.r = 0xFF;
            reg0.g = 0xFF;
            reg0.b = 0xFF;

            reg1.r = 0x80;
            reg1.g = 0x80;
            reg1.b = 0x80;

            reg0.a = 0x0A;
            reg1.a = 0x0A;

            if (dComIfGd_getView() != NULL) {
                MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
            } else {
                return;
            }

            GXTexObj texObj;
            GXInitTexObj(&texObj, pImg[0], 64, 64, GX_TF_I8, GX_CLAMP, GX_CLAMP, GX_FALSE);
            GXInitTexObjLOD(&texObj, GX_LINEAR, GX_LINEAR, 0.0f, 0.0f, 0.0f, GX_FALSE, GX_FALSE, GX_ANISO_1);
            GXLoadTexObj(&texObj, GX_TEXMAP0);
            GXSetNumChans(0);
            GXSetTevColor(GX_TEVREG0, reg0);
            GXSetTevColor(GX_TEVREG1, reg1);
            GXSetNumTexGens(1);
            GXSetTexCoordGen2(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY, GX_FALSE, GX_PTIDENTITY);
            GXSetNumTevStages(1);
            GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
            GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
            GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
            GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
            GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
            GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
            GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
            GXSetZMode(true, GX_LEQUAL, false);
            GXSetCullMode(GX_CULL_NONE);
    #if VERSION != VERSION_JPN
            GXSetClipMode(GX_CLIP_DISABLE);
    #endif
            GXSetNumIndStages(0);
            GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
            GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
            GXClearVtxDesc();
            GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
            GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
            MTXRotDeg(rotMtx, 'Z', rot);
            MTXConcat(camMtx, rotMtx, drawMtx);
            GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
            GXSetCurrentMtx(GX_PNMTX0);

            for (s32 i = 0; i < pPkt->mRainCount; i++) {
                f32 alpha = pPkt->mEff[i].mAlpha;
                if (alpha <= 0.0f)
                    continue;

                reg0.a = alpha * 14.0f;
                GXSetTevColor(GX_TEVREG0, reg0);

                p.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
                p.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
                p.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;

                f32 dist = p.abs(pCamera->mLookat.mEye);
                dist = dist / 1500.0f + 0.1f;
                if (dist > 1.0f)
                    dist = 1.0f;

                f32 size = 2.5f + (i / 250.0f);
                f32 speed = dist * 70.0f + 5.0f;
                tilt.x = speed * (dummy.x + pPkt->mCenterDelta.x * pPkt->mCenterDeltaMul * 10.0f + (i & 0x07) * 0.08f + windvec.x);
                tilt.y = speed * (dummy.y + pPkt->mCenterDelta.y * pPkt->mCenterDeltaMul + windvec.y);
                tilt.z = speed * (dummy.z + pPkt->mCenterDelta.z * pPkt->mCenterDeltaMul * 10.0f + (i & 0x03) * 0.08f + windvec.z);

                vp.x = -1.0f * -size;
                vp.y = 0.0f;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[0].x = (p.x + lp.x) - tilt.x;
                pos[0].y = (p.y + lp.y) - tilt.y;
                pos[0].z = (p.z + lp.z) - tilt.z;

                vp.x = -1.0f * size;
                vp.y = 0.0f;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[1].x = (p.x + lp.x) - tilt.x;
                pos[1].y = (p.y + lp.y) - tilt.y;
                pos[1].z = (p.z + lp.z) - tilt.z;

                vp.x = -1.0f * -size;
                vp.y = 0.0f;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[2].x = p.x + lp.x;
                pos[2].y = p.y + lp.y;
                pos[2].z = p.z + lp.z;

                vp.x = -1.0f * size;
                vp.y = 0.0f;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[3].x = p.x + lp.x;
                pos[3].y = p.y + lp.y;
                pos[3].z = p.z + lp.z;

                for (s32 j = 0; j < 4; j++) {
                    static const cXyz add_table[4] = {
                        cXyz(150.0f, 0.0f, 0.0f),
                        cXyz(0.0f, 150.0f, 150.0f),
                        cXyz(150.0f, 320.0f, 150.0f),
                        cXyz(45.0f, 480.0f, 45.0f),
                    };

                    GXBegin(GX_QUADS, GX_VTXFMT0, 4);
                    const cXyz & addv = add_table[j];
                    f32 addX = addv.x, addY = addv.y, addZ = addv.z;
                    GXPosition3f32(pos[0].x + addX, pos[0].y + addY, pos[0].z + addZ);
                    GXTexCoord2s16(0, 0);
                    GXPosition3f32(pos[1].x + addX, pos[1].y + addY, pos[1].z + addZ);
                    GXTexCoord2s16(0xFF, 0);
                    GXPosition3f32(pos[2].x + addX, pos[2].y + addY, pos[2].z + addZ);
                    GXTexCoord2s16(0xFF, 0xFF);
                    GXPosition3f32(pos[3].x + addX, pos[3].y + addY, pos[3].z + addZ);
                    GXTexCoord2s16(0, 0xFF);
                    GXEnd();
                }
            }

#if VERSION != VERSION_JPN
            GXSetClipMode(GX_CLIP_ENABLE);
            J3DShape::resetVcdVatCache();
#endif
        }
    }
}

/* 8009682C-80096D18       .text dKyr_drawSibuki__FPA4_fPPUc */
void dKyr_drawSibuki(Mtx drawMtx, u8** pImg) {
    camera_class *pCamera = dComIfGp_getCamera(0);
    dKankyo_rain_Packet * pPkt = g_env_light.mpRainPacket;

    if (g_env_light.mSnowCount == 0 && dComIfGd_getView() != NULL) {
        Mtx camMtx;
        MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
    } else {
        return;
    }

    f32 alpha = 200.0f;
    if (pPkt->mStatus & 1)
        alpha = 0.0f;
    else if (pPkt->mStatus & 2)
        alpha = 200.0f;

    cLib_addCalc(&pPkt->mSibukiAlpha, alpha, 0.2f, 30.0f, 0.001f);

    cXyz eyevect, camDir;
    dKy_set_eyevect_calc(pCamera, &eyevect, 7000.0f, 4000.0f);
    dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &camDir);

    f32 alphaFade;
    if (camDir.y > 0.0f) {
        if (camDir.y < 0.5f) {
            alphaFade = 1.0f - (camDir.y / 0.5f);
        } else {
            alphaFade = 0.0f;
        }
    } else {
        alphaFade = 1.0f;
    }

    GXColor color;
    color.r = 0xB4;
    color.g = 0xC8;
    color.b = 0xC8;
    color.a = (u8)(pPkt->mSibukiAlpha * alphaFade);

    GXTexObj texObj;
    dKyr_init_btitex(&texObj, (ResTIMG*)pImg[1]);
    GXLoadTexObj(&texObj, GX_TEXMAP0);

    GXSetNumChans(0);
    GXSetTevColor(GX_TEVREG0, color);
    GXSetTevColor(GX_TEVREG1, color);
    GXSetNumTexGens(1);
    GXSetTexCoordGen2(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY, false, GX_PTIDENTITY);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
    GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
    GXSetZMode(true, GX_GEQUAL, false);
    GXSetCullMode(GX_CULL_NONE);
#if VERSION != VERSION_JPN
    GXSetClipMode(GX_CLIP_DISABLE);
#endif
    GXSetNumIndStages(0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
    GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
    GXSetCurrentMtx(GX_PNMTX0);

    f32 scale;
    if (dComIfGd_getView() != NULL) {
        scale = dComIfGd_getView()->mFovy / 20.0f;
        if (scale >= 1.0f)
            scale = 1.0f;
        scale = 1.0f - scale;
    } else {
        scale = 0.2f;
    }

    for (s32 i = 0; i < g_env_light.mRainCount >> 1; i++) {
        cXyz pos[4], p;

        f32 size = 20.0f + (scale * cM_rndF(25.0f));

        f32 localX = cM_rndFX(3600.0f);
        f32 localY = cM_rndFX(1500.0f);
        f32 localZ = cM_rndFX(3600.0f);

        p.x = eyevect.x + localX;
        p.y = eyevect.y + localY;
        p.z = eyevect.z + localZ;

        pos[0].x = p.x - size;
        pos[0].y = p.y;
        pos[0].z = p.z - size;

        pos[1].x = p.x + size;
        pos[1].y = p.y;
        pos[1].z = p.z - size;

        pos[2].x = p.x + size;
        pos[2].y = p.y;
        pos[2].z = p.z + size;

        pos[3].x = p.x - size;
        pos[3].y = p.y;
        pos[3].z = p.z + size;

        GXBegin(GX_QUADS, GX_VTXFMT0, 4);
        GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
        GXTexCoord2s16(0, 0);
        GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
        GXTexCoord2s16(0x1FF, 0);
        GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
        GXTexCoord2s16(0x1FF, 0x1FF);
        GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
        GXTexCoord2s16(0, 0x1FF);
        GXEnd();
    }

#if VERSION != VERSION_JPN
    GXSetClipMode(GX_CLIP_ENABLE);
    J3DShape::resetVcdVatCache();
#endif
}

/* 80096D18-800973CC       .text drawPoison__FPA4_fPPUc */
void drawPoison(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
    dKankyo_poison_Packet* pPkt;
    GXTexObj texObj;
    Mtx camMtx;
    Mtx rotMtx;
    cXyz pos[4];
    cXyz windvec;
    cXyz vp;
    cXyz lp;
    cXyz p;
    cXyz dummy;
    cXyz tilt;
    GXColor reg0, reg1;

    pPkt = dKy_getEnvlight().mpPoisonPacket;
    static f32 rot = 0.0f;

    j3dSys.reinitGX();
    if (dComIfGd_getView() != NULL) {
        MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
    } else {
        return;
    }

    reg0.r = 0x2D;
    reg0.g = 0x88;
    reg0.b = 0xAA;

    reg1.r = 0x6D;
    reg1.g = 0x3C;
    reg1.b = 0xCD;

    dKyr_set_btitex(&texObj, (ResTIMG*)pImg[0]);

    GXSetNumChans(0);
    GXSetTevColor(GX_TEVREG0, reg0);
    GXSetTevColor(GX_TEVREG1, reg1);
    GXSetNumTexGens(1);
    GXSetTexCoordGen2(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY, false, GX_PTIDENTITY);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    dKy_GxFog_set();
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
    GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
    GXSetZMode(GX_TRUE, GX_LEQUAL, GX_FALSE);
    GXSetCullMode(GX_CULL_NONE);
    GXSetNumIndStages(0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
    MTXRotDeg(rotMtx, 'Z', rot);
    MTXConcat(camMtx, rotMtx, camMtx);
    GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
    rot += 1.3f;
    if (rot < 0.0f)
        rot = 719.0f;
    GXSetCurrentMtx(GX_PNMTX0);

    s32 wave = 0;
    for (s32 i = 0; i < dKy_getEnvlight().mPoisonCount; i++, wave += 4000) {
        f32 size = pPkt->mEff[i].mSize;
        if (pPkt->mEff[i].mAlpha <= 0.0f)
            continue;

        GXLoadTexObj(&texObj, GX_TEXMAP0);

        f32 cosR = fabsf(cM_scos(dKy_getEnvlight().mpPoisonPacket->mCount * 500.0f + wave));
        cosR *= cosR;

        reg0.r = 95.0f + -50.0f * cosR;
        reg0.g = 186.0f + -50.0f * cosR;
        reg0.b = 226.0f + -56.0f * cosR;

        reg1.r = 115.0f + -6.0f * cosR;
        reg1.g = 206.0f + -146.0f * cosR;
        reg1.b = 255.0f + -50.0f * cosR;
        reg1.a = pPkt->mEff[i].mAlpha * 255.0f;

        GXSetTevColor(GX_TEVREG0, reg0);
        GXSetTevColor(GX_TEVREG1, reg1);

        p.x = pPkt->mBasePos.x + pPkt->mEff[i].mPos.x;
        p.y = pPkt->mBasePos.y + pPkt->mEff[i].mPos.y;
        p.z = pPkt->mBasePos.z + pPkt->mEff[i].mPos.z;

        vp.x = -size;
        vp.y = size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[0].x = p.x + lp.x;
        pos[0].y = p.y + lp.y;
        pos[0].z = p.z + lp.z;

        vp.x = size;
        vp.y = size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[1].x = p.x + lp.x;
        pos[1].y = p.y + lp.y;
        pos[1].z = p.z + lp.z;

        vp.x = size;
        vp.y = -size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[2].x = p.x + lp.x;
        pos[2].y = p.y + lp.y;
        pos[2].z = p.z + lp.z;

        vp.x = -size;
        vp.y = -size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[3].x = p.x + lp.x;
        pos[3].y = p.y + lp.y;
        pos[3].z = p.z + lp.z;

        GXBegin(GX_QUADS, GX_VTXFMT0, 4);
        GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
        GXTexCoord2s16(0, 0);
        GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
        GXTexCoord2s16(0xFF, 0);
        GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
        GXTexCoord2s16(0xFF, 0xFF);
        GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
        GXTexCoord2s16(0, 0xFF);
        GXEnd();
    }

#if VERSION != VERSION_JPN
    GXSetClipMode(GX_CLIP_ENABLE);
    J3DShape::resetVcdVatCache();
#endif
}

/* 800973CC-80097AD0       .text dKyr_drawHousi__FPA4_fPPUc */
void dKyr_drawHousi(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
}

/* 80097AD0-800987B8       .text dKyr_drawKazanbai__FPA4_fPPUc */
void dKyr_drawKazanbai(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
}

/* 800987B8-80098FF0       .text dKyr_drawSnow__FPA4_fPPUc */
void dKyr_drawSnow(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
}

/* 80098FF0-80099D38       .text dKyr_drawStar__FPA4_fPPUc */
void dKyr_drawStar(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
}

/* 80099D38-8009A5D4       .text drawWave__FPA4_fPPUc */
void drawWave(Mtx drawMtx, u8** pImg) {
    dKankyo_wave_Packet* pPkt;
    camera_class* pCamera;
    GXTexObj texObj;
    Mtx camMtx;
    Mtx rotMtx;
    cXyz pos[4];
    cXyz windvec;
    cXyz vp;
    cXyz lp;
    cXyz p;
    cXyz dummy;
    cXyz tilt;
    GXColor dif, amb;

    pPkt = dKy_getEnvlight().mpWavePacket;
    pCamera = dComIfGp_getCamera(0);

    if (!(dKy_getEnvlight().mWaveChan.mWaveFlatInter >= 1.0f) && dComIfGd_getView() != NULL) {
        MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
    } else {
        return;
    }

    f32 rot = cM_sht2d(pCamera->mBank);
    j3dSys.reinitGX();

    GXSetClipMode(GX_CLIP_ENABLE);

    s32 texidx = strcmp(dComIfGp_getStartStageName(), "MajyuE") == 0 ? 1 : 0;
    dKyr_set_btitex(&texObj, (ResTIMG*)pImg[texidx]);

    GXSetNumChans(0);
    GXSetNumTexGens(1);
    GXSetTexCoordGen2(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY, false, GX_PTIDENTITY);
    dKy_get_seacolor(&amb, &dif);
    GXSetTevColor(GX_TEVREG0, dif);
    GXSetTevKColorSel(GX_TEVSTAGE0, GX_TEV_KCSEL_K0);
    GXSetTevKAlphaSel(GX_TEVSTAGE0, GX_TEV_KASEL_K3_A);
    GXSetTevKColor(GX_KCOLOR0, amb);
    GXSetTevKColor(GX_KCOLOR3, amb);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C0, GX_CC_KONST, GX_CC_TEXC, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_KONST, GX_CA_TEXA, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    dKy_GxFog_sea_set();
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
    GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
    GXSetZCompLoc(GX_FALSE);
    GXSetZMode(GX_TRUE, GX_LEQUAL, GX_TRUE);
    GXSetCullMode(GX_CULL_NONE);
    GXSetNumIndStages(0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
    MTXRotDeg(rotMtx, 'Z', rot);
    MTXConcat(camMtx, rotMtx, camMtx);
    GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
    GXSetCurrentMtx(GX_PNMTX0);

    s32 counter = 0;
    for (s32 i = 0; i < dKy_getEnvlight().mWaveChan.mWaveCount; i++, counter += 31) {
        p.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
        p.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
        p.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;

        f32 wave = sin(pPkt->mEff[i].mCounter);
        if (wave <= 0.0f)
            continue;

        f32 scale = dKy_getEnvlight().mWaveChan.mWaveScale * pPkt->mEff[i].mScale;
        f32 strength = pPkt->mEff[i].mStrengthEnv;
        f32 height = wave * scale * strength;
        f32 width = dKy_getEnvlight().mWaveChan.mWaveScaleBottom * scale * (strength - height * counter * 0.000015f);
        if (height <= 0.01f)
            continue;

        GXLoadTexObj(&texObj, GX_TEXMAP0);
        amb.a = pPkt->mEff[i].mAlpha;
        GXSetTevKColor(GX_KCOLOR3, amb);

        if (pPkt->mSkewDir >= 0.0f) {
            vp.x = -width - pPkt->mSkewDir * width * (-pPkt->mEff[i].mSpeed * 1.2f);
        } else {
            vp.x = -width + pPkt->mSkewDir * width * (-pPkt->mEff[i].mSpeed * 1.2f);
        }
        vp.y = height;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[0].x = p.x + lp.x;
        pos[0].y = p.y + lp.y;
        pos[0].z = p.z + lp.z;

        if (pPkt->mSkewDir >= 0.0f) {
            vp.x = width - pPkt->mSkewDir * width * (-pPkt->mEff[i].mSpeed * 1.2f);
        } else {
            vp.x = width + pPkt->mSkewDir * width * (-pPkt->mEff[i].mSpeed * 1.2f);
        }
        vp.y = height;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[1].x = p.x + lp.x;
        pos[1].y = p.y + lp.y;
        pos[1].z = p.z + lp.z;

        vp.x = width;
        vp.y = 0.0f;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[2].x = p.x + lp.x;
        pos[2].y = p.y + lp.y;
        pos[2].z = p.z + lp.z;

        vp.x = width;
        vp.y = 0.0f;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[3].x = p.x + lp.x;
        pos[3].y = p.y + lp.y;
        pos[3].z = p.z + lp.z;

        static const cXyz add_table[4] = {
            cXyz(0.0f, 0.0f, 0.0f),
            cXyz(800.0f, 0.0f, 400.0f),
            cXyz(600.0f, 0.0f, 200.0f),
            cXyz(200.0f, 0.0f, 800.0f),
        };

        for (s32 j = 0; j < 1; j++) {
            GXBegin(GX_QUADS, GX_VTXFMT0, 4);
            const cXyz & addv = add_table[j];
            f32 addX = addv.x, addY = addv.y, addZ = addv.z;
            GXPosition3f32(pos[0].x + addX, pos[0].y + addY, pos[0].z + addZ);
            GXTexCoord2s16(0, 0);
            GXPosition3f32(pos[1].x + addX, pos[1].y + addY, pos[1].z + addZ);
            GXTexCoord2s16(0xFA, 0);
            GXPosition3f32(pos[2].x + addX, pos[2].y + addY, pos[2].z + addZ);
            GXTexCoord2s16(0xFA, 0xFA);
            GXPosition3f32(pos[3].x + addX, pos[3].y + addY, pos[3].z + addZ);
            GXTexCoord2s16(0, 0xFA);
            GXEnd();
        }
    }

#if VERSION != VERSION_JPN
    J3DShape::resetVcdVatCache();
#endif
}

/* 8009A5D4-8009AB88       .text drawCloudShadow__FPA4_fPPUc */
void drawCloudShadow(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
}

/* 8009AB88-8009B9C4       .text drawVrkumo__FPA4_fR8GXColorPPUc */
void drawVrkumo(Mtx drawMtx, GXColor& clr, u8** pImg) {
    /* Nonmatching */
}

/* 8009B9C4-8009B9D8       .text dKyr_thunder_init__Fv */
void dKyr_thunder_init() {
    g_env_light.mThunderEff.mState = 0;
}

/* 8009B9D8-8009BDEC       .text dKyr_thunder_move__Fv */
void dKyr_thunder_move() {
    EF_THUNDER * pThunder = &g_env_light.mThunderEff;
    camera_class * pCamera = dComIfGp_getCamera(0);

    switch (pThunder->mState) {
    case 0:
        {
            pThunder->mFlashTimer = 0.0f;
            pThunder->field_0xc = 0.0f;
            pThunder->field_0x10 = 0.0f;

            if (cM_rndF(1.0f) < 0.007f) {
                pThunder->mState = 11;
            } else if (cM_rndF(1.0f) < 0.005f && g_env_light.mThunderEff.mMode < 10) {
                pThunder->mLightInfluence.mPos.x = pCamera->mLookat.mEye.x;
                pThunder->mLightInfluence.mPos.y = pCamera->mLookat.mEye.y;
                pThunder->mLightInfluence.mPos.z = pCamera->mLookat.mEye.z;
                pThunder->mLightInfluence.mColor.r = 0;
                pThunder->mLightInfluence.mColor.g = 0;
                pThunder->mLightInfluence.mColor.b = 0;
                pThunder->mLightInfluence.mPower = 90000.0f;
                pThunder->mLightInfluence.mFluctuation = 150.0f;
                dKy_efplight_set(&pThunder->mLightInfluence);
                pThunder->mState++;
            }
        }
        break;
    case 1:
    case 11:
        {
            cLib_addCalc(&pThunder->mFlashTimer, 1.0f, 0.3f, 0.2f, 0.001f);
            if (pThunder->mFlashTimer >= 1.0f) {
                if (pThunder->mState < 10)
                    mDoAud_seStart(JA_SE_OBJ_THUNDER_NEAR);
                pThunder->mState++;
            }

            if (cM_rndF(1.0f) < 0.18f)
                fopKyM_create(PROC_KY_THUNDER, -1);
        }
        break;
    case 2:
    case 12:
        {
            cLib_addCalc(&pThunder->mFlashTimer, 0.0f, 0.1f, 0.05f, 0.001f);
            if (pThunder->mFlashTimer <= 0.0f) {
                if (pThunder->mState < 10)
                    dKy_efplight_cut(&pThunder->mLightInfluence);

                pThunder->mState = 0;
                if (g_env_light.mThunderEff.mMode == 0)
                    pThunder->mStatus = 0;
            }
        }
        break;
    }

    if (pThunder->mState != 0) {
        if (pThunder->mState < 10) {
            pThunder->mLightInfluence.mPos.x = pCamera->mLookat.mEye.x;
            pThunder->mLightInfluence.mPos.y = pCamera->mLookat.mEye.y + 150.0f;
            pThunder->mLightInfluence.mPos.z = pCamera->mLookat.mEye.z;
            pThunder->mLightInfluence.mColor.r = (u8)(pThunder->mFlashTimer * 0.2f * 180.0f);
            pThunder->mLightInfluence.mColor.g = (u8)(pThunder->mFlashTimer * 0.2f * 235.0f);
            pThunder->mLightInfluence.mColor.b = (u8)(pThunder->mFlashTimer * 0.2f * 255.0f);
            if (g_env_light.field_0xc98 == 0) {
                dKy_actor_addcol_amb_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.5f);
                dKy_actor_addcol_dif_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.5f);
                dKy_bg_addcol_amb_set(0x32, 0x78, 0xff, pThunder->mFlashTimer * 0.7f);
                dKy_bg_addcol_dif_set(0x32, 0x78, 0xff, pThunder->mFlashTimer * 0.7f);
                dKy_bg1_addcol_amb_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.35f);
                dKy_bg1_addcol_dif_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.35f);
                dKy_vrbox_addcol_sky0_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.4f);
                dKy_vrbox_addcol_kasumi_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.5f);
                dKy_addcol_fog_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.3f);
            }
        } else {
            dKy_vrbox_addcol_sky0_set(0x5a,0xa0,0xf5,(pThunder->mFlashTimer * 0.15f));
            dKy_vrbox_addcol_kasumi_set(0x5a,0xa0,0xf5,(pThunder->mFlashTimer * 0.35f));
            dKy_addcol_fog_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.12f);
        }
    }
}
