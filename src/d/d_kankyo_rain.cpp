//
// Generated by dtk
// Translation Unit: d_kankyo_rain.cpp
//

#include "d/dolzel.h" // IWYU pragma: keep
#include "d/d_kankyo_rain.h"
#include "d/d_bg_s_gnd_chk.h"
#include "d/d_bg_s_roof_chk.h"
#include "d/d_cc_d.h"
#include "d/d_com_inf_game.h"
#include "d/d_kankyo.h"
#include "d/d_kankyo_wether.h"
#include "d/d_procname.h"
#include "d/d_snap.h"
#include "f_op/f_op_camera.h"
#include "f_op/f_op_kankyo_mng.h"
#include "m_Do/m_Do_audio.h"
#include "m_Do/m_Do_lib.h"
#include "SSystem/SComponent/c_counter.h"

static u32 now_room = -1;

/* 8008AA30-8008AB3C       .text vectle_calc__FP10DOUBLE_POSP4cXyz */
void vectle_calc(DOUBLE_POS* i_pos, cXyz* o_out) {
    double s = sqrt(i_pos->x * i_pos->x + i_pos->y * i_pos->y + i_pos->z * i_pos->z);

    if (s != 0.0) {
        o_out->x = i_pos->x / s;
        o_out->y = i_pos->y / s;
        o_out->z = i_pos->z / s;
    } else {
        o_out->x = 0.0f;
        o_out->y = 0.0f;
        o_out->z = 0.0f;
    }
}

/* 8008AB3C-8008AB94       .text get_vectle_calc__FP4cXyzP4cXyzP4cXyz */
void get_vectle_calc(cXyz* param_0, cXyz* param_1, cXyz* param_2) {
    DOUBLE_POS pos;
    pos.x = param_1->x - param_0->x;
    pos.y = param_1->y - param_0->y;
    pos.z = param_1->z - param_0->z;

    vectle_calc(&pos, param_2);
}

/* 8008AB94-8008ABB4       .text dKyr_get_vectle_calc__FP4cXyzP4cXyzP4cXyz */
void dKyr_get_vectle_calc(cXyz* param_0, cXyz* param_1, cXyz* param_2) {
    get_vectle_calc(param_0, param_1, param_2);
}

/* 8008ABB4-8008AC64       .text dKy_set_eyevect_calc__FP12camera_classP3Vecff */
void dKy_set_eyevect_calc(camera_class* i_camera, Vec* param_1, f32 param_2, f32 param_3) {
    cXyz tmp;
    get_vectle_calc(&i_camera->mLookat.mEye, &i_camera->mLookat.mCenter, &tmp);
    param_1->x = i_camera->mLookat.mEye.x + tmp.x * param_2;
    param_1->y = (i_camera->mLookat.mEye.y + tmp.y * param_3) - 200.0f;
    param_1->z = i_camera->mLookat.mEye.z + tmp.z * param_2;
}

/* 8008AC64-8008AD60       .text dKy_set_eyevect_calc2__FP12camera_classP3Vecff */
void dKy_set_eyevect_calc2(camera_class* i_camera, Vec* param_1, f32 param_2, f32 param_3) {
    cXyz tmp;
    DOUBLE_POS pos;

    pos.x = i_camera->mLookat.mCenter.x - i_camera->mLookat.mEye.x;
    if (param_3 != 0.0f) {
        pos.y = i_camera->mLookat.mCenter.y - i_camera->mLookat.mEye.y;
    } else {
        pos.y = 0.0f;
    }
    pos.z = i_camera->mLookat.mCenter.z - i_camera->mLookat.mEye.z;

    vectle_calc(&pos, &tmp);

    param_1->x = i_camera->mLookat.mEye.x + tmp.x * param_2;
    param_1->y = i_camera->mLookat.mEye.y + tmp.y * param_3;
    param_1->z = i_camera->mLookat.mEye.z + tmp.z * param_2;

    if (param_3 == 0.0f) {
        param_1->y = 0.0f;
    }
}

static inline void dKyr_init_btitex(GXTexObj* i_obj, ResTIMG* i_img) {
    GXInitTexObj(i_obj, (&i_img->format + i_img->imageOffset), i_img->width, i_img->height,
                 (GXTexFmt)i_img->format, (GXTexWrapMode)i_img->wrapS, (GXTexWrapMode)i_img->wrapT,
                 (GXBool)(i_img->mipmapCount > 1));
}

/* 8008AD60-8008AE54       .text dKyr_set_btitex__FP9_GXTexObjP7ResTIMG */
void dKyr_set_btitex(GXTexObj* i_obj, ResTIMG* i_img) {
    GXInitTexObj(i_obj, (&i_img->format + i_img->imageOffset), i_img->width, i_img->height,
                 (GXTexFmt)i_img->format, (GXTexWrapMode)i_img->wrapS, (GXTexWrapMode)i_img->wrapT,
                 (GXBool)(i_img->mipmapCount > 1));

    GXInitTexObjLOD(i_obj, (GXTexFilter)i_img->minFilter, (GXTexFilter)i_img->magFilter,
                    i_img->minLOD * 0.125f, i_img->maxLOD * 0.125f, i_img->LODBias * 0.01f,
                    (GXBool)i_img->biasClamp, (GXBool)i_img->doEdgeLOD,
                    (GXAnisotropy)i_img->maxAnisotropy);

    GXLoadTexObj(i_obj, GX_TEXMAP0);
}

/* 8008AE54-8008B44C       .text dKyr_kamome_move__Fv */
void dKyr_kamome_move() {
    WINDEFF_SET* pWind = dKy_getEnvlight().mpWind;
    camera_class* pCamera = (camera_class*)dComIfGp_getCamera(0);

    dKyw_get_wind_vec();

    cXyz newPos;
    cXyz targetRot;
    cXyz newTarget;
    cXyz oldTarget;

    BOOL spawnBirds = FALSE;
    if (strcmp(dComIfGp_getStartStageName(), "sea") == 0) {
        if ((g_env_light.mColpatCurr == 1 && g_env_light.mColPatBlend > 0.0f) ||
            (g_env_light.mColpatPrev == 1 && g_env_light.mColPatBlend < 1.0f) ||
            (g_env_light.mColpatCurr == 2 && g_env_light.mColPatBlend > 0.0f) ||
            (g_env_light.mColpatPrev == 2 && g_env_light.mColPatBlend < 1.0f))
        {
            spawnBirds = FALSE;
        } else {
            spawnBirds = TRUE;
        }
    }

    for (s32 i = 0; i < 2; i++) {
        switch (pWind->mKamomeEff[i].mStatus) {
        case 0:
            if (spawnBirds) {
                if (pWind->mKamomeEff[i].mTimer == 0) {
                    pWind->mKamomeEff[i].mAngleY = cM_rndFX(65535.0f);
                    pWind->mKamomeEff[i].mAngleX = cM_rndFX(65535.0f);
                    newPos.x = pCamera->mLookat.mEye.x + cM_ssin(pWind->mKamomeEff[i].mAngleY) * 7000.0f;
                    newPos.y = 4500.0f;
                    newPos.z = pCamera->mLookat.mEye.z + cM_scos(pWind->mKamomeEff[i].mAngleY) * 7000.0f;
                    pWind->mKamomeEff[i].mPos.set(newPos);
                    pWind->mKamomeEff[i].mAngleYSpeed = cM_rndFX(1.0f);
                    pWind->mKamomeEff[i].mScale = 0.0f;
                    pWind->mKamomeEff[i].mTimer = 300.0f + cM_rndF(180.0f);
                    pWind->mKamomeEff[i].mpEmitter = dComIfGp_particle_set(dPa_name::ID_COMMON_0429, &pWind->mKamomeEff[i].mPos);
                    pWind->mKamomeEff[i].mStatus++;
                } else {
                    pWind->mKamomeEff[i].mTimer--;
                }
            }
            break;
        case 1:
            if (pWind->mKamomeEff[i].mpEmitter != NULL) {
                if (pWind->mKamomeEff[i].mAngleYSpeed >= 0.0f) {
                    pWind->mKamomeEff[i].mAngleYSpeed += cM_rndFX(1.0f);
                    if (pWind->mKamomeEff[i].mAngleYSpeed > 100.0f)
                        pWind->mKamomeEff[i].mAngleYSpeed = 100.0f;
                    if (pWind->mKamomeEff[i].mAngleYSpeed < 80.0f)
                        pWind->mKamomeEff[i].mAngleYSpeed = 80.0f;
                } else {
                    pWind->mKamomeEff[i].mAngleYSpeed += cM_rndFX(1.0f);
                    if (pWind->mKamomeEff[i].mAngleYSpeed < -100.0f)
                        pWind->mKamomeEff[i].mAngleYSpeed = -100.0f;
                    if (pWind->mKamomeEff[i].mAngleYSpeed > -80.0f)
                        pWind->mKamomeEff[i].mAngleYSpeed = -80.0f;
                }

                oldTarget.x = cM_ssin(pWind->mKamomeEff[i].mAngleY) * 7000.0f;
                oldTarget.y = std::fabsf(cM_ssin(pWind->mKamomeEff[i].mAngleX) * 3200.0f);
                oldTarget.z = cM_scos(pWind->mKamomeEff[i].mAngleY) * 7000.0f;

                pWind->mKamomeEff[i].mAngleY += pWind->mKamomeEff[i].mAngleYSpeed * pWind->mKamomeEff[i].mScale;
                pWind->mKamomeEff[i].mAngleX += 15;

                newTarget.x = cM_ssin(pWind->mKamomeEff[i].mAngleY) * 7000.0f;
                newTarget.y = std::fabsf(cM_ssin(pWind->mKamomeEff[i].mAngleX) * 3200.0f);
                newTarget.z = cM_scos(pWind->mKamomeEff[i].mAngleY) * 7000.0f;

                newPos.x = pCamera->mLookat.mEye.x + newTarget.x;
                newPos.y = newTarget.y + 4800.0f;
                newPos.z = pCamera->mLookat.mEye.z + newTarget.z;

                pWind->mKamomeEff[i].mPos.set(newPos);
                pWind->mKamomeEff[i].mpEmitter->setGlobalTranslation(pWind->mKamomeEff[i].mPos);

                if (pWind->mKamomeEff[i].mTimer != 0 && spawnBirds) {
                    cLib_addCalc(&pWind->mKamomeEff[i].mScale, 1.0f, 0.1f, 0.003f, 0.000001f);
                    pWind->mKamomeEff[i].mTimer--;
                } else {
                    cLib_addCalc(&pWind->mKamomeEff[i].mScale, 0.0f, 0.1f, 0.003f, 0.000001f);
                    if (pWind->mKamomeEff[i].mScale < 0.001f)
                        pWind->mKamomeEff[i].mStatus++;
                }

                dKyr_get_vectle_calc(&oldTarget, &newTarget, &targetRot);
                JGeometry::TVec3<s16> globalRot(0, 0, 0);
                globalRot.y = (int)cM_atan2s(targetRot.x, targetRot.z);
                pWind->mKamomeEff[i].mpEmitter->setGlobalRotation(globalRot);
            }
            break;
        case 2:
            pWind->mKamomeEff[i].mpEmitter->deleteAllParticle();
            pWind->mKamomeEff[i].mpEmitter->becomeInvalidEmitter();
            pWind->mKamomeEff[i].mpEmitter = NULL;
            pWind->mKamomeEff[i].mStatus = 0;
            pWind->mKamomeEff[i].mTimer = cM_rndF(600.0f) + 900.0f;
            break;
        }

        if (pWind->mKamomeEff[i].mpEmitter != NULL) {
            if (dComIfGd_getView() != NULL) {
                f32 scale = dComIfGd_getView()->mFovy / 26.0f;
                if (scale >= 1.0f)
                    scale = 1.0f;

                scale = pWind->mKamomeEff[i].mScale * scale * 1.6f;
                pWind->mKamomeEff[i].mpEmitter->setGlobalScale(JGeometry::TVec3<f32>(scale, scale, scale));
            }

            pWind->mKamomeEff[i].mpEmitter->setGlobalPrmColor(dKy_getEnvlight().mBG0_K0.r, dKy_getEnvlight().mBG0_K0.g, dKy_getEnvlight().mBG0_K0.b);
        }
    }
}

/* 8008B44C-8008B504       .text dKyr_wind_init__Fv */
void dKyr_wind_init() {
    g_env_light.mpWind->mbHasCustomWindPower = false;
    g_env_light.mpWind->field_0x759 = 0;

    for (int i = 0; i < 2; i++) {
        g_env_light.mpWind->mKamomeEff[i].mStatus = 0;
        g_env_light.mpWind->mKamomeEff[i].mScale = 0.0f;
        g_env_light.mpWind->mKamomeEff[i].mTimer = cM_rndF(1800.0f);
        g_env_light.mpWind->mKamomeEff[i].mpEmitter = NULL;
    }
}

/* 8008B504-8008C4BC       .text dKyr_wind_move__Fv */
void dKyr_wind_move() {
    /* Nonmatching */
    dScnKy_env_light_c& envLight = dKy_getEnvlight();
    WINDEFF_SET* pWind = envLight.mpWind;
    camera_class* pCamera = (camera_class*)dComIfGp_getCamera(0);
    cXyz* pWindVec = dKyw_get_wind_vec();
    f32 windPow = dKyw_get_wind_pow();
    fopAc_ac_c* pPlayer = dComIfGp_getPlayer(0);

    dBgS_ObjGndChk_All gndChk;

    cXyz windVec = *pWindVec;
    u32 particleNum = dComIfGp_particle_getParticleNum();
                                                                                                       
    f32 fVar17 = 4000.0f;
    f32 posRange = 2000.0f;
    f32 fVar28 = 80.0f;
    f32 posWindScale = 2500.0f;
    f32 fVar25 = 250.0f;
    f32 fVar18 = 800.0f;
    f32 fVar23 = 1.0f;
    f32 offsetY = 1000.0f;

    s32 windlineCount = envLight.mWindlineCount;
    if (dComIfGp_checkPlayerStatus1(0, daPyStts1_DEKU_LEAF_FLY_e)) {
        windlineCount = 10;
    }

    bool customWindPowerChanged = false;
    if (envLight.mWind.mCustomWindPower > 0.0f) {
        windlineCount = 9;
        fVar17 = 50.0f;
        posWindScale = 160.0f;
        fVar28 = 8.0f;
        fVar18 = 150.0f;
        offsetY = 200.0f;
        fVar23 = 0.14f;
        fVar25 = offsetY;
        posRange = posWindScale;

        if (!pWind->mbHasCustomWindPower) {
            pWind->mbHasCustomWindPower = true;
            customWindPowerChanged = true;
        }
    } else {
        if (pWind->mbHasCustomWindPower) {
            customWindPowerChanged = true;
            pWind->mbHasCustomWindPower = false;
        }
    }

    f32 fVar27 = 0.18f;
    f32 fvar28 = 255.0f;

    if (customWindPowerChanged) {
        for (s32 i = 0; i < (s32)ARRAY_SIZE(pWind->mWindEff); i++) {
            if (pWind->mWindEff[i].mpEmitter != NULL) {
                pWind->mWindEff[i].mpEmitter->deleteAllParticle();
                pWind->mWindEff[i].mpEmitter->becomeInvalidEmitter();
                pWind->mWindEff[i].mpEmitter = NULL;
            }

            pWind->mWindEff[i].mState = 0;
        }
    }

    cXyz pos;
    dKy_set_eyevect_calc2(pCamera, &pos, fVar17, fVar17);

    for (s32 i = 0; i < (s32)ARRAY_SIZE(pWind->mWindEff); i++) {
        if (i >= windlineCount && pWind->mWindEff[i].mState == 0) {
            if (pWind->mWindEff[i].mpEmitter != NULL) {
                pWind->mWindEff[i].mpEmitter->deleteAllParticle();
                pWind->mWindEff[i].mpEmitter->becomeInvalidEmitter();
                pWind->mWindEff[i].mpEmitter = NULL;
            }
            continue;
        }

        WIND_EFF& windEff = pWind->mWindEff[i];
        switch (windEff.mState) {
        case 0:
            if (windPow < 0.3f)
                continue;
            
            if (particleNum <= 1500 && (((g_Counter.mCounter0 >> 4 & 7) != (i & 3U)) || pWind->mbHasCustomWindPower)) {
                windEff.mStateTimer = 0.0f;
                windEff.mAlpha = 0.0f;
                windEff.field_0x2c = 0;

                if (pWind->mbHasCustomWindPower) {
                    windEff.mBasePos.set(pPlayer->current.pos);
                } else {
                    windEff.mBasePos.set(pos);
                }

                windEff.mBasePos.y += offsetY;

                windEff.mPos.x = cM_rndFX(posRange);
                windEff.mPos.y = cM_rndFX(posRange);
                windEff.mPos.z = cM_rndFX(posRange);

                f32 windScale = posWindScale + posWindScale * cM_rndF(1.0f);
                windEff.mPos.x -= windVec.x * windScale;
                windEff.mPos.y -= windVec.y * windScale;
                windEff.mPos.z -= windVec.z * windScale;

                windEff.field_0x2c = cM_rndF(65535.0f);

                cXyz pos;
                pos.x = windEff.mBasePos.x + windEff.mPos.x;
                pos.y = windEff.mBasePos.y + windEff.mPos.y;
                pos.z = windEff.mBasePos.z + windEff.mPos.z;

                if (pWind->mbHasCustomWindPower != TRUE) {
                    cXyz checkPos = pos;
                    checkPos.y += 10000.0f;

                    gndChk.SetPos(&checkPos);

                    f32 gndY = dComIfG_Bgsp()->GroundCross(&gndChk);
                    if (pos.y < gndY) {
                        windEff.mPos.y = (gndY + offsetY + cM_rndF(offsetY)) - windEff.mBasePos.y;
                    }
                }

                pos.x = windEff.mBasePos.x + windEff.mPos.x;
                pos.y = windEff.mBasePos.y + windEff.mPos.y;
                pos.z = windEff.mBasePos.z + windEff.mPos.z;

                windEff.mpEmitter = dComIfGp_particle_set(dPa_name::ID_COMMON_0031, &pos);
                if (windEff.mpEmitter != NULL) {
                    windEff.mpEmitter->setGlobalAlpha(0);
                    windEff.mpEmitter->setGlobalScale(JGeometry::TVec3<f32>(fVar23, fVar23, fVar23));
                    windEff.mState = 1;
                }

                f32 windVec_absXZ = std::sqrtf(windVec.x*windVec.x + windVec.z*windVec.z);
                windEff.mAngleXZ = cM_atan2s(windVec.x, windVec.z);
                windEff.mAngleY = cM_atan2s(windVec.y, windVec_absXZ);

                windEff.field_0x28 = 0;
                windEff.field_0x32 = cM_rndF(1.0f) >= 0.0f ? 1 : 0;
            }
            break;
        case 1:
        case 2:
            {
                f32 fVar14 = fVar25 - fVar17 * (1.0f - windPow);
                windEff.field_0x2c += fVar18; // mSwerveAnimCounter
                if (i & 1) {
                    windEff.mAngleY += fVar14 * cM_ssin(windEff.field_0x2c);
                    windEff.mAngleXZ += fVar14 * cM_ssin(windEff.field_0x2c);
                } else {
                    windEff.mAngleY += fVar14 * cM_ssin(windEff.field_0x2c);
                    windEff.mAngleXZ -= fVar14 * cM_ssin(windEff.field_0x2c);
                }

                if (windEff.mStateTimer > 0.4f && windEff.field_0x32 == 1) {
                    // do the loop-de-loop
                    windEff.field_0x28 += i * 200 + 3600;
                    windEff.mAngleY += i * 200 + 3600;
                    if (windEff.field_0x28 > 60535)
                        windEff.field_0x32 = 0;
                } else {
                    f32 windVec_absXZ = std::sqrtf(windVec.x*windVec.x + windVec.z*windVec.z);
                    s16 targetAngleXZ = cM_atan2s(windVec.x, windVec.z);
                    s16 targetAngleY = cM_atan2s(windVec.y, windVec_absXZ);
                    cLib_addCalcAngleS(&windEff.mAngleY, targetAngleY, 10, 1000, 1);
                    cLib_addCalcAngleS(&windEff.mAngleXZ, targetAngleXZ, 10, 1000, 1);
                }

                cXyz move;
                move.x = cM_scos(windEff.mAngleY) * cM_ssin(windEff.mAngleXZ);
                move.y = cM_ssin(windEff.mAngleY);
                move.z = cM_scos(windEff.mAngleY) * cM_scos(windEff.mAngleXZ);

                fVar14 = fVar28 - (fVar28 * 0.2f) * (1.0f - windPow);
                windEff.mPos.x += move.x * fVar14;
                windEff.mPos.y += move.y * fVar14;
                windEff.mPos.z += move.z * fVar14;

                cXyz pos;
                pos.x = windEff.mBasePos.x + windEff.mPos.x;
                pos.y = windEff.mBasePos.y + windEff.mPos.y;
                pos.z = windEff.mBasePos.z + windEff.mPos.z;
                windEff.mpEmitter->setGlobalTranslation(pos);

                // so much stuff is missing in here

                fVar14 = fVar27 * (s32)(i / 30); 
                f32 distance = pos.getSquareDistance(pCamera->mLookat.mEye) / 200.0f;
                if (distance > 1.0f) {
                    distance = 1.0f;
                }

                f32 fVar15 = 1.0f;
                windEff.mpEmitter->setGlobalAlpha(fVar15 * 255.0f * windEff.mAlpha);
                if (windEff.mState == 1) {
                    cLib_addCalc(&windEff.mStateTimer, 1.0f, 0.3f, fVar14 * 0.1f, 0.01f);
                    if (windEff.mStateTimer >= 1.0f)
                        windEff.mState = 2;
                    if (windEff.mStateTimer > 0.5f)
                        cLib_addCalc(&windEff.mAlpha, 1.0f, 0.5f, 0.05f, 0.001f);
                } else {
                    cLib_addCalc(&windEff.mStateTimer, 0.0f, 0.4f, fVar14 * (i * 0.01f + 0.1f), 0.01f);
                    if (windEff.mStateTimer <= 0.0f) {
                        windEff.mpEmitter->deleteAllParticle();
                        windEff.mpEmitter->becomeInvalidEmitter();
                        windEff.mpEmitter = NULL;
                        windEff.mState = 0;
                        if (pWind->mbHasCustomWindPower == TRUE)
                            windEff.mState = 4;
                    }
                    if (windEff.mStateTimer < 0.5f)
                        cLib_addCalc(&windEff.mAlpha, 0.0f, 0.5f, 0.05f, 0.001f);
                }
            }

            break;
        case 3:
            if (!pWind->mbHasCustomWindPower)
                windEff.mState = 0;
            break;
        }
    }

    dKyr_kamome_move();
}

/* 8008C624-8008C888       .text dKyr_lenzflare_move__Fv */
void dKyr_lenzflare_move() {
    dKankyo_sun_Packet* pSunPkt = g_env_light.mpSunPacket;
    dKankyo_sunlenz_Packet* pLenzPkt = g_env_light.mpSunlenzPacket;
    camera_class* pCamera = (camera_class*)dComIfGp_getCamera(0);

    if (pSunPkt->mVisibility < 0.0001f)
        return;

    cXyz eyeVect;
    cXyz sunDirSmth;
    cXyz camFwd;
    cXyz vectle;
    cXyz projected;
    cXyz center;

    dKy_set_eyevect_calc(pCamera, &eyeVect, 7200.0005f, 7200.0005f);

    dKyr_get_vectle_calc(&eyeVect, pSunPkt->mPos, &sunDirSmth);
    pLenzPkt->mPositions[0] = pSunPkt->mPos[0];
    pLenzPkt->mPositions[1] = pSunPkt->mPos[0];

    mDoLib_project(pLenzPkt->mPositions, &projected);

    center.x = 320.0f;
    center.y = 240.0f;
    center.z = 0.0f;

    dKyr_get_vectle_calc(&center, &projected, &vectle);
    s16 angle = cM_atan2s(vectle.x, vectle.y);

    pLenzPkt->mAngleDeg = angle;
    pLenzPkt->mAngleDeg *= 0.005493164f;
    pLenzPkt->mAngleDeg += 180.0f;

    dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &camFwd);

    f32 size = sunDirSmth.abs(camFwd) * 350.0f + 250.0f;

    for (int i = 2; i < 8; i++) {
        pLenzPkt->mPositions[i].x = pSunPkt->mPos[0].x - sunDirSmth.x * size * i;
        pLenzPkt->mPositions[i].y = pSunPkt->mPos[0].y - sunDirSmth.y * size * i;
        pLenzPkt->mPositions[i].z = pSunPkt->mPos[0].z - sunDirSmth.z * size * i;
    }
}

/* 8008C888-8008C8B8       .text dKyr_moon_arrival_check__Fv */
BOOL dKyr_moon_arrival_check() {
    BOOL ret = false;
    if (g_env_light.mCurTime > 277.5f || g_env_light.mCurTime < 112.5f)
        ret = true;
    return ret;
}

/* 8008C8B8-8008CF68       .text dKyr_sun_move__Fv */
void dKyr_sun_move() {
    camera_class* pCamera;
    dKankyo_sun_Packet* pSunPkt = dKy_getEnvlight().mpSunPacket;
    dKankyo_sunlenz_Packet* pLenzPkt = dKy_getEnvlight().mpSunlenzPacket;
    pCamera = (camera_class*)dComIfGp_getCamera(0);

    f32 pulsePos;
    f32 staringAtSunAmount = 0.0f;
    u8 numPointsVisible = 0, numCenterPointsVisible = 0;
    u32 stType = dStage_stagInfo_GetSTType(dComIfGp_getStageStagInfo());
    cXyz lightDir;
    if (dKy_getEnvlight().mBaseLightInfluence.mColor.r == 0 && stType != dStageType_MISC_e) {
        dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &dKy_getEnvlight().mBaseLightInfluence.mPos, &lightDir);
    } else {
        dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &dKy_getEnvlight().mSunPos2, &lightDir);
    }

    pSunPkt->mPos[0].x = pCamera->mLookat.mEye.x + lightDir.x * 8000.0f;
    pSunPkt->mPos[0].y = pCamera->mLookat.mEye.y + lightDir.y * 8000.0f;
    pSunPkt->mPos[0].z = pCamera->mLookat.mEye.z + lightDir.z * 8000.0f;

    f32 horizonY = (pSunPkt->mPos[0].y - pCamera->mLookat.mEye.y) / 8000.0f;
    if (horizonY < 0.0f)
        horizonY = 0.0f;
    if (horizonY >= 1.0f)
        horizonY = 1.0f;
    horizonY = 1.0f - horizonY;
    horizonY *= horizonY;
    pulsePos = 1.0f - horizonY;

    if (dComIfGp_getStageStagInfo() != NULL) {
        dComIfGp_getStageStagInfo();
    }

    if (pSunPkt->field_0x3c != 0)
        pSunPkt->field_0x3c--;
    pSunPkt->field_0x3d = false;

    if (dKy_getEnvlight().mCurTime > 97.5f && dKy_getEnvlight().mCurTime < 292.5f) {
        f32 borderY = 0.0f;
        s32 numPointsCulled = 0;

        cLib_addCalc(&pSunPkt->mSunAlpha, 1.0f, 0.5f, 0.1f, 0.01f);

        if (pCamera != NULL) {
            borderY = pCamera->mCamera.mTrimHeight;
        }

        cXyz projected;
        mDoLib_project(pSunPkt->mPos, &projected);

        static const cXy sun_chkpnt[] = {
            0.0f, 0.0f,
            -10.0f, -20.0f,
            10.0f, 20.0f,
            -20.0f, 10.0f,
            20.0f, -10.0f,
        };

        for (s32 i = 0; i < 5; i++) {
            f32 screenBottom = 490.0f - borderY;
            cXyz chkpnt = projected;
            chkpnt.x -= sun_chkpnt[i].x;
            chkpnt.y -= sun_chkpnt[i].y;

            if (chkpnt.x > 0.0f && chkpnt.x < 640.0 && chkpnt.y > borderY && chkpnt.y < screenBottom) {
                if (pSunPkt->mVizChkData[i] >= 0xFFFFFF) {
                    numPointsVisible++;
                    if (i == 0)
                        numCenterPointsVisible++;
                }

                dComIfGd_peekZ(chkpnt.x, chkpnt.y, &pSunPkt->mVizChkData[i]);
            } else {
                numPointsCulled++;
            }
        }

        if (numPointsCulled != 0 && numPointsVisible != 0 && numCenterPointsVisible != 0) {
            numCenterPointsVisible = 1;
            numPointsVisible = 5;
        }

        if (numPointsVisible != 0) {
            if (pSunPkt->field_0x3c < 5)
                pSunPkt->field_0x3c += 2;
            pSunPkt->field_0x3d = true;
        }

        pLenzPkt->field_0x80 = pLenzPkt->field_0x88;
        pLenzPkt->field_0x84 = pLenzPkt->field_0x8c;
        pLenzPkt->field_0x88 = 1000000000.0f; // This is not G_CM3D_F_INF
        pLenzPkt->field_0x8c = 0.0f;

        cXyz center;
        center.x = 320.0f;
        center.y = 240.0f;
        center.z = 0.0f;
        pLenzPkt->mDistFalloff = center.abs(projected);
        pLenzPkt->mDistFalloff /= 450.0f;
        if (pLenzPkt->mDistFalloff > 1.0f)
            pLenzPkt->mDistFalloff = 1.0f;
        pLenzPkt->mDistFalloff = 1.0f - pLenzPkt->mDistFalloff;
        staringAtSunAmount = (pLenzPkt->mDistFalloff * pLenzPkt->mDistFalloff);
        pLenzPkt->mDistFalloff = 1.0f - staringAtSunAmount;
        staringAtSunAmount = staringAtSunAmount * staringAtSunAmount;
    } else {
        cLib_addCalc(&pSunPkt->mSunAlpha, 0.0f, 0.5f, 0.1f, 0.01f);
        numPointsVisible = 0;
        pSunPkt->field_0x3c = 0;
        pSunPkt->field_0x3d = false;
    }

    if (dKy_getEnvlight().mColpatWeather != 0 || (dKy_getEnvlight().mColpatCurr != 0 && dKy_getEnvlight().mColPatBlend > 0.5f)) {
        numCenterPointsVisible = 0;
        numPointsVisible = 0;
    }

    if (stType == dStageType_MISC_e) {
        numCenterPointsVisible = 0;
        numPointsVisible = 0;
    }

    if (dKy_getEnvlight().mCurTime < 120.0f || dKy_getEnvlight().mCurTime > 270.0f) {
        numCenterPointsVisible = 0;
        numPointsVisible = 0;
    }

    if (numCenterPointsVisible != 0) {
        if (numPointsVisible == 4)
            cLib_addCalc(&pSunPkt->mVisibility, 1.0f, 0.1f, 0.1f, 0.001f);
        if (numPointsVisible <= 3)
            cLib_addCalc(&pSunPkt->mVisibility, 0.0f, 0.1f, 0.2f, 0.001f);
        else
            cLib_addCalc(&pSunPkt->mVisibility, 1.0f, 0.5f, 0.2f, 0.01f);
    } else {
        if (numPointsVisible < 3)
            cLib_addCalc(&pSunPkt->mVisibility, 0.0f, 0.5f, 0.2f, 0.001f);
        else
            cLib_addCalc(&pSunPkt->mVisibility, 1.0f, 0.1f, 0.1f, 0.001f);
    }

    if (numPointsVisible >= 2) {
        dKy_getEnvlight().mpSunlenzPacket->mbDrawLenzInSky = false;
    } else {
        dKy_getEnvlight().mpSunlenzPacket->mbDrawLenzInSky = true;
    }

    if (pSunPkt->mPos[0].y > 0.0f && !dKy_getEnvlight().mpSunlenzPacket->mbDrawLenzInSky) {
        dKy_set_actcol_ratio(1.0f - staringAtSunAmount * pSunPkt->mVisibility);
        dKy_set_bgcol_ratio(1.0f - staringAtSunAmount * pSunPkt->mVisibility);
        dKy_set_fogcol_ratio(staringAtSunAmount * pSunPkt->mVisibility * pulsePos * 0.5f + 1.0f);
        dKy_set_vrboxcol_ratio(staringAtSunAmount * pSunPkt->mVisibility * pulsePos * 0.5f + 1.0f);
    }

    if (dKyr_moon_arrival_check()) {
        f32 alpha = (pSunPkt->mPos[0].y - pCamera->mLookat.mEye.y) / -8000.0f;
        alpha *= alpha;
        alpha *= 6.0f;
        if (alpha > 1.0f)
            alpha = 1.0f;
        cLib_addCalc(&pSunPkt->mMoonAlpha, alpha, 0.2f, 0.01f, 0.001f);
    } else {
        cLib_addCalc(&pSunPkt->mMoonAlpha, 0.0f, 0.2f, 0.01f, 0.001f);
    }
}

/* 8008CF68-8008D0B4       .text dKyr_rain_init__Fv */
void dKyr_rain_init() {
    camera_class * pCamera = (camera_class*)dComIfGp_getCamera(0);
    g_env_light.mpRainPacket->mpTxSnow01 = (u8*)dComIfG_getObjectRes("Always", ALWAYS_I8_TX_SNOW01);
    g_env_light.mpRainPacket->mpTxRingAHalf = (u8*)dComIfG_getObjectRes("Always", ALWAYS_BTI_TXA_RING_A_32HAFE);
    g_env_light.mpRainPacket->mCamEyePos = pCamera->mLookat.mEye;
    g_env_light.mpRainPacket->mCamCenterPos = pCamera->mLookat.mCenter;
    g_env_light.mpRainPacket->mCenterDeltaMul = 0.0f;
    g_env_light.mpRainPacket->field_0x3700 = 0.0f;
    g_env_light.mpRainPacket->mSibukiAlpha = 0.0f;
    g_env_light.mpRainPacket->mOverheadFade = 0.0f;
    g_env_light.mpRainPacket->mFwdFade1 = 0.0f;
    g_env_light.mpRainPacket->mFwdFade2 = 0.0f;
    g_env_light.mpRainPacket->mStatus = 0;
    g_env_light.mpRainPacket->mCenterDelta.x = 0.0f;
    g_env_light.mpRainPacket->mCenterDelta.y = 0.0f;
    g_env_light.mpRainPacket->mCenterDelta.z = 0.0f;
    for (u32 i = 0; i < ARRAY_SIZE(g_env_light.mpRainPacket->mEff); i++)
        g_env_light.mpRainPacket->mEff[i].mStatus = 0;
    g_env_light.mpRainPacket->mRainCount = 0;
}

/* 8008D0B4-8008D0DC       .text rain_bg_chk__FP19dKankyo_rain_Packeti */
void rain_bg_chk(dKankyo_rain_Packet* pPkt, int idx) {
    pPkt->mEff[idx].field_0x30 = dComIfGp_getCamera(0)->mLookat.mCenter.y + -800.0f;
}

/* 8008D0DC-8008D53C       .text overhead_bg_chk__Fv */
bool overhead_bg_chk() {
    camera_class* pCamera = (camera_class*)dComIfGp_getCamera(0);
    bool ret = false;

    dBgS_ObjGndChk_All gndChk;
    dBgS_RoofChk roofChk;
    cXyz pos = pCamera->mLookat.mEye;
    pos.y += 50.0f;
    roofChk.SetPos(pos);

    if (dComIfG_Bgsp()->RoofChk(&roofChk) != G_CM3D_F_INF)
        ret = true;
    pos.y += 10000.0f;
    gndChk.SetPos(&pos);

    if (dComIfG_Bgsp()->GroundCross(&gndChk) > (pCamera->mLookat.mEye.y + 50.0f))
        ret = true;

    return ret;
}

/* 8008D638-8008DAF0       .text forward_overhead_bg_chk__FP4cXyzf */
bool forward_overhead_bg_chk(cXyz* pPos, f32 dist) {
    camera_class* pCamera = (camera_class*)dComIfGp_getCamera(0);
    bool ret = false;

    dBgS_ObjGndChk_All gndChk;
    dBgS_RoofChk roofChk;
    cXyz pos;
    cXyz lookDir;
    dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &lookDir);
    pos.x = pCamera->mLookat.mEye.x + lookDir.x * dist;
    pos.y = pCamera->mLookat.mEye.y + lookDir.y * dist;
    pos.z = pCamera->mLookat.mEye.z + lookDir.z * dist;
    pos.y = pCamera->mLookat.mEye.y + 50.f;

    *pPos = pos;
    roofChk.SetPos(pos);

    if (dComIfG_Bgsp()->RoofChk(&roofChk) != G_CM3D_F_INF)
        ret = true;
    pos.y += 10000.0f;
    gndChk.SetPos(&pos);

    if (dComIfG_Bgsp()->GroundCross(&gndChk) > (pCamera->mLookat.mEye.y + 50.0f))
        ret = true;

    return ret;
}

/* 8008DAF0-8008E79C       .text dKyr_rain_move__Fv */
void dKyr_rain_move() {
    dKankyo_rain_Packet* rain_packet;
    camera_class* camera;

    rain_packet = g_env_light.mpRainPacket;
    camera = (camera_class*)dComIfGp_getCamera(0);
    fopAc_ac_c* player = dComIfGp_getPlayer(0);
    cXyz spFC;
    cXyz spF0;
    cXyz spE4;
    cXyz spD8;
    cXyz spCC = dKyw_get_wind_vecpow();

    cXyz spC0;
    cXyz spB4;
    cXyz spA8;
    cXyz sp9C;
    cXyz sp90;

    cXyz* sp3C;
    f32 sp38;
    BOOL sp34;
    BOOL sp30;
    BOOL sp2C;
    u32 sp28;
    BOOL sp24 = 0;
    f32 sp20;
    BOOL sp1C = 0;

    f32 var_f31;
    f32 var_f30;
    f32 var_f29;
    f32 var_f28;

    sp28 = dStage_stagInfo_GetSTType(dComIfGp_getStageStagInfo());

    spA8.x = 0.0f;
    spA8.y = -2.5f;
    spA8.z = 0.0f;

    if (rain_packet->mRainCount <= g_env_light.mRainCount) {
        rain_packet->mRainCount = g_env_light.mRainCount;
    }

    if (rain_packet->mRainCount != 0) {
        dKyr_get_vectle_calc(&camera->mLookat.mCenter, &rain_packet->mCamCenterPos, &spB4);

        var_f30 = rain_packet->mCamEyePos.abs(camera->mLookat.mEye);

        if (var_f30 > 10.0f) {
            var_f30 = (var_f30 - 10.0f) / 50.0f;
            if (var_f30 > 1.0f) {
                var_f30 = 1.0f;
            }
        } else {
            var_f30 = 0.0f;
        }

        rain_packet->mCamEyePos = camera->mLookat.mEye;

        var_f29 = rain_packet->mCamCenterPos.abs(camera->mLookat.mCenter);
        if (var_f29 > 10.0f) {
            var_f29 = (var_f29 - 10.0f) / 50.0f;
            if (var_f29 > 1.0f) {
                var_f29 = 1.0f;
            }
        } else {
            var_f29 = 0.0f;
        }

        cLib_addCalc(&rain_packet->mCenterDeltaMul, var_f30 * var_f29, 0.2f, 0.1f, 0.01f);
        if (rain_packet->mCenterDeltaMul > 0.3f) {
            rain_packet->mCenterDeltaMul = 0.3f;
        }

        cLib_addCalc(&rain_packet->mCenterDelta.x, spB4.x, 0.2f, 0.1f, 0.01f);
        cLib_addCalc(&rain_packet->mCenterDelta.y, spB4.y, 0.2f, 0.1f, 0.01f);
        cLib_addCalc(&rain_packet->mCenterDelta.z, spB4.z, 0.2f, 0.1f, 0.01f);
        rain_packet->mCamCenterPos = camera->mLookat.mCenter;

        dKy_set_eyevect_calc2(camera, &spFC, 700.0f, 600.0f);
        spD8.x = spD8.y = spD8.z = 0.0f;

        sp3C = dKyw_get_wind_vec();
        sp38 = dKyw_get_wind_pow();

        rain_packet->field_0x36cc = 0;
        rain_packet->field_0x36c8 = 0;
        rain_packet->mStatus = 0;

        sp34 = 0;
        sp30 = 0;
        sp2C = 0;

        f32 fadeMaxXZDist = 0.0f;
        f32 fadeMaxY = 0.0f;
        if (sp28 == dStageType_MISC_e && strcmp(dComIfGp_getStartStageName(), "Ocrogh") != 0 && strcmp(dComIfGp_getStartStageName(), "Omori") != 0) {
            if (strcmp(dComIfGp_getStartStageName(), "Orichh") == 0)
                fadeMaxXZDist = 2300.0f;
            else
                fadeMaxXZDist = 1200.0f;

            if (strcmp(dComIfGp_getStartStageName(), "Atorizk") == 0)
                fadeMaxY = 1300.0f;
        }

        if (sp1C == 0) {
            sp34 = overhead_bg_chk();
            sp30 = forward_overhead_bg_chk(&sp9C, 700.0f);
            sp2C = forward_overhead_bg_chk(&sp90, 1400.0f);

            if (sp34) {
                rain_packet->mStatus |= (u8)1;
            } else if (sp30) {
                rain_packet->mStatus |= (u8)2;
            }
        } else {
            sp24 = 1;
            rain_packet->mStatus |= (u8)1;
            sp20 = 1200.0f;
        }

        if (sp34) {
            cLib_addCalc(&rain_packet->mOverheadFade, 0.0f, 0.5f, 0.2f, 0.01f);
        } else {
            cLib_addCalc(&rain_packet->mOverheadFade, 1.0f, 0.1f, 0.1f, 0.001f);
        }

        if (sp30) {
            cLib_addCalc(&rain_packet->mFwdFade1, 0.0f, 0.5f, 0.2f, 0.01f);
        } else {
            cLib_addCalc(&rain_packet->mFwdFade1, 1.0f, 0.1f, 0.1f, 0.001f);
        }

        if (sp2C) {
            cLib_addCalc(&rain_packet->mFwdFade2, 0.0f, 0.5f, 0.2f, 0.01f);
        } else {
            cLib_addCalc(&rain_packet->mFwdFade2, 1.0f, 0.1f, 0.1f, 0.001f);
        }

        for (int i = rain_packet->mRainCount - 1; i >= 0; i--) {
            rain_packet->mEff[i].mBasePos.y = spFC.y;

            switch (rain_packet->mEff[i].mStatus) {
            case 0:
                rain_packet->mEff[i].field_0x24 = -(cM_rndF(10.0f) + 35.5f);
                rain_packet->mEff[i].mTimer = 0;
                rain_packet->mEff[i].mBasePos.x = spFC.x;
                rain_packet->mEff[i].mBasePos.y = spFC.y;
                rain_packet->mEff[i].mBasePos.z = spFC.z;
                rain_packet->mEff[i].mPos.x = cM_rndFX(800.0f);
                rain_packet->mEff[i].mPos.y = cM_rndF(600.0f);
                rain_packet->mEff[i].mPos.z = cM_rndFX(800.0f);
                rain_packet->mEff[i].mAlpha = 1.0f;
                rain_packet->mEff[i].field_0x1c = cM_rndF(360.0f);
                rain_packet->mEff[i].field_0x20 = cM_rndF(360.0f);

                rain_bg_chk(rain_packet, i);
                rain_packet->mEff[i].mStatus++;
                break;
            case 1:
            case 2:
            case 3:
                cLib_addCalc(&rain_packet->mEff[i].field_0x24, rain_packet->mEff[i].field_0x24 - cM_rndFX(0.1f), 0.5f, 0.1f, 0.01f);

                rain_packet->mEff[i].mPos.x +=
                    20.0f *
                    ((spCC.x + (10.0f * (rain_packet->mCenterDelta.x * rain_packet->mCenterDeltaMul))) +
                     (spA8.x + (0.08f * (f32)(i & 7))));

                rain_packet->mEff[i].mPos.y +=
                    ((f32)(i & 7) * -2.0f) +
                    (20.0f *
                     (spA8.y +
                      (spCC.y + ((rain_packet->mCenterDelta.y * rain_packet->mCenterDeltaMul) * 10.0f))));

                rain_packet->mEff[i].mPos.z +=
                    20.0f *
                    ((spCC.z + (10.0f * (rain_packet->mCenterDelta.z * rain_packet->mCenterDeltaMul))) +
                     (spA8.z + (0.08f * (f32)(i & 3))));

                spC0.x = rain_packet->mEff[i].mBasePos.x + rain_packet->mEff[i].mPos.x;
                spC0.y = spFC.y;
                spC0.z = rain_packet->mEff[i].mBasePos.z + rain_packet->mEff[i].mPos.z;

                f32 var_f1 = spC0.abs(spFC);

                if (rain_packet->mEff[i].mTimer == 0) {
                    if (var_f1 > 800.0f) {
                        rain_packet->mEff[i].mTimer = 10;
                        rain_packet->mEff[i].field_0x24 = -(cM_rndF(10.0f) + 35.5f);
                        rain_packet->mEff[i].mBasePos = spFC;

                        if (spC0.abs(spFC) > 850.0f) {
                            rain_packet->mEff[i].mPos.x = cM_rndFX(800.0f);
                            rain_packet->mEff[i].mPos.y = cM_rndFX(800.0f);
                            rain_packet->mEff[i].mPos.z = cM_rndFX(800.0f);
                        } else {
                            var_f31 = cM_rndFX(40.0f);
                            get_vectle_calc(&spC0, &spFC, &spB4);

                            rain_packet->mEff[i].mPos.x = spB4.x * (var_f31 + 800.0f);
                            rain_packet->mEff[i].mPos.y = spB4.y * (var_f31 + 800.0f);
                            rain_packet->mEff[i].mPos.z = spB4.z * (var_f31 + 800.0f);
                        }

                        rain_packet->mEff[i].mStatus = 1;
                        rain_bg_chk(rain_packet, i);
                    }

                    spC0.y = rain_packet->mEff[i].mBasePos.y + rain_packet->mEff[i].mPos.y;
                    if (spC0.y < rain_packet->mEff[i].field_0x30 + 20.0f) {
                        rain_packet->mEff[i].mBasePos = spFC;
                        rain_packet->mEff[i].mPos.x = cM_rndFX(800.0f);
                        rain_packet->mEff[i].mPos.y = 200.0f;
                        rain_packet->mEff[i].mPos.z = cM_rndFX(800.0f);
                        rain_bg_chk(rain_packet, i);
                        rain_packet->mEff[i].mTimer = 10;
                    }
                } else {
                    rain_packet->mEff[i].mTimer--;
                }
            }

            spC0.x = rain_packet->mEff[i].mBasePos.x + rain_packet->mEff[i].mPos.x;
            spC0.y = rain_packet->mEff[i].mBasePos.y + rain_packet->mEff[i].mPos.y;
            spC0.z = rain_packet->mEff[i].mBasePos.z + rain_packet->mEff[i].mPos.z;

            if (i > g_env_light.mRainCount - 1) {
                if (i == rain_packet->mRainCount - 1) {
                    rain_packet->mRainCount--;
                }
            }

            var_f31 = 1.0f;
            if (sp34 || rain_packet->mOverheadFade < 1.0f) {
                cXyz sp80;
                f32 sp10 = 800.0f;
                sp80 = spC0;
                sp80.y = camera->mLookat.mEye.y;

                if (camera->mLookat.mEye.abs(sp80) < sp10) {
                    var_f31 *= rain_packet->mOverheadFade * 1.0f;
                }
            }

            if (sp30 || rain_packet->mFwdFade1 < 1.0f) {
                cXyz sp74;
                f32 sp0C = 550.0f;
                sp74 = spC0;
                sp74.y = sp9C.y;

                if (sp9C.abs(sp74) < sp0C) {
                    var_f31 *= rain_packet->mFwdFade1;
                }
            }

            if (sp2C || rain_packet->mFwdFade2 < 1.0f) {
                cXyz sp68;
                f32 sp08 = 550.0f;
                sp68 = spC0;
                sp68.y = sp90.y;

                if (sp90.abs(sp68) < sp08) {
                    var_f31 *= rain_packet->mFwdFade2;
                }
            }

            if (sp24) {
                cXyz sp5C;
                cXyz sp50;
                sp50.x = 27453.0f;
                sp50.y = spC0.y;
                sp50.z = 8528.0f;

                if (spC0.y < 1300.0f || player->current.pos.y < 1100.0f) {
                    if (spC0.abs(sp50) > 80.0f) {
                        var_f31 = 0.0f;
                    }
                } else {
                    if (spC0.abs(sp50) > 500.0f) {
                        var_f31 = 0.0f;
                    }
                }
            }

            rain_packet->mEff[i].mAlpha = var_f31 * (1.0f + cM_rndFX(0.5f));
        }
    }
}

/* 8008E79C-8008F0BC       .text dKyr_housi_move__Fv */
void dKyr_housi_move() {
    /* Nonmatching */
    dKankyo_housi_Packet* housi_packet = g_env_light.mpHousiPacket;
    HOUSI_EFF* effect;
    camera_class* camera = (camera_class*)dComIfGp_getCamera(0);
    fopAc_ac_c* player = dComIfGp_getPlayer(0);

    cXyz sp84;
    cXyz sp78 = dKyw_get_wind_vecpow();
    cXyz sp6C;
    cXyz sp60;

    dBgS_GndChk gndchk;
    bool var_r27 = 0;
    f32 var_f31 = 1.0f;

    f32 var_f30 = -100000000.0f;

    cXyz sp54;

    if (g_env_light.mHousiCount != 0 ||
        (g_env_light.mHousiCount == 0 && housi_packet->field_0x5ddc <= 0.0f))
    {
        housi_packet->mCount = g_env_light.mHousiCount;
    }

    if (g_env_light.mHousiCount != 0) {
        cLib_addCalc(&housi_packet->field_0x5ddc, 1.0f, 0.2f, 0.05f, 0.01f);
    } else {
        cLib_addCalc(&housi_packet->field_0x5ddc, 0.0f, 0.2f, 0.05f, 0.01f);
    }

    if (housi_packet->mCount == 0) {
        return;
    }

    dKy_set_eyevect_calc2(camera, &sp84, 800.0f, 800.0f);
    dKyw_get_wind_pow();

    for (int i = housi_packet->mCount - 1; i >= 0; i--) {
        f32 var_f26 = housi_packet->field_0x5ddc;
        effect = &housi_packet->mEffect[i];

        switch (housi_packet->mEffect[i].mStatus) {
        case 0:
            effect->field_0x34 = cM_rndF(1.5f) + 0.2f;
            effect->field_0x3c = 0;
            effect->field_0x4c = cM_rndFX(65536.0f);
            effect->mBasePos.x = sp84.x;
            effect->mBasePos.y = sp84.y;
            effect->mBasePos.z = sp84.z;
            effect->mPos.x = cM_rndFX(1000.0f);
            effect->mPos.y = 1000.0f;
            effect->mPos.z = cM_rndFX(1000.0f);
            effect->mAlpha = 0.0f;
            effect->field_0x48 = 0.0f;
            effect->mScale.x = cM_rndF(360.0f);
            effect->mScale.y = cM_rndF(360.0f);
            effect->mScale.z = cM_rndF(360.0f);
            effect->mSpeed.x = 0.0f;
            effect->mSpeed.y = 0.0f;
            effect->mSpeed.z = 0.0f;

            if (effect->mBasePos.y + effect->mPos.y < -100149.9f) {
                effect->mPos.y = (-99999.9f - effect->mBasePos.y) + 10.0f;
            }

            effect->mStatus++;
            break;
        case 1:
        case 2:
        case 3:
            f32 var_f24 = 2.5f;

            if (effect->mStatus != 1) {
                f32 var_f23 = effect->field_0x34;
                f32 temp_f0_5 = cM_fsin(effect->mScale.x);

                effect->mPos.y += var_f23 * (sp78.y * var_f24);
                effect->mPos.x += var_f23 * (sp78.x * var_f24);
                effect->mPos.y -= var_f23 * 0.6f;

                effect->mPos.z += var_f23 * (sp78.z * var_f24);

                effect->mPos.x += temp_f0_5 * var_f23;
                effect->mPos.y += var_f23 * 0.5f * cM_fsin(effect->mScale.y);
                effect->mPos.z += cM_fsin(effect->mScale.z) * var_f23;
            }

            effect->mScale.x += 0.03f;
            effect->mScale.y += 0.02f;
            effect->mScale.z += 0.01f;

            sp6C.x = effect->mBasePos.x + effect->mPos.x;
            sp6C.y = effect->mBasePos.y + effect->mPos.y;
            sp6C.z = effect->mBasePos.z + effect->mPos.z;

            sp60 = dKyw_pntwind_get_vecpow(&sp6C);

            if (effect->mSpeed.x < 30.0f) {
                effect->mSpeed.x += sp60.x * 9.0f;
            }

            if (effect->mSpeed.y < 30.0f) {
                effect->mSpeed.y += sp60.y * 9.0f;
            }

            if (effect->mSpeed.z < 30.0f) {
                effect->mSpeed.z += sp60.z * 9.0f;
            }

            cLib_addCalc(&effect->mSpeed.x, 0.0f, 0.2f, 0.1f, 0.00001f);
            cLib_addCalc(&effect->mSpeed.y, 0.0f, 0.2f, 0.1f, 0.00001f);
            cLib_addCalc(&effect->mSpeed.z, 0.0f, 0.2f, 0.1f, 0.00001f);

            effect->mPos.x += effect->mSpeed.x;
            effect->mPos.y += effect->mSpeed.y;
            effect->mPos.z += effect->mSpeed.z;

            sp6C.x = effect->mBasePos.x + effect->mPos.x;
            sp6C.y = effect->mBasePos.y + effect->mPos.y;
            sp6C.z = effect->mBasePos.z + effect->mPos.z;

            f32 var_f1_4 = sp6C.abs(sp84);

            if (effect->field_0x3c == 0) {
                if (var_f1_4 > 1000.0f || sp6C.y < -99979.9f) {
                    effect->field_0x3c = 10;
                    effect->mBasePos = sp84;

                    if (sp6C.abs(sp84) > 1050.0f) {
                        effect->mPos.x = cM_rndFX(1000.0f);
                        effect->mPos.y = cM_rndFX(1000.0f);
                        effect->mPos.z = cM_rndFX(1000.0f);
                    } else {
                        f32 temp_f23 = cM_rndFX(50.0f);
                        get_vectle_calc(&sp6C, &sp84, &sp60);

                        effect->mPos.x = sp60.x * (temp_f23 + 1000.0f);
                        effect->mPos.y = sp60.y * (temp_f23 + 1000.0f);
                        effect->mPos.z = sp60.z * (temp_f23 + 1000.0f);
                    }

                    effect->mSpeed.x = 0.0f;
                    effect->mSpeed.y = 0.0f;
                    effect->mSpeed.z = 0.0f;

                    effect->mStatus = 1;
                }
            } else {
                effect->field_0x3c--;
            }
            break;
        }

        sp6C.x = effect->mBasePos.x + effect->mPos.x;
        sp6C.y = effect->mBasePos.y + effect->mPos.y;
        sp6C.z = effect->mBasePos.z + effect->mPos.z;

        effect->field_0x4c += 600;
        if (effect->field_0x4c > 30000) {
            var_f26 = 0.0f;
        }

        cLib_addCalc(&effect->mAlpha, var_f26, 0.5f, 0.02f, 0.00001f);
    }
}

/* 8008F0BC-8008F23C       .text dKyr_snow_init__Fv */
void dKyr_snow_init() {
    camera_class* pCamera = (camera_class*)dComIfGp_getCamera(0);
    g_env_light.mpSnowPacket = new(0x20) dKankyo_snow_Packet();
    if (g_env_light.mpSnowPacket != NULL) {
        if (strcmp(dComIfGp_getStartStageName(), "Adanmae") != 0) {
            g_env_light.mpSnowPacket->mpTexture = (u8*)dComIfG_getObjectRes("Always", ALWAYS_I8_TX_SNOW01);
        } else {
            g_env_light.mpSnowPacket->mpTexture = (u8*)dComIfG_getStageRes("Stage", "ak_kazanbai00.bti");
        }

        for (u32 i = 0; i < ARRAY_SIZE(g_env_light.mpSnowPacket->mEff); i++)
            g_env_light.mpSnowPacket->mEff[i].mStatus = 0;
        g_env_light.mpSnowPacket->mEffCount = 0;
        g_env_light.mpSnowPacket->mOldEyePos = pCamera->mLookat.mEye;
    }
}

/* 8008F23C-8008F9FC       .text dKyr_snow_move__Fv */
void dKyr_snow_move() {
    /* Nonmatching */
}

/* 8008F9FC-8009065C       .text dKyr_kazanbai_move__Fv */
void dKyr_kazanbai_move() {
    /* Nonmatching */
}

/* 8009065C-80090C68       .text dKyr_kazanbai_tamari_move__Fv */
void dKyr_kazanbai_tamari_move() {
    /* Nonmatching */
}

/* 80090C68-80090D50       .text dKyr_star_init__Fv */
void dKyr_star_init() {
    g_env_light.mpStarPacket = new(0x20) dKankyo_star_Packet();
    if (g_env_light.mpStarPacket != NULL) {
        g_env_light.mpStarPacket->mpTexture = (u8*)dComIfG_getObjectRes("Always", ALWAYS_I8_TX_SNOW01);
        g_env_light.mpStarPacket->mEffect[0].mSin = 1.0f;
        g_env_light.mpStarPacket->mEffectNum = 0;
    }
}

/* 80090D50-80090DE0       .text dKyr_star_move__Fv */
void dKyr_star_move() {
    dKankyo_star_Packet* pPkt = g_env_light.mpStarPacket;
    pPkt->mEffectNum = g_env_light.mStarCount;
    if (pPkt->mEffectNum != 0) {
        f32 wave = std::fabsf(cM_fsin(pPkt->mEffect[0].mAnimCounter));
        pPkt->mEffect[0].mAnimCounter += 0.01f;
        pPkt->mEffect[0].mSin = wave;
        cLib_addCalc(&pPkt->mEffect[0].mSin, wave, 0.5f, 0.1f, 0.01f);
    }
}

/* 80090DE0-80091964       .text wave_move__Fv */
void wave_move() {
    /* Nonmatching */
    dScnKy_env_light_c& envLight = dKy_getEnvlight();
    dStage_FileList_dt_c* fili_p;
    fopAc_ac_c* pPlayer;
    cXyz* windVecP;
    dKankyo_wave_Packet* pPkt;
    camera_class* pCamera;
    f32 seaLevel;
    cXyz newPos2;
    cXyz eyevect;
    cXyz d0;
    cXyz newPos3;
    cXyz windPowVec2;
    cXyz windPowVec;
    cXyz windNrmVec2;
    cXyz vectle;
    cXyz pos;
    cXyz newPos;
    DOUBLE_POS deltaXZ;
    Mtx drawMtx;
    s32 roomNo;
    f32 windPow;
    s32 stageWindY;
    s16 windX;
    s16 windY;

    windPowVec = dKyw_get_wind_vecpow();

    fili_p = NULL;
    pPkt = g_env_light.mpWavePacket;
    pCamera = (camera_class*)dComIfGp_getCamera(0);
    pPlayer = dComIfGp_getPlayer(0);

    roomNo = dComIfGp_roomControl_getStayNo();
    if (roomNo >= 0)
        fili_p = dComIfGp_roomControl_getStatusRoomDt(roomNo)->getFileListInfo();

    if (fili_p != NULL)
        seaLevel = dStage_FileList_dt_SeaLevel(fili_p);

    if (g_env_light.mWaveChan.mWaveFlatInter >= 1.0f)
        return;

    if (dComIfGd_getView() != NULL) {
        MTXInverse(dComIfGd_getViewRotMtx(), drawMtx);
    } else {
        return;
    }

    dKy_set_eyevect_calc2(pCamera, &eyevect, g_env_light.mWaveChan.mWaveSpawnDist, 0.0f);
    d0.x = d0.y = d0.z = 0.0f;

    windVecP = dKyw_get_wind_vec();
    windPow = dKyw_get_wind_pow();
    windPowVec2 = *windVecP;

    if (dStage_stagInfo_GetSTType(dComIfGp_getStageStagInfo()) == dStageType_MISC_e) {
        stageWindY = 0;

        if (strcmp(dComIfGp_getStartStageName(), "LinkRM") == 0)
            stageWindY = 0x4000;
        else if (strcmp(dComIfGp_getStartStageName(), "Orichh") == 0)
            stageWindY = -0x4000;
        else if (strcmp(dComIfGp_getStartStageName(), "Ojhous2") == 0)
            stageWindY = 0x7fff;
        else if (strcmp(dComIfGp_getStartStageName(), "Omasao") == 0)
            stageWindY = -0x4000;
        else if (strcmp(dComIfGp_getStartStageName(), "Onobuta") == 0)
            stageWindY = 0x4000;

        if (dComIfGs_getWindX() == -1 && dComIfGs_getWindY() == -1) {
            windX = 0;
            windY = 0;
        } else {
            windX = g_env_light.mWind.mTactWindAngleX;
            windY = g_env_light.mWind.mTactWindAngleY;
        }

        windY += stageWindY;

        windNrmVec2.x = cM_scos(windX) * cM_scos(windY);
        windNrmVec2.y = cM_ssin(windX);
        windNrmVec2.z = cM_scos(windX) * cM_ssin(windY);

        windPowVec.x = 0.6f * windNrmVec2.x;
        windPowVec.y = 0.6f * windNrmVec2.y;
        windPowVec.z = 0.6f * windNrmVec2.z;
        windPowVec2 = windPowVec;
        windPow = 0.6f;
    }

    d0.x = d0.y = d0.z = 0.0f;

    deltaXZ.x = pCamera->mLookat.mCenter.x - pCamera->mLookat.mEye.x;
    deltaXZ.y = 0.0f;
    deltaXZ.z = pCamera->mLookat.mCenter.z - pCamera->mLookat.mEye.z;
    vectle_calc(&deltaXZ, &vectle);

    pPkt->mSkewDir = cM3d_VectorProduct2d(0.0f, 0.0f, -windPowVec2.x, -windPowVec2.z, vectle.x, vectle.z);
    pPkt->mSkewWidth = windPow * (1.0f - std::fabsf(windPowVec2.y)) * (1.0f - std::fabsf(windPowVec2.x * vectle.x + windPowVec2.z * vectle.z));
    pPkt->mSkewWidth *= 0.6f * std::fabsf(pPkt->mSkewDir);

    for (s32 i = 0; i < g_env_light.mWaveChan.mWaveCount; i++) {
        if (g_env_light.mWaveChan.mWaveReset)
            pPkt->mEff[i].mStatus = 0;

        switch (pPkt->mEff[i].mStatus) {
        case 0:
            {
                pPkt->mEff[i].mBasePos.x = eyevect.x;
                pPkt->mEff[i].mBasePos.y = seaLevel;
                pPkt->mEff[i].mBasePos.z = eyevect.z;
                pPkt->mEff[i].mPos.x = cM_rndFX(g_env_light.mWaveChan.mWaveSpawnRadius);
                pPkt->mEff[i].mPos.y = 0.0f;
                pPkt->mEff[i].mPos.z = cM_rndFX(g_env_light.mWaveChan.mWaveSpawnRadius);
                pPkt->mEff[i].mCounter = cM_rndF(65536.0f);
                pPkt->mEff[i].mAlpha = 0.0f;
                pPkt->mEff[i].field_0x32 = cM_rndF(65536.0f);
                pPkt->mEff[i].mStrengthEnv = 1.0f;
                pPkt->mEff[i].mScale = g_env_light.mWaveChan.mWaveScaleRand + cM_rndF(1.0f - g_env_light.mWaveChan.mWaveScaleRand);
                pPkt->mEff[i].mSpeed = pPkt->mEff[i].mScale;
                pPkt->mEff[i].mCounterSpeed = ((1.0f - pPkt->mEff[i].mScale) * 0.05f + 0.02f) * g_env_light.mWaveChan.mWaveCounterSpeedScale;
                pPkt->mEff[i].field_0x30 = 0;
                pPkt->mEff[i].mStatus++;
            }
            // fallthrough
        case 1:
        case 2:
            {
                pPkt->mEff[i].mPos.x += (windPowVec.x * g_env_light.mWaveChan.mWaveSpeed * pPkt->mEff[i].mSpeed) * (pPkt->mEff[i].mStrengthEnv * 0.5f + 0.5f) * (pPkt->mEff[i].mAlpha * 0.8f + 0.2f);
                pPkt->mEff[i].mPos.z += (windPowVec.z * g_env_light.mWaveChan.mWaveSpeed * pPkt->mEff[i].mSpeed) * (pPkt->mEff[i].mStrengthEnv * 0.5f + 0.5f) * (pPkt->mEff[i].mAlpha * 0.8f + 0.2f);
                pPkt->mEff[i].mCounter += pPkt->mEff[i].mCounterSpeed;
                pos.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
                pos.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
                pos.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;
                if (pos.abs(eyevect) > g_env_light.mWaveChan.mWaveSpawnRadius) {
                    pPkt->mEff[i].mBasePos.x = eyevect.x;
                    pPkt->mEff[i].mBasePos.z = eyevect.z;
                    if (pos.abs(eyevect) > (g_env_light.mWaveChan.mWaveSpawnRadius + 350.0f)) {
                        pPkt->mEff[i].mPos.x = cM_rndFX(g_env_light.mWaveChan.mWaveSpawnRadius);
                        pPkt->mEff[i].mPos.z = cM_rndFX(g_env_light.mWaveChan.mWaveSpawnRadius);
                    } else {
                        get_vectle_calc(&pos, &eyevect, &newPos);
                        pPkt->mEff[i].mPos.x = newPos.x * g_env_light.mWaveChan.mWaveSpawnRadius;
                        pPkt->mEff[i].mPos.z = newPos.z * g_env_light.mWaveChan.mWaveSpawnRadius;
                    }
                    pPkt->mEff[i].mAlpha = 0.0f;
                }
                pos.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
                pos.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
                pos.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;

                pPkt->mEff[i].mStrengthEnv = 1.0f;
                for (s32 j = 0; j < 10; j++) {
                    if (envLight.mpWaveInfl[j] == NULL)
                        continue;

                    envLight.mpWaveInfl[j]->mPos.y = pos.y;
                    f32 dist = pos.abs(envLight.mpWaveInfl[j]->mPos);
                    f32 outerRadius = envLight.mpWaveInfl[j]->mOuterRadius;
                    f32 innerRadius = envLight.mpWaveInfl[j]->mInnerRadius;
                    if (dist < outerRadius) {
                        if (dist < innerRadius) {
                            pPkt->mEff[i].mStrengthEnv = 0.0f;
                            break;
                        }

                        f32 range = outerRadius - innerRadius;
                        if (range > 0.0f) {
                            if (pPkt->mEff[i].mStrengthEnv > (dist - innerRadius) / range)
                                pPkt->mEff[i].mStrengthEnv = (dist - innerRadius) / range;
                        } else {
                            pPkt->mEff[i].mStrengthEnv = 0.0f;
                        }
                    }
                }

                if (g_env_light.mWaveChan.mWaveFlatInter > 0.0f) {
                    newPos3 = pCamera->mLookat.mEye;
                    newPos3.y = pos.y;

                    f32 dist = pos.abs(newPos3);
                    f32 innerRadius = g_env_light.mWaveChan.mWaveFlatInter * (g_env_light.mWaveChan.mWaveSpawnRadius * 1.5f);
                    f32 outerRadius = innerRadius + 1000.0f;
                    f32 range = outerRadius - innerRadius;
                    if (range > 0.0f) {
                        if (pPkt->mEff[i].mStrengthEnv > (dist - innerRadius) / range)
                            pPkt->mEff[i].mStrengthEnv = (dist - innerRadius) / range;
                    } else {
                        pPkt->mEff[i].mStrengthEnv = 0.0f;
                    }
                }

                {
                    newPos3 = pPlayer->current.pos;
                    newPos3.y = pos.y;

                    f32 dist = pos.abs(newPos3);
                    f32 innerRadius = 200.0f;
                    f32 outerRadius = 2000.0f;
                    f32 range = outerRadius - innerRadius;
                    if (dist < outerRadius) {
                        if (innerRadius < dist) {
                            pPkt->mEff[i].mStrengthEnv = 0.0f;
                        } else {
                            f32 fade = (dist - innerRadius) / range;
                            pPkt->mEff[i].mStrengthEnv *= fade;
                        }
                    }
                }
            }
            break;
        case 3:
            {
                pPkt->mEff[i].mStatus = 0;
            }
            break;
        default:
            break;
        }

        {
            newPos2.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
            newPos2.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
            newPos2.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;
            f32 dist = newPos2.abs(pCamera->mLookat.mEye);
            if (dist < 0.0f)
                dist = 0.0f;
            f32 alphaTarget = 1.0f - (dist / (2.0f * g_env_light.mWaveChan.mWaveSpawnDist));
            alphaTarget *= 1.03f;
            alphaTarget *= (f32)sin(pPkt->mEff[i].mCounter);
            if (alphaTarget > 1.0f)
                alphaTarget = 1.0f;
            if (alphaTarget < 0.0f)
                alphaTarget = 0.0f;
            cLib_addCalc(&pPkt->mEff[i].mAlpha, alphaTarget, 0.5f, 0.5f, 0.001f);
            pPkt->mEff[i].mBasePos.y = seaLevel;
        }
    }
}

/* 80091964-80092294       .text cloud_shadow_move__Fv */
void cloud_shadow_move() {
    /* Nonmatching */
    dKankyo_cloud_Packet* pPkt = dKy_getEnvlight().mpMoyaPacket;
    camera_class* pCamera = (camera_class*)dComIfGp_getCamera(0);
    Mtx camMtx;
    cXyz windVecPow = dKyw_get_wind_vecpow();
    cXyz center;
    cXyz pos;
    cXyz pntwind;
    cXyz velRndm;

    if (dComIfGd_getView() != NULL) {
        MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
    } else {
        return;
    }

    if (pPkt->mCount <= dKy_getEnvlight().mMoyaCount)
        pPkt->mCount = dKy_getEnvlight().mMoyaCount;

    if (pPkt->mCount == 0)
        return;

    dKy_set_eyevect_calc2(pCamera, &center, 1500.0f, 1500.0f);

    for (s32 i = 0; i < pPkt->mCount; i++) {
        switch (pPkt->mEff[i].mStatus) {
        case 0:
            pPkt->mEff[i].mInitialSize = 400.0f + cM_rndFX(80.0f);
            pPkt->mEff[i].mSize = pPkt->mEff[i].mInitialSize;
            pPkt->mEff[i].mBasePos.set(center);
            pPkt->mEff[i].mPos.x = cM_rndFX(2000.0f);
            pPkt->mEff[i].mPos.y = cM_rndFX(2000.0f);
            pPkt->mEff[i].mPos.z = cM_rndFX(2000.0f);
            pPkt->mEff[i].mWindSpeed = 0.7f + cM_rndF(0.3f);
            pPkt->mEff[i].mAlpha = 0.0;
            pPkt->mEff[i].mAnimCounter = cM_rndF(65535.0f);
            pPkt->mEff[i].mVelRndm.x = cM_rndFX(360.0f);
            pPkt->mEff[i].mVelRndm.y = cM_rndFX(360.0f);
            pPkt->mEff[i].mVelRndm.z = cM_rndFX(360.0f);
            pPkt->mEff[i].mPntWindVel.x = 0.0f;
            pPkt->mEff[i].mPntWindVel.y = 0.0f;
            pPkt->mEff[i].mPntWindVel.z = 0.0f;
            pPkt->mEff[i].mStatus++;
            break;
        case 1:
        case 2:
            {
                pos.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
                pos.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
                pos.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;
                pPkt->mEff[i].mAnimCounter += 120;
                cLib_chaseF(&pPkt->mEff[i].field_0x34, pPkt->mEff[i].mWindSpeed, 7.0f);
                if (dKy_getEnvlight().mMoyaMode & 1) {
                    if (strcmp(dComIfGp_getStartStageName(), "M_DragB") != 0 || dKy_getEnvlight().mbVrboxInvisible) {
                        if (dKy_getEnvlight().mMoyaMode == 1) {
                            pPkt->mEff[i].mPos.y += 20.0f;
                        }
                    } else {
                        pPkt->mEff[i].mPos.y += 5.0f;
                    }
                }

                f32 speed;
                if (dKy_getEnvlight().mMoyaMode == 1) {
                    speed = 10.0f;
                } else {
                    speed = 40.0f;
                }

                pPkt->mEff[i].mPos.x += windVecPow.x * speed * pPkt->mEff[i].mWindSpeed;
                pPkt->mEff[i].mPos.y += windVecPow.y * speed * pPkt->mEff[i].mWindSpeed;
                pPkt->mEff[i].mPos.z += windVecPow.z * speed * pPkt->mEff[i].mWindSpeed;
                pntwind = dKyw_pntwind_get_vecpow(&pos);
                if (pPkt->mEff[i].mPntWindVel.x < 30.0f)
                    pPkt->mEff[i].mPntWindVel.x += pntwind.x * 9.0f;
                if (pPkt->mEff[i].mPntWindVel.y < 30.0f)
                    pPkt->mEff[i].mPntWindVel.y += pntwind.y * 9.0f;
                if (pPkt->mEff[i].mPntWindVel.z < 30.0f)
                    pPkt->mEff[i].mPntWindVel.z += pntwind.z * 9.0f;

                cLib_addCalc(&pPkt->mEff[i].mPntWindVel.x, 0.0f, 0.2f, 0.1f, 0.00001f);
                cLib_addCalc(&pPkt->mEff[i].mPntWindVel.y, 0.0f, 0.2f, 0.1f, 0.00001f);
                cLib_addCalc(&pPkt->mEff[i].mPntWindVel.z, 0.0f, 0.2f, 0.1f, 0.00001f);

                pPkt->mEff[i].mPos.x += pPkt->mEff[i].mPntWindVel.x;
                pPkt->mEff[i].mPos.y += pPkt->mEff[i].mPntWindVel.y;
                pPkt->mEff[i].mPos.z += pPkt->mEff[i].mPntWindVel.z;

                // botched comparison?
                if (strcmp(dComIfGp_getStartStageName(), "kaze") == 0) {
                    
                }

                if (strcmp(dComIfGp_getStartStageName(), "Adanmae") == 0) {
                    speed = 20.0f;
                } else {
                    speed = 8.0f;
                }

                velRndm.x = (pPkt->mEff[i].mVelRndm.x / 360.0f - 0.5f) * speed;
                velRndm.y = (pPkt->mEff[i].mVelRndm.y / 360.0f - 0.5f) * speed;
                velRndm.z = (pPkt->mEff[i].mVelRndm.z / 360.0f - 0.5f) * speed;

                pPkt->mEff[i].mPos.x += velRndm.x;
                pPkt->mEff[i].mPos.y += velRndm.y;
                pPkt->mEff[i].mPos.z += velRndm.z;

                pos.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
                pos.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
                pos.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;

                if (pos.abs(center) > 2000.0f) {
                    pPkt->mEff[i].mBasePos.set(center);

                    if (pos.abs(center) > 2200.0f) {
                        pPkt->mEff[i].mPos.x = cM_rndFX(2000.0f);
                        pPkt->mEff[i].mPos.y = cM_rndFX(2000.0f);
                        pPkt->mEff[i].mPos.z = cM_rndFX(2000.0f);
                    } else {
                        cLib_addCalc(&pPkt->mEff[i].mAlpha, 0.0f, 0.1f, 0.01f, 0.001f);
                        if (pPkt->mEff[i].mAlpha < 0.001f) {
                            get_vectle_calc(&pos, &center, &pntwind);
                            pntwind.x += cM_rndF(0.5f);
                            pntwind.y += cM_rndF(0.5f);
                            pntwind.z += cM_rndF(0.5f);
                            pPkt->mEff[i].mPos.x = pntwind.x * 2000.0f;
                            pPkt->mEff[i].mPos.y = pntwind.y * 2000.0f;
                            pPkt->mEff[i].mPos.z = pntwind.z * 2000.0f;
                        }
                    }

                    pPkt->mEff[i].mAlpha = 0.0f;
                }
            }
            break;
        case 3:
            pPkt->mEff[i].mStatus = 0;
            break;
        }

        pos.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
        pos.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
        pos.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;

        pPkt->mEff[i].mSize = pPkt->mEff[i].mInitialSize + ((pos.abs(pCamera->mLookat.mEye) - 1000.0f) / 2000.0f) * 1.5f * pPkt->mEff[i].mInitialSize + (40.0f * cM_ssin(pPkt->mEff[i].mAnimCounter));

        f32 distCenter = pos.abs(center);
        if (distCenter < 0.0f)
            distCenter = 0.0f;

        f32 alphaTarget = 1.0f - distCenter / 1000.0f;
        f32 maxAlpha = 0.035f;
        if (dKy_getEnvlight().mMoyaMode == 3) {
            maxAlpha = 0.06f;
        } else if (dKy_getEnvlight().mMoyaMode == 4) {
            maxAlpha = 0.05f;
        }
        maxAlpha *= 1.2f;

        if (i > dKy_getEnvlight().mMoyaCount - 1) {
            alphaTarget = 0.0f;
            if (pPkt->mEff[i].mAlpha < 0.001f && i == pPkt->mCount - 1) {
                pPkt->mCount--;
            }
        }

        cLib_addCalc(&pPkt->mEff[i].mAlpha, alphaTarget * maxAlpha, 0.1f, 0.1f, 0.000000001f);
    }
}

/* 80092294-80092310       .text light_at_hit_check__FP4cXyz */
BOOL light_at_hit_check(cXyz* pPos) {
    dCcMassS_HitInf hitInfo;
    BOOL ret = FALSE;
    fopAc_ac_c * pActor;
    u32 res = dComIfG_Ccsp()->ChkMass(pPos, &pActor, &hitInfo);
    if (((res & 1) != 0) && (hitInfo.GetAtHitObj()->ChkAtType(AT_TYPE_LIGHT)))
        ret = TRUE;
    return ret;
}

/* 80092310-80092330       .text dKyr_poison_live_check__Fv */
BOOL dKyr_poison_live_check() {
    BOOL ret = FALSE;
    if (g_env_light.mPoisonCount != 0)
        ret = TRUE;
    return ret;
}

/* 80092330-80092448       .text dKyr_poison_light_colision__Fv */
void dKyr_poison_light_colision() {
    dKankyo_poison_Packet * pPkt = g_env_light.mpPoisonPacket;
    if (!dKyr_poison_live_check())
        return;

    dComIfG_Ccsp()->SetMassAttr(220.0f, 140.0f, 0x0B, 0x03);

    f32 halfHeight = 70.0f;
    for (s32 i = 0; i < g_env_light.mPoisonCount; i++) {
        cXyz pos = pPkt->mBasePos + pPkt->mEff[i].mPos;
        pos.y -= halfHeight;
        if (light_at_hit_check(&pos) && pPkt->mEff[i].mStatus == 1) {
            pPkt->mEff[i].mStatus = 2;
            pPkt->mEff[i].field_0x2e = 60;
        }
    }
}

/* 80092448-8009258C       .text poison_init__Fv */
void poison_init() {
    g_env_light.mpPoisonPacket = new(0x20) dKankyo_poison_Packet();
    g_env_light.mpPoisonPacket->field_0xbb9c.x = 0.0f;
    g_env_light.mpPoisonPacket->field_0xbb9c.y = 0.0f;
    g_env_light.mpPoisonPacket->field_0xbb9c.z = 0.0f;
    g_env_light.mpPoisonPacket->mCount = 0;
    if (g_env_light.mpPoisonPacket != NULL) {
        g_env_light.mpPoisonPacket->mpTexture = (u8*)dComIfG_getObjectRes("Always", ALWAYS_BTI_AK_SMOKE01);
        for (u32 i = 0; i < ARRAY_SIZE(g_env_light.mpPoisonPacket->mEff); i++)
            g_env_light.mpPoisonPacket->mEff[i].mStatus = 0;
        poison_move();
        now_room = dComIfGp_roomControl_getStayNo();
    }
}

/* 8009258C-800937BC       .text poison_move__Fv */
void poison_move() {
    /* Nonmatching */
}

/* 800937BC-800940D4       .text vrkumo_move__Fv */
void vrkumo_move() {
    /* Nonmatching */
}

/* 800940D4-80094144       .text dKy_wave_chan_init__Fv */
void dKy_wave_chan_init() {
    g_env_light.mWaveChan.mWaveCount = 0;
    g_env_light.mWaveChan.field_0x0 = -1.0f;
    g_env_light.mWaveChan.field_0x4 = 0.0f;
    g_env_light.mWaveChan.field_0x8 = 0.0f;
    g_env_light.mWaveChan.mWaveSpeed = 0.3f;
    g_env_light.mWaveChan.mWaveSpawnDist = 3000.0f;
    g_env_light.mWaveChan.mWaveSpawnRadius = 3150.0f;
    g_env_light.mWaveChan.mWaveReset = 0;
    g_env_light.mWaveChan.mWaveScale = 250.0f;
    g_env_light.mWaveChan.mWaveScaleBottom = 5.0f;
    g_env_light.mWaveChan.mWaveScaleRand = 0.217f;
    g_env_light.mWaveChan.mWaveCounterSpeedScale = 1.6f;
    g_env_light.mWaveChan.field_0x2f = 0;
    g_env_light.mWaveChan.mWaveSpeed = 0.1f;
}

/* 80094144-8009428C       .text snap_sunmoon_proc__FP4cXyzi */
void snap_sunmoon_proc(cXyz* pPos, int type) {
    dSnap_Obj snapObj;
    camera_class * pCamera = dComIfGp_getCamera(0);

    if (dComIfGp_checkPlayerStatus1(0, daPyStts1_PICTO_BOX_AIM_e)) {
        cXyz pos;
        pos.x = (pPos->x - pCamera->mLookat.mEye.x);
        pos.y = (pPos->y - pCamera->mLookat.mEye.y);
        pos.z = (pPos->z - pCamera->mLookat.mEye.z);
        pos.x *= 10.0f;
        pos.y *= 10.0f;
        pos.z *= 10.0f;
        pos.x += pCamera->mLookat.mEye.x;
        pos.y += pCamera->mLookat.mEye.y;
        pos.z += pCamera->mLookat.mEye.z;

        snapObj.SetGeoSph(pos, 8000.0f);
        if (type == 9)
            snapObj.SetInf(9, NULL, 0xFF, 4, 0x7FFF);
        else if (type == 0)
            snapObj.SetInf(7, NULL, 0xFF, 4, 0x7FFF);
        else
            snapObj.SetInf(8, NULL, 0xFF, 4, 0x7FFF);
        dSnap_RegistSnapObj(snapObj);
    }
}

/* 8009428C-8009514C       .text dKyr_drawSun__FPA4_fP4cXyzR8GXColorPPUc */
void dKyr_drawSun(Mtx drawMtx, cXyz* pPos, GXColor& reg0, u8** pImg) {
    /* Nonmatching */
    dKankyo_sun_Packet* pSunPkt;
    dKankyo_sunlenz_Packet* pSunlenzPkt;
    camera_class* pCamera;
    cXyz pos[4];
    cXyz sunPos;
    cXyz moonPos2;
    cXyz moonPos;
    cXyz vp;
    cXyz lp;
    bool bDrawSun;
    bool bDrawMoon;
    Mtx camMtx;
    Mtx rotMtx;
    GXColor reg1;
    GXTexObj texObj;

    pSunPkt = dKy_getEnvlight().mpSunPacket;
    pSunlenzPkt = dKy_getEnvlight().mpSunlenzPacket;
    pCamera = dComIfGp_getCamera(0);

    bDrawMoon = false;
    bDrawSun = false;
    if (pSunPkt->mSunAlpha > 0.0f)
        bDrawSun = true;
    if (pSunPkt->mMoonAlpha > 0.0f)
        bDrawMoon = true;

    if (bDrawSun | bDrawMoon) {
        sunPos = *pPos;

        u32 stType = dStage_stagInfo_GetSTType(dComIfGp_getStageStagInfo());
        if (dKy_getEnvlight().mBaseLightInfluence.mColor.r == 0 && stType != dStageType_MISC_e) {
            if (dKy_getEnvlight().mCurTime > 285.0f || dKy_getEnvlight().mCurTime < 105.0f)
                bDrawMoon = false;

            moonPos2 = *pPos;
        } else {
            moonPos.x = -(pPos->x - pCamera->mLookat.mEye.x);
            moonPos.y = -(pPos->y - pCamera->mLookat.mEye.y);
            moonPos.z = -(pPos->z - pCamera->mLookat.mEye.z);

            moonPos2.x = moonPos.x + pCamera->mLookat.mEye.x;
            moonPos2.y = moonPos.y + pCamera->mLookat.mEye.y;
            moonPos2.z = moonPos.z + pCamera->mLookat.mEye.z;
        }

        int dayofweek = dKy_get_dayofweek();
        if (dComIfGs_getTime() < 180.0f) {
            if (dayofweek != 0)
                dayofweek--;
            else
                dayofweek = 6;
        }

        s32 texidx;
        f32 flipX;
        switch (dayofweek) {
        case 0: texidx = 0; flipX = 1.0f; break;
        case 1: texidx = 1; flipX = 1.0f; break;
        case 2: texidx = 2; flipX = 1.0f; break;
        case 3: texidx = 3; flipX = 1.0f; break;
        case 4: texidx = 3; flipX = -1.0f; break;
        case 5: texidx = 2; flipX = -1.0f; break;
        case 6: texidx = 1; flipX = -1.0f; break;
        }

        reg0.r = dKy_getEnvlight().mFogColor.r;
        reg0.g = dKy_getEnvlight().mFogColor.g;
        reg0.b = dKy_getEnvlight().mFogColor.b;
        reg0.a = 0xFF;

        reg1.r = 0x00;
        reg1.g = 0x00;
        reg1.b = 0x00;
        reg1.a = 0xFF;

        if (dComIfGd_getView() != NULL) {
            MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
        } else {
            if (pSunPkt->field_0x3c < 5)
                pSunPkt->field_0x3c += 2;
            pSunPkt->field_0x3d = true;
            return;
        }

        dKyr_set_btitex(&texObj, (ResTIMG*)pImg[texidx]);

        GXSetNumChans(0);
        GXSetTevColor(GX_TEVREG0, reg0);
        GXSetTevColor(GX_TEVREG1, reg1);
        GXSetNumTexGens(1);
        GXSetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
        GXSetNumTevStages(1);
        GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
        GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
        GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
        GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
        GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
        GXSetZMode(GX_TRUE, GX_LEQUAL, GX_FALSE);
        GXSetNumIndStages(0);
        GXSetCullMode(GX_CULL_NONE);

        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
        GXClearVtxDesc();
        GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
        GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);

        if (bDrawMoon == true) {
            cXyz camfwd;
            f32 dayscale[7] = { 1.0f, 0.83f, 0.6f, 0.6f, 0.6f, 0.6f, 0.83f, };

            snap_sunmoon_proc(&moonPos2, texidx);
            dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &camfwd);

            f32 cam_distXZ = std::sqrtf(camfwd.x*camfwd.x + camfwd.z*camfwd.z);
            f32 cam_theta = std::atan2f(camfwd.x, camfwd.z);
            f32 cam_phi = std::atan2f(camfwd.y, cam_distXZ);

            f32 moon_distXZ = std::sqrtf(moonPos.x*moonPos.x + moonPos.z*moonPos.z);
            f32 moon_theta = std::atan2f(moonPos.x, moonPos.z);
            f32 moon_phi = std::atan2f(moonPos.y, moon_distXZ);

            f32 angle = 45.0f + (((moon_theta - cam_theta) / -8.0f) * moon_phi) * 360.0f;
            MTXRotDeg(rotMtx, 'Z', angle);
            MTXConcat(camMtx, rotMtx, camMtx);
            GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
            GXSetCurrentMtx(GX_PNMTX0);

            reg0.r = 0xF3;
            reg0.g = 0xFF;
            reg0.b = 0x94;

            f32 size = 700.0f;
            reg0.a = pSunPkt->mMoonAlpha * 255.0f;
            GXSetTevColor(GX_TEVREG0, reg0);

            for (s32 j = 0; j < 2; j++) {
                if (j == 1) {
                    GXInitTexObj(&texObj, pSunlenzPkt->mpTexSnow01, 64, 64, GX_TF_I8, GX_CLAMP, GX_CLAMP, GX_FALSE);
                    GXInitTexObjLOD(&texObj, GX_LINEAR, GX_LINEAR, 0.0f, 0.0f, 0.0f, GX_FALSE, GX_FALSE, GX_ANISO_1);
                    GXLoadTexObj(&texObj, GX_TEXMAP0);
                    size *= 1.7f;
                    reg0.a = pSunPkt->mMoonAlpha * 76.0f;
                    reg0.r = 0xFF;
                    reg0.g = 0xFF;
                    reg0.b = 0xCF;
                    reg1.r = 0xC5;
                    reg1.g = 0x69;
                    reg1.b = 0x23;
                    MTXRotDeg(rotMtx, 'Z', 50.0f * flipX);
                    MTXConcat(camMtx, rotMtx, camMtx);
                    GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
                    GXSetCurrentMtx(GX_PNMTX0);
                }

                GXSetTevColor(GX_TEVREG0, reg0);
                GXSetTevColor(GX_TEVREG1, reg1);

                vp.x = -size * flipX;
                vp.y = size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[0].x = moonPos2.x + lp.x;
                pos[0].y = moonPos2.y + lp.y;
                pos[0].z = moonPos2.z + lp.z;

                vp.x = size * flipX;
                vp.y = size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[1].x = moonPos2.x + lp.x;
                pos[1].y = moonPos2.y + lp.y;
                pos[1].z = moonPos2.z + lp.z;

                if (texidx == 0) {
                    vp.x = size * flipX;
                    vp.y = -size;
                } else {
                    vp.x = size * flipX * dayscale[dayofweek];
                    vp.y = -size * dayscale[dayofweek];
                }
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[2].x = moonPos2.x + lp.x;
                pos[2].y = moonPos2.y + lp.y;
                pos[2].z = moonPos2.z + lp.z;

                vp.x = -size * flipX;
                vp.y = -size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[3].x = moonPos2.x + lp.x;
                pos[3].y = moonPos2.y + lp.y;
                pos[3].z = moonPos2.z + lp.z;

                GXBegin(GX_QUADS, GX_VTXFMT0, 4);
                GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
                GXTexCoord2s16(0, 0);
                GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
                GXTexCoord2s16(0xFF, 0);
                GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
                GXTexCoord2s16(0xFF, 0xFF);
                GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
                GXTexCoord2s16(0, 0xFF);
                GXEnd();
            }
        }

        if (bDrawSun == true) {
            cXyz camfwd;
            snap_sunmoon_proc(&sunPos, 9);

            f32 sun_distXZ = std::sqrtf(sunPos.x*sunPos.x + sunPos.z*sunPos.z);
            f32 sun_theta = std::atan2f(sunPos.x, sunPos.z);
            f32 sun_phi = std::atan2f(sunPos.y, sun_distXZ);

            dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &camfwd);

            f32 cam_distXZ = std::sqrtf(camfwd.x*camfwd.x + camfwd.z*camfwd.z);
            f32 cam_theta = std::atan2f(camfwd.x, camfwd.z);
            f32 cam_phi = std::atan2f(camfwd.y, cam_distXZ);

            MTXRotDeg(rotMtx, 'Z', -50.0f + (360.0f * ((sun_theta - cam_theta) / -8.0f)));
            MTXConcat(camMtx, rotMtx, camMtx);
            GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
            GXSetCurrentMtx(GX_PNMTX0);

            reg0.r = 0xFF;
            reg0.g = 0xFF;
            reg0.b = 0xF1;

            reg1.r = 0xF1;
            reg1.g = 0x91;
            reg1.b = 0x49;

            f32 dist = 1.0f - pSunlenzPkt->mDistFalloff;
            f32 size = 575.0f;
            if (pSunPkt->mVisibility > 0.0f)
                size += 500.0f * (dist * dist) * pSunPkt->mVisibility;

            for (s32 j = 0; j < 2; j++) {
                if (j == 0) {
                    dKyr_set_btitex(&texObj, (ResTIMG*)pImg[4]);
                    reg0.a = pSunPkt->mSunAlpha * 255.0f;
                } else {
                    GXInitTexObj(&texObj, pSunlenzPkt->mpTexSnow01, 64, 64, GX_TF_I8, GX_CLAMP, GX_CLAMP, GX_FALSE);
                    GXInitTexObjLOD(&texObj, GX_LINEAR, GX_LINEAR, 0.0f, 0.0f, 0.0f, GX_FALSE, GX_FALSE, GX_ANISO_1);
                    GXLoadTexObj(&texObj, GX_TEXMAP0);
                    size *= 1.6f;
                    reg0.a = pSunPkt->mSunAlpha * 76.0f;
                }

                GXSetTevColor(GX_TEVREG0, reg0);
                GXSetTevColor(GX_TEVREG1, reg1);

                vp.x = -size * flipX;
                vp.y = size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[0].x = sunPos.x + lp.x;
                pos[0].y = sunPos.y + lp.y;
                pos[0].z = sunPos.z + lp.z;

                vp.x = size * flipX;
                vp.y = size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[1].x = sunPos.x + lp.x;
                pos[1].y = sunPos.y + lp.y;
                pos[1].z = sunPos.z + lp.z;

                vp.x = size * flipX;
                vp.y = -size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[2].x = sunPos.x + lp.x;
                pos[2].y = sunPos.y + lp.y;
                pos[2].z = sunPos.z + lp.z;

                vp.x = -size * flipX;
                vp.y = -size;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[3].x = sunPos.x + lp.x;
                pos[3].y = sunPos.y + lp.y;
                pos[3].z = sunPos.z + lp.z;

                GXBegin(GX_QUADS, GX_VTXFMT0, 4);
                GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
                GXTexCoord2s16(0, 0);
                GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
                GXTexCoord2s16(0xFF, 0);
                GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
                GXTexCoord2s16(0xFF, 0xFF);
                GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
                GXTexCoord2s16(0, 0xFF);
                GXEnd();
            }
        }
#if VERSION > VERSION_JPN
        J3DShape::resetVcdVatCache();
#endif
    }
}

/* 8009514C-80095E8C       .text dKyr_drawLenzflare__FPA4_fP4cXyzR8GXColorPPUc */
void dKyr_drawLenzflare(Mtx drawMtx, cXyz* pPos, GXColor& color, u8** pImg) {
    /* Nonmatching */
    dKankyo_sunlenz_Packet* lenz_packet = g_env_light.mpSunlenzPacket;
    dKankyo_sun_Packet* sun_packet = g_env_light.mpSunPacket;
    camera_class* camera = (camera_class*)dComIfGp_getCamera(0);

    Mtx camMtx;
    Mtx rotMtx;

    cXyz pos[4];
    cXyz spFC;
    cXyz spF0;

    Vec spE4, spD8;

    s16 spC = 0;
    s16 spA = 0;

    f32 sun_visibility = sun_packet->mVisibility;
    f32 spAC = 1.0f - lenz_packet->mDistFalloff;
    f32 spA8 = sun_packet->mVisibility * sun_packet->mVisibility;

    if (!(sun_visibility < 0.1f)) {
        dKy_set_eyevect_calc2(camera, &spFC, 8000.0f, 8000.0f);

        GXColor color_reg0;
        color_reg0.r = sun_packet->mColor.r;
        color_reg0.g = sun_packet->mColor.g;
        color_reg0.b = sun_packet->mColor.b;

        GXColor color_reg1;
        color_reg1.r = sun_packet->mColor.r;
        color_reg1.g = sun_packet->mColor.g;
        color_reg1.b = sun_packet->mColor.b;

        if (dComIfGd_getView() != NULL) {
            MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
        } else {
            return;
        }

        GXTexObj texobj;
        GXInitTexObj(&texobj, pImg[0], 64, 64, GX_TF_I8, GX_CLAMP, GX_CLAMP, GX_FALSE);
        GXInitTexObjLOD(&texobj, GX_LINEAR, GX_LINEAR, 0.0f, 0.0f, 0.0f, GX_FALSE, GX_FALSE, GX_ANISO_1);
        GXLoadTexObj(&texobj, GX_TEXMAP0);
        GXSetNumChans(0);
        GXSetTevColor(GX_TEVREG0, color_reg0);
        GXSetTevColor(GX_TEVREG1, color_reg1);
        GXSetNumTexGens(1);
        GXSetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
        GXSetNumTevStages(1);
        GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
        GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
        GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
        GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
        GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
        GXSetZCompLoc(GX_TRUE);
        GXSetZMode(GX_DISABLE, GX_LEQUAL, GX_DISABLE);
        GXSetNumIndStages(0);
        GXSetCullMode(GX_CULL_NONE);
        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
        GXClearVtxDesc();
        GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
        GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);

        MTXRotRad(rotMtx, 'Z', 0.0f);
        MTXConcat(camMtx, rotMtx, camMtx);
        GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
        GXSetCurrentMtx(GX_PNMTX0);

        static const f32 scale_dat[] = {
            8000.0f, 10000.0f, 1600.0f, 4800.0f, 1200.0f, 5600.0f, 2400.0f, 7200.0f,
        };

        static const GXColor col_dat[] = {
            {0xFF, 0xFF, 0xFF, 0xFF},
            {0xFF, 0xFF, 0xFF, 0x50},
            {0xFF, 0xFF, 0xFF, 0x5A},
            {0xFF, 0xFF, 0xFF, 0x64},
            {0xFF, 0xFF, 0xFF, 0x55},
            {0xFF, 0xFF, 0xFF, 0x5A},
            {0xFF, 0xFF, 0xFF, 0x6E},
            {0xFF, 0xFF, 0xFF, 0x5A},
        };

        for (int i = 0; i < 8; i++) {
            if (!g_env_light.mpSunlenzPacket->mbDrawLenzInSky || i == 0) {
                f32 spC4 = spA8;
                if (i < 2) {
                    color_reg0.a = spC4 * col_dat[i].a;
                } else {
                    color_reg0.a = spC4 * col_dat[i].a * (0.8f * lenz_packet->mDistFalloff);
                }

                GXSetTevColor(GX_TEVREG0, color_reg0);

                f32 var_f31;
                if (i < 2) {
                    var_f31 = (0.04f + (0.075f * sun_visibility)) * scale_dat[i] + ((0.2f * sun_visibility * scale_dat[i]) * (1.0f - (lenz_packet->mDistFalloff * lenz_packet->mDistFalloff)));
                } else {
                    var_f31 = 0.8f * (sun_visibility * scale_dat[i]) * (1.0f - (lenz_packet->mDistFalloff * lenz_packet->mDistFalloff * lenz_packet->mDistFalloff));
                }

                if (i == 1) {
                    dKyr_init_btitex(&texobj, (ResTIMG*)pImg[2]);
                    GXLoadTexObj(&texobj, GX_TEXMAP0);
                } else if (i == 2) {
                    dKyr_init_btitex(&texobj, (ResTIMG*)pImg[1]);
                    GXLoadTexObj(&texobj, GX_TEXMAP0);
                }

                spE4.x = -var_f31;
                spE4.y = var_f31;
                spE4.z = 0.0f;
                cMtx_multVec(camMtx, &spE4, &spD8);
                pos[0].x = spD8.x + pPos[i].x;
                pos[0].y = spD8.y + pPos[i].y;
                pos[0].z = spD8.z + pPos[i].z;

                spE4.x = var_f31;
                spE4.y = var_f31;
                spE4.z = 0.0f;
                cMtx_multVec(camMtx, &spE4, &spD8);
                pos[1].x = spD8.x + pPos[i].x;
                pos[1].y = spD8.y + pPos[i].y;
                pos[1].z = spD8.z + pPos[i].z;

                spE4.x = var_f31;
                spE4.y = -var_f31;
                spE4.z = 0.0f;
                cMtx_multVec(camMtx, &spE4, &spD8);
                pos[2].x = spD8.x + pPos[i].x;
                pos[2].y = spD8.y + pPos[i].y;
                pos[2].z = spD8.z + pPos[i].z;

                spE4.x = -var_f31;
                spE4.y = -var_f31;
                spE4.z = 0.0f;
                cMtx_multVec(camMtx, &spE4, &spD8);
                pos[3].x = spD8.x + pPos[i].x;
                pos[3].y = spD8.y + pPos[i].y;
                pos[3].z = spD8.z + pPos[i].z;

                s16 sp8;
                if (i == 0) {
                    sp8 = 0xFF;
                } else {
                    sp8 = 0x1FF;
                }

                GXBegin(GX_QUADS, GX_VTXFMT0, 4);
                GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
                GXTexCoord2s16(0, 0);
                GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
                GXTexCoord2s16(sp8, 0);
                GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
                GXTexCoord2s16(sp8, sp8);
                GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
                GXTexCoord2s16(0, sp8);
                GXEnd();
            }
        }

        spC = -0x07F6;
        spA = 0x416B;

        if (dComIfGd_getView() != NULL) {
            MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
        }

        {
            MTXRotRad(rotMtx, 'Z', 0.0f);
            MTXConcat(camMtx, rotMtx, camMtx);
            GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
            GXSetCurrentMtx(GX_PNMTX0);

            GXSetNumChans(1);
            GXSetChanCtrl(GX_COLOR0, GX_DISABLE, GX_SRC_REG, GX_SRC_REG, GX_LIGHT_NULL, GX_DF_CLAMP, GX_AF_NONE);
            GXSetNumTexGens(0);
            GXSetNumTevStages(1);

            color_reg0.a = sun_packet->mVisibility * (15.0f * (spA8 * spA8 * spA8));
            GXSetTevColor(GX_TEVREG0, color_reg0);
            GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD_NULL, GX_TEXMAP_NULL, GX_COLOR0A0);
            GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_C0);
            GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
            GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_A0);
            GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
            GXSetClipMode(GX_CLIP_ENABLE);
            GXSetNumIndStages(0);
            GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_CLR_RGBA, GX_F32, 0);
            GXClearVtxDesc();
            GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
            GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
            GXSetCurrentMtx(GX_PNMTX0);

            for (int i = 0; i < 16; i++) {
                f32 spA0;
                f32 sp9C;
                f32 sp98;
                f32 sp94;
                f32 sp90;
                f32 sp8C;
                f32 sp88;
                f32 sp84;
                f32 sp80;
                f32 sp7C;
                f32 sp78;
                f32 sp74;
                f32 sp70;
                f32 sp6C;
                f32 sp68;
                f32 sp64;

                if (i & 1) {
                    sp78 = spC;
                } else {
                    sp78 = spA;
                }

                sp6C = 0.4f + (0.6f * (sun_visibility * (spAC * spAC)));
                sp64 = 300.0f;
                sp68 = cM_ssin(34.0f * sp78);
                if (sp68 < 0.0f) {
                    sp68 = -sp68;
                }

                sp74 = 1000.0f * (0.5f + sp68);

                spA0 = sp64 * sp6C * cM_ssin(sp78 + sp74);
                sp9C = sp64 * sp6C * cM_scos(sp78 + sp74);
                sp90 = sp64 * sp6C * cM_ssin(sp78 - sp74);
                sp8C = sp64 * sp6C * cM_scos(sp78 - sp74);

                sp70 = (0.6f + (0.4f * sp68)) * (300.0f * sp6C * (3.0f + spAC));
                sp70 *= 1.5f * sun_visibility;

                if ((i & 3)) {
                    sp70 *= 0.2f;
                }

                sp98 = sp70 * cM_ssin(sp78);
                sp94 = sp70 * cM_scos(sp78);
                spC += 0x1000;
                spA += 0x1C71;

                spE4.x = sp98;
                spE4.y = sp94;
                spE4.z = 0.0f;
                cMtx_multVec(camMtx, &spE4, &spD8);
                spF0.x = pPos[0].x + spD8.x;
                spF0.y = pPos[0].y + spD8.y;
                spF0.z = pPos[0].z + spD8.z;

                sp7C = spFC.abs(spF0);
                if (sp7C < lenz_packet->field_0x88) {
                    lenz_packet->field_0x88 = sp7C;
                } else if (sp7C > lenz_packet->field_0x8c) {
                    lenz_packet->field_0x8c = sp7C;
                }

                sp88 = lenz_packet->field_0x88 - lenz_packet->field_0x84;
                if (sp88 > 0.0f) {
                    sp84 = 1.0f - ((sp7C - lenz_packet->field_0x84) / sp88);
                } else {
                    sp84 = 1.0f;
                }

                switch (i & 3) {
                case 0:
                    sp80 = 0.1f;
                    break;
                case 1:
                    sp80 = 1.1f;
                    break;
                case 2:
                    sp80 = 0.2f;
                    break;
                case 3:
                    sp80 = 0.4f;
                    break;
                }

                f32 spC4 = spA8;
                sp98 *= sun_visibility * (spC4 + sp80);
                sp94 *= sun_visibility * (spC4 + sp80);

                spE4.x = spA0;
                spE4.y = sp9C;
                spE4.z = 0.0f;
                cMtx_multVec(camMtx, &spE4, &spD8);
                pos[0].x = sun_packet->mPos[0].x + spD8.x;
                pos[0].y = sun_packet->mPos[0].y + spD8.y;
                pos[0].z = sun_packet->mPos[0].z + spD8.z;

                spE4.x = sp98;
                spE4.y = sp94;
                spE4.z = 0.0f;
                cMtx_multVec(camMtx, &spE4, &spD8);
                pos[1].x = sun_packet->mPos[0].x + spD8.x;
                pos[1].y = sun_packet->mPos[0].y + spD8.y;
                pos[1].z = sun_packet->mPos[0].z + spD8.z;

                spE4.x = sp90;
                spE4.y = sp8C;
                spE4.z = 0.0f;
                cMtx_multVec(camMtx, &spE4, &spD8);
                pos[2].x = sun_packet->mPos[0].x + spD8.x;
                pos[2].y = sun_packet->mPos[0].y + spD8.y;
                pos[2].z = sun_packet->mPos[0].z + spD8.z;

                GXBegin(GX_TRIANGLES, GX_VTXFMT0, 3);
                GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
                GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
                GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
                GXEnd();
            }
        }

        J3DShape::resetVcdVatCache();
    }
}

/* 80095E8C-8009682C       .text dKyr_drawRain__FPA4_fPPUc */
void dKyr_drawRain(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
    dKankyo_rain_Packet* pPkt = g_env_light.mpRainPacket;
    camera_class* pCamera = dComIfGp_getCamera(0);

    Mtx camMtx;
    cXyz pos[4];
    cXyz windvec;
    cXyz vp;
    cXyz lp;
    cXyz p;
    cXyz dummy;
    cXyz tilt;
    Mtx rotMtx;
    GXColor reg0, reg1;

    windvec = dKyw_get_wind_vecpow();

    static u32 rot = 0;

    if (g_env_light.mSnowCount == 0) {
        dummy.set(0.0f, -2.0f, 0.0f);

        if (pPkt->mRainCount != 0) {
            reg0.r = 0xFF;
            reg0.g = 0xFF;
            reg0.b = 0xFF;

            reg1.r = 0x80;
            reg1.g = 0x80;
            reg1.b = 0x80;

            reg0.a = 0x0A;
            reg1.a = 0x0A;

            if (dComIfGd_getView() != NULL) {
                MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
            } else {
                return;
            }

            GXTexObj texObj;
            GXInitTexObj(&texObj, pImg[0], 64, 64, GX_TF_I8, GX_CLAMP, GX_CLAMP, GX_FALSE);
            GXInitTexObjLOD(&texObj, GX_LINEAR, GX_LINEAR, 0.0f, 0.0f, 0.0f, GX_FALSE, GX_FALSE, GX_ANISO_1);
            GXLoadTexObj(&texObj, GX_TEXMAP0);
            GXSetNumChans(0);
            GXSetTevColor(GX_TEVREG0, reg0);
            GXSetTevColor(GX_TEVREG1, reg1);
            GXSetNumTexGens(1);
            GXSetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
            GXSetNumTevStages(1);
            GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
            GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
            GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
            GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
            GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
            GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
            GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
            GXSetZMode(true, GX_LEQUAL, false);
            GXSetCullMode(GX_CULL_NONE);
#if VERSION > VERSION_JPN
            GXSetClipMode(GX_CLIP_DISABLE);
#endif
            GXSetNumIndStages(0);
            GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
            GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
            GXClearVtxDesc();
            GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
            GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
            MTXRotDeg(rotMtx, 'Z', rot);
            MTXConcat(camMtx, rotMtx, drawMtx);
            GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
            GXSetCurrentMtx(GX_PNMTX0);

            for (s32 i = 0; i < pPkt->mRainCount; i++) {
                f32 alpha = pPkt->mEff[i].mAlpha;
                if (alpha <= 0.0f)
                    continue;

                reg0.a = alpha * 14.0f;
                GXSetTevColor(GX_TEVREG0, reg0);

                p.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
                p.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
                p.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;

                f32 dist = p.abs(pCamera->mLookat.mEye);
                dist = dist / 1500.0f + 0.1f;
                if (dist > 1.0f)
                    dist = 1.0f;

                f32 size = 2.5f + (i / 250.0f);
                f32 speed = 5.0f + (dist * 70.0f);
                tilt.x = speed * (dummy.x + (0.08f * (i & 0x07)) + pPkt->mCenterDelta.x * pPkt->mCenterDeltaMul * 10.0f + windvec.x);
                tilt.y = speed * (dummy.y + pPkt->mCenterDelta.y * pPkt->mCenterDeltaMul + windvec.y);
                tilt.z = speed * (dummy.z + (0.08f * (i & 0x03)) + pPkt->mCenterDelta.z * pPkt->mCenterDeltaMul * 10.0f + windvec.z);

                vp.x = -1.0f * -size;
                vp.y = 0.0f;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[0].x = (p.x + lp.x) - tilt.x;
                pos[0].y = (p.y + lp.y) - tilt.y;
                pos[0].z = (p.z + lp.z) - tilt.z;

                vp.x = -1.0f * size;
                vp.y = 0.0f;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[1].x = (p.x + lp.x) - tilt.x;
                pos[1].y = (p.y + lp.y) - tilt.y;
                pos[1].z = (p.z + lp.z) - tilt.z;

                vp.x = -1.0f * -size;
                vp.y = 0.0f;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[2].x = p.x + lp.x;
                pos[2].y = p.y + lp.y;
                pos[2].z = p.z + lp.z;

                vp.x = -1.0f * size;
                vp.y = 0.0f;
                vp.z = 0.0f;
                MTXMultVec(camMtx, &vp, &lp);
                pos[3].x = p.x + lp.x;
                pos[3].y = p.y + lp.y;
                pos[3].z = p.z + lp.z;

                for (s32 j = 0; j < 4; j++) {
                    static const cXyz add_table[4] = {
                        cXyz(150.0f, 0.0f, 0.0f),
                        cXyz(0.0f, 150.0f, 150.0f),
                        cXyz(150.0f, 320.0f, 150.0f),
                        cXyz(45.0f, 480.0f, 45.0f),
                    };

                    GXBegin(GX_QUADS, GX_VTXFMT0, 4);
                    GXPosition3f32(pos[0].x + add_table[j].x, pos[0].y + add_table[j].y, pos[0].z + add_table[j].z);
                    GXTexCoord2s16(0, 0);
                    GXPosition3f32(pos[1].x + add_table[j].x, pos[1].y + add_table[j].y, pos[1].z + add_table[j].z);
                    GXTexCoord2s16(0xFF, 0);
                    GXPosition3f32(pos[2].x + add_table[j].x, pos[2].y + add_table[j].y, pos[2].z + add_table[j].z);
                    GXTexCoord2s16(0xFF, 0xFF);
                    GXPosition3f32(pos[3].x + add_table[j].x, pos[3].y + add_table[j].y, pos[3].z + add_table[j].z);
                    GXTexCoord2s16(0, 0xFF);
                    GXEnd();
                }
            }

#if VERSION > VERSION_JPN
            GXSetClipMode(GX_CLIP_ENABLE);
            J3DShape::resetVcdVatCache();
#endif
        }
    }
}

/* 8009682C-80096D18       .text dKyr_drawSibuki__FPA4_fPPUc */
void dKyr_drawSibuki(Mtx drawMtx, u8** pImg) {
    camera_class *pCamera = dComIfGp_getCamera(0);
    dKankyo_rain_Packet * pPkt = g_env_light.mpRainPacket;

    if (g_env_light.mSnowCount == 0 && dComIfGd_getView() != NULL) {
        Mtx camMtx;
        MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
    } else {
        return;
    }

    f32 alpha = 200.0f;
    if (pPkt->mStatus & 1)
        alpha = 0.0f;
    else if (pPkt->mStatus & 2)
        alpha = 200.0f;

    cLib_addCalc(&pPkt->mSibukiAlpha, alpha, 0.2f, 30.0f, 0.001f);

    cXyz eyevect, camDir;
    dKy_set_eyevect_calc(pCamera, &eyevect, 7000.0f, 4000.0f);
    dKyr_get_vectle_calc(&pCamera->mLookat.mEye, &pCamera->mLookat.mCenter, &camDir);

    f32 alphaFade;
    if (camDir.y > 0.0f) {
        if (camDir.y < 0.5f) {
            alphaFade = 1.0f - (camDir.y / 0.5f);
        } else {
            alphaFade = 0.0f;
        }
    } else {
        alphaFade = 1.0f;
    }

    GXColor color;
    color.r = 0xB4;
    color.g = 0xC8;
    color.b = 0xC8;
    color.a = (u8)(pPkt->mSibukiAlpha * alphaFade);

    GXTexObj texObj;
    dKyr_init_btitex(&texObj, (ResTIMG*)pImg[1]);
    GXLoadTexObj(&texObj, GX_TEXMAP0);

    GXSetNumChans(0);
    GXSetTevColor(GX_TEVREG0, color);
    GXSetTevColor(GX_TEVREG1, color);
    GXSetNumTexGens(1);
    GXSetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
    GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
    GXSetZMode(true, GX_GEQUAL, false);
    GXSetCullMode(GX_CULL_NONE);
#if VERSION > VERSION_JPN
    GXSetClipMode(GX_CLIP_DISABLE);
#endif
    GXSetNumIndStages(0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
    GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
    GXSetCurrentMtx(GX_PNMTX0);

    f32 scale;
    if (dComIfGd_getView() != NULL) {
        scale = dComIfGd_getView()->mFovy / 20.0f;
        if (scale >= 1.0f)
            scale = 1.0f;
        scale = 1.0f - scale;
    } else {
        scale = 0.2f;
    }

    for (s32 i = 0; i < g_env_light.mRainCount >> 1; i++) {
        cXyz pos[4], p;

        f32 size = 20.0f + (scale * cM_rndF(25.0f));

        f32 localX = cM_rndFX(3600.0f);
        f32 localY = cM_rndFX(1500.0f);
        f32 localZ = cM_rndFX(3600.0f);

        p.x = eyevect.x + localX;
        p.y = eyevect.y + localY;
        p.z = eyevect.z + localZ;

        pos[0].x = p.x - size;
        pos[0].y = p.y;
        pos[0].z = p.z - size;

        pos[1].x = p.x + size;
        pos[1].y = p.y;
        pos[1].z = p.z - size;

        pos[2].x = p.x + size;
        pos[2].y = p.y;
        pos[2].z = p.z + size;

        pos[3].x = p.x - size;
        pos[3].y = p.y;
        pos[3].z = p.z + size;

        GXBegin(GX_QUADS, GX_VTXFMT0, 4);
        GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
        GXTexCoord2s16(0, 0);
        GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
        GXTexCoord2s16(0x1FF, 0);
        GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
        GXTexCoord2s16(0x1FF, 0x1FF);
        GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
        GXTexCoord2s16(0, 0x1FF);
        GXEnd();
    }

#if VERSION > VERSION_JPN
    GXSetClipMode(GX_CLIP_ENABLE);
    J3DShape::resetVcdVatCache();
#endif
}

/* 80096D18-800973CC       .text drawPoison__FPA4_fPPUc */
void drawPoison(Mtx drawMtx, u8** pImg) {
    /* Nonmatching - just mul order when computing reg0/reg1 */
    dScnKy_env_light_c& envLight = dKy_getEnvlight();
    dKankyo_poison_Packet* pPkt;
    GXTexObj texObj;
    Mtx camMtx;
    Mtx rotMtx;
    cXyz pos[4];
    cXyz windvec;
    cXyz vp;
    cXyz lp;
    cXyz p;
    cXyz dummy;
    cXyz tilt;
    GXColor reg0, reg1;

    pPkt = dKy_getEnvlight().mpPoisonPacket;
    static f32 rot = 0.0f;

    j3dSys.reinitGX();
    if (dComIfGd_getView() != NULL) {
        MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
    } else {
        return;
    }

    reg0.r = 0x2D;
    reg0.g = 0x88;
    reg0.b = 0xAA;

    reg1.r = 0x6D;
    reg1.g = 0x3C;
    reg1.b = 0xCD;

    dKyr_set_btitex(&texObj, (ResTIMG*)pImg[0]);

    GXSetNumChans(0);
    GXSetTevColor(GX_TEVREG0, reg0);
    GXSetTevColor(GX_TEVREG1, reg1);
    GXSetNumTexGens(1);
    GXSetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    dKy_GxFog_set();
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
    GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
    GXSetZMode(GX_TRUE, GX_LEQUAL, GX_FALSE);
    GXSetCullMode(GX_CULL_NONE);
    GXSetNumIndStages(0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
    MTXRotDeg(rotMtx, 'Z', rot);
    MTXConcat(camMtx, rotMtx, camMtx);
    GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
    rot += 1.3f;
    if (rot < 0.0f)
        rot = 719.0f;
    GXSetCurrentMtx(GX_PNMTX0);

    for (s32 i = 0; i < dKy_getEnvlight().mPoisonCount; i++) {
        f32 size = pPkt->mEff[i].mSize;
        if (pPkt->mEff[i].mAlpha <= 0.000001f)
            continue;

        GXLoadTexObj(&texObj, GX_TEXMAP0);

        f32 cosR = std::fabsf(cM_scos(envLight.mpPoisonPacket->mCount * 500.0f + i * 4000));
        cosR *= cosR;

        reg0.r = 95.0f + -50.0f * cosR;
        reg0.g = 186.0f + -50.0f * cosR;
        reg0.b = 226.0f + -56.0f * cosR;

        reg1.r = 115.0f + -6.0f * cosR;
        reg1.g = 206.0f + -146.0f * cosR;
        reg1.b = 255.0f + -50.0f * cosR;

        reg0.a = pPkt->mEff[i].mAlpha * 255.0f;

        GXSetTevColor(GX_TEVREG0, reg0);
        GXSetTevColor(GX_TEVREG1, reg1);

        p.x = pPkt->mBasePos.x + pPkt->mEff[i].mPos.x;
        p.y = pPkt->mBasePos.y + pPkt->mEff[i].mPos.y;
        p.z = pPkt->mBasePos.z + pPkt->mEff[i].mPos.z;

        vp.x = -size;
        vp.y = size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[0].x = p.x + lp.x;
        pos[0].y = p.y + lp.y;
        pos[0].z = p.z + lp.z;

        vp.x = size;
        vp.y = size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[1].x = p.x + lp.x;
        pos[1].y = p.y + lp.y;
        pos[1].z = p.z + lp.z;

        vp.x = size;
        vp.y = -size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[2].x = p.x + lp.x;
        pos[2].y = p.y + lp.y;
        pos[2].z = p.z + lp.z;

        vp.x = -size;
        vp.y = -size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[3].x = p.x + lp.x;
        pos[3].y = p.y + lp.y;
        pos[3].z = p.z + lp.z;

        GXBegin(GX_QUADS, GX_VTXFMT0, 4);
        GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
        GXTexCoord2s16(0, 0);
        GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
        GXTexCoord2s16(0xFF, 0);
        GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
        GXTexCoord2s16(0xFF, 0xFF);
        GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
        GXTexCoord2s16(0, 0xFF);
        GXEnd();
    }

#if VERSION > VERSION_JPN
    GXSetClipMode(GX_CLIP_ENABLE);
    J3DShape::resetVcdVatCache();
#endif
}

/* 800973CC-80097AD0       .text dKyr_drawHousi__FPA4_fPPUc */
void dKyr_drawHousi(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
    dKankyo_housi_Packet* housi_packet = g_env_light.mpHousiPacket;
    static u32 rot = 0;

    Mtx camMtx;
    Mtx rotMtx;
    cXyz pos[4];
    GXTexObj spDC;
    cXyz spD0;
    Vec spC4;
    Vec spB8;

    if (housi_packet->mCount != 0) {
        f32 var_f25 = 120.0f;

        GXColor color_reg0;
        color_reg0.r = 0xE5;
        color_reg0.g = 0xFF;
        color_reg0.b = 0xC8;
        color_reg0.a = var_f25;

        GXColor color_reg1;
        color_reg1.r = 0x43;
        color_reg1.g = 0xD2;
        color_reg1.b = 0xCA;
        color_reg1.a = 0xFF;

        if (dComIfGd_getView() != NULL) {
            MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
        } else {
            return;
        }

        f32 temp_f26 = 1.2f;
        f32 temp_f24 = 6.5f;

        for (int i = 0; i < 2; i++) {
            dKyr_set_btitex(&spDC, (ResTIMG*)pImg[0]);
            GXSetNumChans(0);
            GXSetTevColor(GX_TEVREG0, color_reg0);
            GXSetTevColor(GX_TEVREG1, color_reg1);
            GXSetNumTexGens(1);
            GXSetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
            GXSetNumTevStages(1);
            GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
            GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
            GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
            GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
            GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
            GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
            GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);

            if (i == 1) {
                GXSetZMode(GX_TRUE, GX_GEQUAL, GX_FALSE);
            } else {
                GXSetZMode(GX_TRUE, GX_LEQUAL, GX_FALSE);
            }

            GXSetCullMode(GX_CULL_NONE);
            GXSetClipMode(GX_CLIP_DISABLE);
            GXSetNumIndStages(0);

            GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
            GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
            GXClearVtxDesc();
            GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
            GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);

            MTXRotRad(rotMtx, 'Z', DEG_TO_RAD(rot));
            MTXConcat(camMtx, rotMtx, camMtx);

            GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
            GXSetCurrentMtx(GX_PNMTX0);

            for (int j = 0; j < housi_packet->mCount; j++) {
                fopAc_ac_c* player = dComIfGp_getPlayer(0);

                spD0.x = housi_packet->mEffect[j].mBasePos.x + housi_packet->mEffect[j].mPos.x;
                spD0.y = housi_packet->mEffect[j].mBasePos.y + housi_packet->mEffect[j].mPos.y;
                spD0.z = housi_packet->mEffect[j].mBasePos.z + housi_packet->mEffect[j].mPos.z;

                if (i == 1 && j == 0) {
                    color_reg0.r = 0;
                    color_reg0.g = 0;
                    color_reg0.b = 0;

                    color_reg1.r = 0;
                    color_reg1.g = 0;
                    color_reg1.b = 0;

                    GXSetTevColor(GX_TEVREG1, color_reg1);
                }

                if (i == 1) {
                    f32 temp_f4 = 100.0f;
                    if (!(spD0.y > player->current.pos.y + temp_f4)) {
                        if (!(spD0.y < player->current.pos.y - 20.0f)) {
                            if (!(housi_packet->mEffect[j].mAlpha <= 0.0f)) {
                                color_reg0.a =
                                    housi_packet->mEffect[j].mAlpha * 40.0f *
                                    (1.0f - ((spD0.y - player->current.pos.y) / 100.0f));
                                spD0.y = player->current.pos.y - 20.0f;
                                goto block_14;  // probably fake match
                            }
                        }
                    }
                } else {
                    color_reg0.a = housi_packet->mEffect[j].mAlpha * var_f25;

                block_14:
                    GXLoadTexObj(&spDC, GX_TEXMAP0);
                    GXSetTevColor(GX_TEVREG0, color_reg0);

                    f32 var_f27 = housi_packet->mEffect[j].field_0x48 * 9.0f;

                    f32 temp_f28 = (var_f27 * 0.2f) * cM_fsin(housi_packet->mEffect[j].mScale.x * 5.0f);
                    f32 temp_f30 = (var_f27 * 0.2f) * cM_fsin(housi_packet->mEffect[j].mScale.y * 6.0f);

                    spC4.x = var_f27 - temp_f30;
                    spC4.y = var_f27 - temp_f28;
                    spC4.z = 0.0f;
                    MTXMultVec(camMtx, &spC4, &spB8);
                    pos[0].x = spD0.x + spB8.x;
                    pos[0].y = spD0.y + spB8.y;
                    pos[0].z = spD0.z + spB8.z;

                    spC4.x = -var_f27 + temp_f30;
                    spC4.y = var_f27 - temp_f28;
                    spC4.z = 0.0f;
                    MTXMultVec(camMtx, &spC4, &spB8);
                    pos[1].x = spD0.x + spB8.x;
                    pos[1].y = spD0.y + spB8.y;
                    pos[1].z = spD0.z + spB8.z;

                    spC4.x = -var_f27 + temp_f30;
                    spC4.y = -var_f27 + temp_f28;
                    spC4.z = 0.0f;
                    MTXMultVec(camMtx, &spC4, &spB8);
                    pos[2].x = spD0.x + spB8.x;
                    pos[2].y = spD0.y + spB8.y;
                    pos[2].z = spD0.z + spB8.z;

                    spC4.x = var_f27 - temp_f30;
                    spC4.y = -var_f27 + temp_f28;
                    spC4.z = 0.0f;
                    MTXMultVec(camMtx, &spC4, &spB8);
                    pos[3].x = spD0.x + spB8.x;
                    pos[3].y = spD0.y + spB8.y;
                    pos[3].z = spD0.z + spB8.z;

                    GXBegin(GX_QUADS, GX_VTXFMT0, 4);

                    s16 var_r17 = 0x1FF;

                    GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
                    GXTexCoord2s16(0, 0);
                    GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
                    GXTexCoord2s16(var_r17, 0);
                    GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
                    GXTexCoord2s16(var_r17, var_r17);
                    GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
                    GXTexCoord2s16(0, var_r17);
                    GXEnd();
                }
            }
        }

        GXSetClipMode(GX_CLIP_ENABLE);
        J3DShape::resetVcdVatCache();
    }
}

/* 80097AD0-800987B8       .text dKyr_drawKazanbai__FPA4_fPPUc */
void dKyr_drawKazanbai(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
}

/* 800987B8-80098FF0       .text dKyr_drawSnow__FPA4_fPPUc */
void dKyr_drawSnow(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
}

/* 80098FF0-80099D38       .text dKyr_drawStar__FPA4_fPPUc */
void dKyr_drawStar(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
    dScnKy_env_light_c* envlight = &dKy_getEnvlight();
    dKankyo_star_Packet* star_packet = g_env_light.mpStarPacket;
    camera_class* camera = (camera_class*)dComIfGp_getCamera(0);

    static u32 rot = 0;

    cXyz pos[4];

    Mtx camMtx;
    cXyz spBC;
    cXyz moon_proj;
    cXyz star_proj;

    Vec sp98, sp8C;
    cXyz moon_pos;

    BOOL sp38 = false;

    // Cassiopeia and Orion constellation positions
    static csXyz hokuto_position[] = {
        csXyz(13000, 10500, -16000),
        csXyz(9400, 9800, -12646),
        csXyz(10200, 11800, -13525),
        csXyz(10300, 13450, -13525),
        csXyz(15000, 18400, -16162),
        csXyz(12500, 19800, -15000),
        csXyz(9179, 17200, -14404),
        csXyz(9500, 9800, -12646),
        csXyz(-7421, 31005, 18798),
        csXyz(-10937, 28000, 15000),
        csXyz(-10000, 24902, 18400),
        csXyz(-9400, 22500, 15900),
        csXyz(-9179, 21300, 14300),
        csXyz(-10300, 22000, 21000),
        csXyz(-16000, 25500, 20000),
        csXyz(0, 30000, 19000),
    };

    if (star_packet->mEffectNum != 0) {
        GXColor color_reg0;
        color_reg0.r = 0xDC;
        color_reg0.g = 0xE6;
        color_reg0.b = 0xFF;
        color_reg0.a = 0xFF;

        if (dComIfGd_getView() != NULL) {
            MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
        } else {
            return;
        }

        mDoLib_project(&envlight->mMoonPos, &moon_proj);

        GXSetNumChans(1);
        GXSetChanCtrl(GX_COLOR0, GX_DISABLE, GX_SRC_REG, GX_SRC_REG, GX_LIGHT_NULL, GX_DF_CLAMP, GX_AF_NONE);
        GXSetNumTexGens(0);
        GXSetNumTevStages(1);
        GXSetTevColor(GX_TEVREG0, color_reg0);
        GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD_NULL, GX_TEXMAP_NULL, GX_COLOR0A0);
        GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_C0);
        GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_A0);
        GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetZMode(GX_ENABLE, GX_LEQUAL, GX_DISABLE);
        GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_CLEAR);
        GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
        GXSetNumIndStages(0);
        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_CLR_RGBA, GX_F32, 0);
        GXClearVtxDesc();
        GXSetVtxDesc(GX_VA_POS, GX_DIRECT);

        Mtx rotMtx;
        MTXRotRad(rotMtx, 'Z', DEG_TO_RAD(rot));
        MTXConcat(camMtx, rotMtx, camMtx);

        GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
        GXSetCurrentMtx(GX_PNMTX0);

        rot++;
        if (rot > 719) {
            rot = 0;
        }

        spBC.x = camera->mLookat.mEye.x;
        spBC.y = camera->mLookat.mEye.y;
        spBC.z = camera->mLookat.mEye.z;

        f32 sp34 = -1.0f;
        int sp30 = 0;
        f32 var_f30 = 0.0f;

        if (dComIfGd_getView() != NULL) {
            var_f30 = dComIfGd_getView()->mFovy / 45.0f;
            if (var_f30 >= 1.0f) {
                var_f30 = 1.0f;
            }
            var_f30 = 1.0f - var_f30;
        }

        f32 temp_f27 = 0.28f * (1.0f - var_f30);

        sp98.x = 0.0f;
        sp98.y = temp_f27;
        sp98.z = 0.0f;
        cMtx_multVec(camMtx, &sp98, &sp8C);
        pos[0].x = spBC.x + sp8C.x;
        pos[0].y = spBC.y + sp8C.y;
        pos[0].z = spBC.z + sp8C.z;

        sp98.x = temp_f27;
        sp98.y = -(0.5f * temp_f27);
        sp98.z = 0.0f;
        cMtx_multVec(camMtx, &sp98, &sp8C);
        pos[1].x = spBC.x + sp8C.x;
        pos[1].y = spBC.y + sp8C.y;
        pos[1].z = spBC.z + sp8C.z;

        sp98.x = -temp_f27;
        sp98.y = -(0.5f * temp_f27);
        sp98.z = 0.0f;
        cMtx_multVec(camMtx, &sp98, &sp8C);
        pos[2].x = spBC.x + sp8C.x;
        pos[2].y = spBC.y + sp8C.y;
        pos[2].z = spBC.z + sp8C.z;

        int sp48 = 0;
        int sp44 = 0;
        f32 var_f28 = 0.0f;

        for (int i = 0; i < star_packet->mEffectNum; i++) {
            f32 star_size;
            cXyz star_pos;
            f32 sp2C = 300.0f;

            if (i < (s32)ARRAY_SIZE(hokuto_position)) {
                star_pos.x = hokuto_position[i].x;
                star_pos.y = hokuto_position[i].y;
                star_pos.z = hokuto_position[i].z;

                if (i <= 7) {
                    star_size = 190.0f + star_packet->mEffect[0].mSin;
                } else {
                    star_size = 290.0f + star_packet->mEffect[0].mSin;
                }

                star_size -= temp_f27 * (0.5f * star_size);
            } else {
                star_size = star_packet->mEffect[0].mSin + (0.066f * (i & 0x0F));
                if (star_size > 1.0f)
                    star_size = (1.0f - (star_size - 1.0f));

                f32 temp_f29 = 1.0f - (var_f28 * (1.0f / 202.0f));
                star_pos.x = temp_f29 * (sp2C * -cM_ssin((sp48 - 0x8000)));
                star_pos.y = 45.0f + var_f28;
                star_pos.z = temp_f29 * (sp2C * cM_scos((sp48 - 0x8000)));

                sp48 += sp44;
                sp44 += 2250;

                temp_f29 = var_f28 / 200.0f;
                temp_f29 *= temp_f29 * temp_f29;
                var_f28 += 1.0f + (3.0f * temp_f29);
                if (var_f28 > 200.0f) {
                    var_f28 = (20.0f * i) / 1000.0f;
                }
            }

            static const GXColor star_col[] = {
                /* red   */ {0xFF, 0xBE, 0xC8, 0xA0},
                /* green */ {0xC8, 0xFF, 0xBE, 0x78},
                /* blue  */ {0xC8, 0xBE, 0xFF, 0x50},
                /* white */ {0xFF, 0xFF, 0xFF, 0xC8},
            };

            if (i == 6 || i == 8)
                color_reg0 = star_col[1];
            else if ((i & 0x3F) == 0)
                color_reg0 = star_col[(i >> 4) & 3];
            else
                color_reg0 = star_col[0];
            GXSetTevColor(GX_TEVREG0, color_reg0);

            cXyz center;
            cXyz sp5C;
            center.x = spBC.x + star_pos.x;
            center.y = spBC.y + star_pos.y;
            center.z = spBC.z + star_pos.z;

            mDoLib_project(&center, &star_proj);

            f32 moon_dist_to_star = moon_proj.abs(star_proj);
            f32 moon_threshold = 80.0f + (700.0f * (var_f30 * var_f30));

            // if a star is too close to the moon then avoid drawing
            if (moon_dist_to_star > moon_threshold) {
                GXBegin(GX_QUADS, GX_VTXFMT0, 3);
                GXPosition3f32(center.x + (star_size * (pos[0].x - spBC.x)), center.y + (star_size * (pos[0].y - spBC.y)), center.z + (star_size * (pos[0].z - spBC.z)));
                GXPosition3f32(center.x + (star_size * (pos[1].x - spBC.x)), center.y + (star_size * (pos[1].y - spBC.y)), center.z + (star_size * (pos[1].z - spBC.z)));
                GXPosition3f32(center.x + (star_size * (pos[2].x - spBC.x)), center.y + (star_size * (pos[2].y - spBC.y)), center.z + (star_size * (pos[2].z - spBC.z)));
                GXEnd();
                
                GXBegin(GX_QUADS, GX_VTXFMT0, 3);
                GXPosition3f32(center.x - (star_size * (pos[0].x - spBC.x)), center.y - (star_size * (pos[0].y - spBC.y)), center.z - (star_size * (pos[0].z - spBC.z)));
                GXPosition3f32(center.x - (star_size * (pos[1].x - spBC.x)), center.y - (star_size * (pos[1].y - spBC.y)), center.z - (star_size * (pos[1].z - spBC.z)));
                GXPosition3f32(center.x - (star_size * (pos[2].x - spBC.x)), center.y - (star_size * (pos[2].y - spBC.y)), center.z - (star_size * (pos[2].z - spBC.z)));
                GXEnd();
            }
        }

        J3DShape::resetVcdVatCache();
    }
}

/* 80099D38-8009A5D4       .text drawWave__FPA4_fPPUc */
void drawWave(Mtx drawMtx, u8** pImg) {
    /* Nonmatching */
    dKankyo_wave_Packet* pPkt;
    camera_class* pCamera;
    GXTexObj texObj;
    Mtx camMtx;
    Mtx rotMtx;
    cXyz pos[4];
    cXyz windvec;
    cXyz p;
    cXyz vp;
    cXyz lp;
    cXyz dummy;
    cXyz tilt;
    GXColor dif, amb;

    pPkt = dKy_getEnvlight().mpWavePacket;
    pCamera = dComIfGp_getCamera(0);

    if (!(dKy_getEnvlight().mWaveChan.mWaveFlatInter >= 1.0f) && dComIfGd_getView() != NULL) {
        MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
    } else {
        return;
    }

    f32 rot = cM_sht2d(pCamera->mBank);
    j3dSys.reinitGX();

    GXSetClipMode(GX_CLIP_ENABLE);

    s32 texidx = strcmp(dComIfGp_getStartStageName(), "MajyuE") == 0 ? 1 : 0;
    dKyr_set_btitex(&texObj, (ResTIMG*)pImg[texidx]);

    GXSetNumChans(0);
    GXSetNumTexGens(1);
    GXSetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
    dKy_get_seacolor(&amb, &dif);
    GXSetTevColor(GX_TEVREG0, dif);
    GXSetTevKColorSel(GX_TEVSTAGE0, GX_TEV_KCSEL_K0);
    GXSetTevKAlphaSel(GX_TEVSTAGE0, GX_TEV_KASEL_K3_A);
    GXSetTevKColor(GX_KCOLOR0, amb);
    GXSetTevKColor(GX_KCOLOR3, amb);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C0, GX_CC_KONST, GX_CC_TEXC, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_KONST, GX_CA_TEXA, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    dKy_GxFog_sea_set();
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
    GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
    GXSetZCompLoc(GX_FALSE);
    GXSetZMode(GX_TRUE, GX_LEQUAL, GX_TRUE);
    GXSetCullMode(GX_CULL_NONE);
    GXSetNumIndStages(0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
    MTXRotDeg(rotMtx, 'Z', rot);
    MTXConcat(camMtx, rotMtx, camMtx);
    GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
    GXSetCurrentMtx(GX_PNMTX0);

    for (s32 i = 0; i < dKy_getEnvlight().mWaveChan.mWaveCount; i++) {
        p.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
        p.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
        p.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;

        f32 wave = sin(pPkt->mEff[i].mCounter);
        if (wave <= 0.0f)
            continue;

        f32 scale = dKy_getEnvlight().mWaveChan.mWaveScale * pPkt->mEff[i].mScale * wave;
        f32 scaleBottom = dKy_getEnvlight().mWaveChan.mWaveScaleBottom * scale;
        f32 strength = pPkt->mEff[i].mStrengthEnv;
        f32 height = strength * scale;
        f32 width = scaleBottom * (strength - 0.00000015f * (i * 32) * height);
        if (height <= 0.0f)
            continue;

        GXLoadTexObj(&texObj, GX_TEXMAP0);
        amb.a = pPkt->mEff[i].mAlpha * 255.0f;
        GXSetTevKColor(GX_KCOLOR3, amb);

        if (pPkt->mSkewDir < 0.0f) {
            vp.x = -width + width * -(pPkt->mEff[i].mSpeed * 1.2f) * pPkt->mSkewWidth;
        } else {
            vp.x = -width - width * -(pPkt->mEff[i].mSpeed * 1.2f) * pPkt->mSkewWidth;
        }
        vp.y = height;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[0].x = p.x + lp.x;
        pos[0].y = p.y + lp.y;
        pos[0].z = p.z + lp.z;

        if (pPkt->mSkewDir < 0.0f) {
            vp.x = width + width * -(pPkt->mEff[i].mSpeed * 1.2f) * pPkt->mSkewWidth;
        } else {
            vp.x = width - width * -(pPkt->mEff[i].mSpeed * 1.2f) * pPkt->mSkewWidth;
        }
        vp.y = height;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[1].x = p.x + lp.x;
        pos[1].y = p.y + lp.y;
        pos[1].z = p.z + lp.z;

        vp.x = width;
        vp.y = 0.0f;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[2].x = p.x + lp.x;
        pos[2].y = p.y + lp.y;
        pos[2].z = p.z + lp.z;

        vp.x = -width;
        vp.y = 0.0f;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[3].x = p.x + lp.x;
        pos[3].y = p.y + lp.y;
        pos[3].z = p.z + lp.z;

        for (s32 j = 0; j < 1; j++) {
            static const cXyz add_table[4] = {
                cXyz(0.0f, 0.0f, 0.0f),
                cXyz(800.0f, 0.0f, 400.0f),
                cXyz(600.0f, 0.0f, 200.0f),
                cXyz(200.0f, 0.0f, 800.0f),
            };

            GXBegin(GX_QUADS, GX_VTXFMT0, 4);
            GXPosition3f32(pos[0].x + add_table[j].x, pos[0].y + add_table[j].y, pos[0].z + add_table[j].z);
            GXTexCoord2s16(0, 0);
            GXPosition3f32(pos[1].x + add_table[j].x, pos[1].y + add_table[j].y, pos[1].z + add_table[j].z);
            GXTexCoord2s16(0xFA, 0);
            GXPosition3f32(pos[2].x + add_table[j].x, pos[2].y + add_table[j].y, pos[2].z + add_table[j].z);
            GXTexCoord2s16(0xFA, 0xFA);
            GXPosition3f32(pos[3].x + add_table[j].x, pos[3].y + add_table[j].y, pos[3].z + add_table[j].z);
            GXTexCoord2s16(0, 0xFA);
            GXEnd();
        }
    }

#if VERSION > VERSION_JPN
    J3DShape::resetVcdVatCache();
#endif
}

/* 8009A5D4-8009AB88       .text drawCloudShadow__FPA4_fPPUc */
void drawCloudShadow(Mtx drawMtx, u8** pImg) {
    dScnKy_env_light_c& envLight = dKy_getEnvlight();
    camera_class *pCamera = (camera_class*)dComIfGp_getCamera(0);
    dKankyo_cloud_Packet* pPkt = g_env_light.mpMoyaPacket;
    static f32 rot = 0.0f;
    GXTexObj texObj;
    Mtx camMtx;
    Mtx rotMtx;
    cXyz pos[4];
    cXyz windvec;
    cXyz vp;
    cXyz lp;
    cXyz p;
    cXyz dummy;
    cXyz tilt;

    if (pPkt->mCount <= 0)
        return;

    j3dSys.reinitGX();
    if (dComIfGd_getView() != NULL) {
        MTXInverse(dComIfGd_getViewRotMtx(), camMtx);
    } else {
        return;
    }

#if VERSION > VERSION_JPN
    GXSetClipMode(GX_CLIP_DISABLE);
#endif

    GXColor reg0, reg1;
    if (dKy_getEnvlight().mMoyaMode != 3 && dKy_getEnvlight().mMoyaMode != 4) {
        reg0.r = envLight.mBG0_K0.r;
        reg0.g = envLight.mBG0_K0.g;
        reg0.b = envLight.mBG0_K0.b;

        reg1.r = envLight.mBG0_K0.r;
        reg1.g = envLight.mBG0_K0.g;
        reg1.b = envLight.mBG0_K0.b;
    } else {
        reg0.r = envLight.mBG3_K0.r;
        reg0.g = envLight.mBG3_K0.g;
        reg0.b = envLight.mBG3_K0.b;

        reg1.r = envLight.mBG3_K0.r;
        reg1.g = envLight.mBG3_K0.g;
        reg1.b = envLight.mBG3_K0.b;
    }

    dKyr_set_btitex(&texObj, (ResTIMG*)pImg[0]);

    GXSetNumChans(0);
    GXSetTevColor(GX_TEVREG0, reg0);
    GXSetTevColor(GX_TEVREG1, reg1);
    GXSetNumTexGens(1);
    GXSetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_TEXC, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_TEXA, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, true, GX_TEVPREV);
    dKy_GxFog_set();
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_SET);
    GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
    GXSetZMode(GX_FALSE, GX_LEQUAL, GX_FALSE);
    GXSetCullMode(GX_CULL_NONE);
    GXSetNumIndStages(0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S16, 8);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
    MTXRotDeg(rotMtx, 'Z', rot);
    MTXConcat(camMtx, rotMtx, camMtx);
    GXLoadPosMtxImm(drawMtx, GX_PNMTX0);
    rot -= 1.5f;
    if (rot < 0.0f)
        rot = 719.0f;
    GXSetCurrentMtx(GX_PNMTX0);

    for (s32 i = 0; i < pPkt->mCount; i++) {
        f32 size = pPkt->mEff[i].mSize;
        if (pPkt->mEff[i].mAlpha <= 0.000001f)
            continue;

        GXLoadTexObj(&texObj, GX_TEXMAP0);

        reg0.a = pPkt->mEff[i].mAlpha * 255.0f;
        GXSetTevColor(GX_TEVREG0, reg0);

        p.x = pPkt->mEff[i].mBasePos.x + pPkt->mEff[i].mPos.x;
        p.y = pPkt->mEff[i].mBasePos.y + pPkt->mEff[i].mPos.y;
        p.z = pPkt->mEff[i].mBasePos.z + pPkt->mEff[i].mPos.z;

        vp.x = -size;
        vp.y = size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[0].x = p.x + lp.x;
        pos[0].y = p.y + lp.y;
        pos[0].z = p.z + lp.z;

        vp.x = size;
        vp.y = size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[1].x = p.x + lp.x;
        pos[1].y = p.y + lp.y;
        pos[1].z = p.z + lp.z;

        vp.x = size;
        vp.y = -size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[2].x = p.x + lp.x;
        pos[2].y = p.y + lp.y;
        pos[2].z = p.z + lp.z;

        vp.x = -size;
        vp.y = -size;
        vp.z = 0.0f;
        MTXMultVec(camMtx, &vp, &lp);
        pos[3].x = p.x + lp.x;
        pos[3].y = p.y + lp.y;
        pos[3].z = p.z + lp.z;

        GXBegin(GX_QUADS, GX_VTXFMT0, 4);
        GXPosition3f32(pos[0].x, pos[0].y, pos[0].z);
        GXTexCoord2s16(0, 0);
        GXPosition3f32(pos[1].x, pos[1].y, pos[1].z);
        GXTexCoord2s16(0xFF, 0);
        GXPosition3f32(pos[2].x, pos[2].y, pos[2].z);
        GXTexCoord2s16(0xFF, 0xFF);
        GXPosition3f32(pos[3].x, pos[3].y, pos[3].z);
        GXTexCoord2s16(0, 0xFF);
        GXEnd();
    }

#if VERSION > VERSION_JPN
    GXSetClipMode(GX_CLIP_ENABLE);
    J3DShape::resetVcdVatCache();
#endif
}

/* 8009AB88-8009B9C4       .text drawVrkumo__FPA4_fR8GXColorPPUc */
void drawVrkumo(Mtx drawMtx, GXColor& clr, u8** pImg) {
    /* Nonmatching */
}

/* 8009B9C4-8009B9D8       .text dKyr_thunder_init__Fv */
void dKyr_thunder_init() {
    g_env_light.mThunderEff.mState = 0;
}

/* 8009B9D8-8009BDEC       .text dKyr_thunder_move__Fv */
void dKyr_thunder_move() {
    EF_THUNDER * pThunder = &g_env_light.mThunderEff;
    camera_class * pCamera = dComIfGp_getCamera(0);

    switch (pThunder->mState) {
    case 0:
        {
            pThunder->mFlashTimer = 0.0f;
            pThunder->field_0xc = 0.0f;
            pThunder->field_0x10 = 0.0f;

            if (cM_rndF(1.0f) < 0.007f) {
                pThunder->mState = 11;
            } else if (cM_rndF(1.0f) < 0.005f && g_env_light.mThunderEff.mMode < 10) {
                pThunder->mLightInfluence.mPos.x = pCamera->mLookat.mEye.x;
                pThunder->mLightInfluence.mPos.y = pCamera->mLookat.mEye.y;
                pThunder->mLightInfluence.mPos.z = pCamera->mLookat.mEye.z;
                pThunder->mLightInfluence.mColor.r = 0;
                pThunder->mLightInfluence.mColor.g = 0;
                pThunder->mLightInfluence.mColor.b = 0;
                pThunder->mLightInfluence.mPower = 90000.0f;
                pThunder->mLightInfluence.mFluctuation = 150.0f;
                dKy_efplight_set(&pThunder->mLightInfluence);
                pThunder->mState++;
            }
        }
        break;
    case 1:
    case 11:
        {
            cLib_addCalc(&pThunder->mFlashTimer, 1.0f, 0.3f, 0.2f, 0.001f);
            if (pThunder->mFlashTimer >= 1.0f) {
                if (pThunder->mState < 10)
                    mDoAud_seStart(JA_SE_OBJ_THUNDER_NEAR, NULL);
                pThunder->mState++;
            }

            if (cM_rndF(1.0f) < 0.18f)
                fopKyM_create(PROC_KY_THUNDER, -1);
        }
        break;
    case 2:
    case 12:
        {
            cLib_addCalc(&pThunder->mFlashTimer, 0.0f, 0.1f, 0.05f, 0.001f);
            if (pThunder->mFlashTimer <= 0.0f) {
                if (pThunder->mState < 10)
                    dKy_efplight_cut(&pThunder->mLightInfluence);

                pThunder->mState = 0;
                if (g_env_light.mThunderEff.mMode == 0)
                    pThunder->mStatus = 0;
            }
        }
        break;
    }

    if (pThunder->mState != 0) {
        if (pThunder->mState < 10) {
            pThunder->mLightInfluence.mPos.x = pCamera->mLookat.mEye.x;
            pThunder->mLightInfluence.mPos.y = pCamera->mLookat.mEye.y + 150.0f;
            pThunder->mLightInfluence.mPos.z = pCamera->mLookat.mEye.z;
            pThunder->mLightInfluence.mColor.r = (u8)(pThunder->mFlashTimer * 0.2f * 180.0f);
            pThunder->mLightInfluence.mColor.g = (u8)(pThunder->mFlashTimer * 0.2f * 235.0f);
            pThunder->mLightInfluence.mColor.b = (u8)(pThunder->mFlashTimer * 0.2f * 255.0f);
            if (g_env_light.field_0xc98 == 0) {
                dKy_actor_addcol_amb_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.5f);
                dKy_actor_addcol_dif_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.5f);
                dKy_bg_addcol_amb_set(0x32, 0x78, 0xff, pThunder->mFlashTimer * 0.7f);
                dKy_bg_addcol_dif_set(0x32, 0x78, 0xff, pThunder->mFlashTimer * 0.7f);
                dKy_bg1_addcol_amb_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.35f);
                dKy_bg1_addcol_dif_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.35f);
                dKy_vrbox_addcol_sky0_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.4f);
                dKy_vrbox_addcol_kasumi_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.5f);
                dKy_addcol_fog_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.3f);
            }
        } else {
            dKy_vrbox_addcol_sky0_set(0x5a,0xa0,0xf5,(pThunder->mFlashTimer * 0.15f));
            dKy_vrbox_addcol_kasumi_set(0x5a,0xa0,0xf5,(pThunder->mFlashTimer * 0.35f));
            dKy_addcol_fog_set(0x5a, 0xa0, 0xf5, pThunder->mFlashTimer * 0.12f);
        }
    }
}
