//
// Generated by dtk
// Translation Unit: f_op_actor.cpp
//

#include "d/dolzel.h" // IWYU pragma: keep
#include "f_op/f_op_actor.h"
#include "f_op/f_op_actor_mng.h"
#include "f_op/f_op_actor_tag.h"
#include "f_op/f_op_draw_tag.h"
#include "f_pc/f_pc_leaf.h"
#include "d/d_demo.h"
#include "d/d_map.h"
#include "d/d_meter.h"
#include "d/d_com_inf_game.h"
#include "d/d_s_play.h"

#if VERSION == VERSION_DEMO
#include "m_Do/m_Do_printf.h"

class print_error_check_c {
public:
    struct param_s {
        const char* m00;
        u32 m04;
    };
    print_error_check_c(fopAc_ac_c* actor, const param_s& prm);
    ~print_error_check_c();
    void start();
    void check();
    
    static u8 mPriorityMaximum;
    static bool mPrintDisable;
    
    static param_s sEXECUTE;
    static param_s sCREATE;
    static param_s sDELETE;
    static param_s sIS_DELETE;
    static param_s sDRAW;

private:
    fopAc_ac_c* mpActor;
    param_s mParam;
    u32 mNumErrors;
    OSTick mTick;
    OSPriority mPriority;
    u32 mReportDisable;
};

u8 print_error_check_c::mPriorityMaximum = 0;
bool print_error_check_c::mPrintDisable = false;

print_error_check_c::param_s print_error_check_c::sEXECUTE = {
    "EXECUTE", 0xBB8,
};
print_error_check_c::param_s print_error_check_c::sCREATE = {
    "CREATE", 0xBB8,
};
print_error_check_c::param_s print_error_check_c::sDELETE = {
    "DELETE", 0xBB8,
};
print_error_check_c::param_s print_error_check_c::sIS_DELETE = {
    "IS_DELETE", 0x1E,
};
print_error_check_c::param_s print_error_check_c::sDRAW = {
    "DRAW", 0xBB8,
};

print_error_check_c::print_error_check_c(fopAc_ac_c* actor, const param_s& prm) {
    mpActor = actor;
    mParam = prm;
    start();
}

print_error_check_c::~print_error_check_c() {
    check();
}

void print_error_check_c::start() {
    mNumErrors = print_errors;

    if (mPrintDisable) {
        mReportDisable = __OSReport_disable;
        OSReportDisable();
    } else {
        mReportDisable = -1;
    }

    if (mPriorityMaximum > 0) {
        OSThread* currentThread = OSGetCurrentThread();
        mPriority = OSGetThreadPriority(currentThread);
        OSSetThreadPriority(currentThread, 0);
    } else {
        mPriority = -1;
    }

    mTick = OSGetTick();
}

void print_error_check_c::check() {
    /* Empty in non-debug builds */
}
#endif

/* 8002330C-800233C4       .text __ct__10fopAc_ac_cFv */
fopAc_ac_c::fopAc_ac_c() {
}

fopAc_ac_c::~fopAc_ac_c() {
}

int g_fopAc_type;
u32 fopAc_ac_c::stopStatus;

/* 80023514-80023540       .text fopAc_IsActor__FPv */
s32 fopAc_IsActor(void* pProc) {
    int actor_type = ((fopAc_ac_c*)pProc)->actor_type;
    return fpcBs_Is_JustOfType(g_fopAc_type, actor_type);
}

/* 80023540-8002362C       .text fopAc_Draw__FPv */
s32 fopAc_Draw(void* pProc) {
    fopAc_ac_c * actor = (fopAc_ac_c *)pProc;
    BOOL ret = TRUE;

    if (!dMenu_flag()) {
        s32 moveApproval = dComIfGp_event_moveApproval(actor);

        if (
            (
                moveApproval == dEvtMove_FORCE_e
                || (
                    !fopAcM_CheckStatus(actor, fopAc_ac_c::getStopStatus())
                    && !(
                        fopAcM_CheckStatus(actor, fopAcStts_CULL_e)
                        && fopAcM_cullingCheck(actor)
                    )
                )
            ) && !fopAcM_CheckStatus(actor, fopAcStts_NODRAW_e)
        ) {
            fopAcM_OffCondition(actor, fopAcCnd_NODRAW_e);
#if VERSION == VERSION_DEMO
            print_error_check_c sp08(actor, print_error_check_c::sDRAW);
#endif
            ret = fpcLf_DrawMethod((leafdraw_method_class*)actor->sub_method, actor);
        } else {
            fopAcM_OnCondition(actor, fopAcCnd_NODRAW_e);
        }

        fopAcM_OffStatus(actor, fopAcStts_NODRAW_e);

#if VERSION > VERSION_DEMO
        if (dComIfGp_roomControl_getStayNo() >= 0 && fopAcM_CheckStatus(actor, fopAcStts_SHOWMAP_e))
#endif
            dMap_drawActorPointMiniMap(actor);
    }

    return ret;
}

#define CHECK_FLOAT_CLASS(line, x) JUT_ASSERT(line, !(fpclassify(x) == 1));
#define CHECK_VEC3_RANGE(line, v) JUT_ASSERT(line, -1.0e32f < v.x && v.x < 1.0e32f && -1.0e32f < v.y && v.y < 1.0e32f && -1.0e32f < v.z && v.z < 1.0e32f)

/* 8002362C-80023BDC       .text fopAc_Execute__FPv */
BOOL fopAc_Execute(void* pProc) {
    fopAc_ac_c * actor = (fopAc_ac_c *)pProc;
    BOOL ret = TRUE;

#if VERSION > VERSION_DEMO
    CHECK_FLOAT_CLASS(0x27d, actor->current.pos.x);
    CHECK_FLOAT_CLASS(0x27e, actor->current.pos.y);
    CHECK_FLOAT_CLASS(0x27f, actor->current.pos.z);
    CHECK_VEC3_RANGE(0x286, actor->current.pos);
#endif

    if (fopAcM_CheckStatus(actor, fopAcStts_NOPAUSE_e) || (!dMenu_flag() && !dScnPly_ply_c::isPause())) {
        actor->eventInfo.beforeProc();

        s32 moveApproval = dComIfGp_event_moveApproval(actor);

        if (
            (
                moveApproval == dEvtMove_FORCE_e
                || (
                    (
                        moveApproval != dEvtMove_NOMOVE_e
                        && !fopAcM_CheckStatus(actor, fopAc_ac_c::getStopStatus())
                    )
                    && (
                        !fopAcM_CheckStatus(actor, fopAcStts_NOCULLEXEC_e)
                        || !fopAcM_CheckCondition(actor, fopAcCnd_NODRAW_e)
                    )
                )
            )
        ) {
            fopAcM_OffCondition(actor, fopAcCnd_NOEXEC_e);
            actor->old = actor->current;
#if VERSION == VERSION_DEMO
            print_error_check_c sp08(actor, print_error_check_c::sEXECUTE);
#endif
            ret = fpcMtd_Execute((process_method_class*)actor->sub_method, actor);
        } else {
            fopAcM_OnCondition(actor, fopAcCnd_NOEXEC_e);
        }

#if VERSION > VERSION_DEMO
        CHECK_FLOAT_CLASS(0x2b4, actor->current.pos.x);
        CHECK_FLOAT_CLASS(0x2b5, actor->current.pos.y);
        CHECK_FLOAT_CLASS(0x2b6, actor->current.pos.z);
        CHECK_VEC3_RANGE(0x2bd, actor->current.pos);
#endif
    }

    return ret;
}

/* 80023BDC-80023C30       .text fopAc_IsDelete__FPv */
BOOL fopAc_IsDelete(void* pProc) {
    fopAc_ac_c * actor = (fopAc_ac_c *)pProc;
    BOOL ret;
    {
#if VERSION == VERSION_DEMO
        print_error_check_c sp08(actor, print_error_check_c::sIS_DELETE);
#endif
        ret = fpcMtd_IsDelete((process_method_class*)actor->sub_method, actor);
    }
    if (ret == TRUE)
        fopDwTg_DrawQTo(&actor->draw_tag);
    return ret;
}

/* 80023C30-80023CD4       .text fopAc_Delete__FPv */
BOOL fopAc_Delete(void* pProc) {
    fopAc_ac_c * actor = (fopAc_ac_c *)pProc;
    BOOL ret;
    {
#if VERSION == VERSION_DEMO
        print_error_check_c sp08(actor, print_error_check_c::sDELETE);
#endif
        ret = fpcMtd_Delete((process_method_class*)actor->sub_method, actor);
    }
    if (ret == TRUE) {
        fopAcTg_ActorQTo(&actor->actor_tag);
        fopDwTg_DrawQTo(&actor->draw_tag);
        fopAcM_DeleteHeap(actor);
        dDemo_actor_c *pDemoActor = dComIfGp_demo_getActor(actor->demoActorID);
        if (pDemoActor != NULL)
            pDemoActor->setActor(NULL);
        mDoAud_seDeleteObject(&actor->eyePos);
        mDoAud_seDeleteObject(&actor->current.pos);
    }
    return ret;
}

/* 80023CD4-80023F78       .text fopAc_Create__FPv */
cPhs_State fopAc_Create(void* pProc) {
    fopAc_ac_c* actor = (fopAc_ac_c*)pProc;

    if (fpcM_IsFirstCreating(actor)) {
        actor_process_profile_definition* profile = (actor_process_profile_definition*)fpcM_GetProfile(pProc);
        actor->actor_type = fpcBs_MakeOfType(&g_fopAc_type);
        actor->sub_method = profile->sub_method;
        fopAcTg_Init(&actor->actor_tag, actor);
        fopAcTg_ToActorQ(&actor->actor_tag);
        fopDwTg_Init(&actor->draw_tag, actor);
        actor->actor_status = profile->status;
        actor->group = profile->group;
        actor->cullType = profile->cullType;

        fopAcM_prm_class* prm = fopAcM_GetAppend(actor);
        if (prm != NULL) {
            fopAcM_SetParam(actor, prm->base.parameters);
            actor->home.pos = prm->base.position;
            actor->home.angle = prm->base.angle;
            actor->shape_angle = prm->base.angle;
            actor->parentActorID = prm->parent_id;
            actor->subtype = prm->subtype;
            actor->gbaName = prm->gbaName;
            actor->scale.set(prm->scale.x * 0.1f, prm->scale.y * 0.1f, prm->scale.z * 0.1f);
            actor->setID = prm->base.setID;
            actor->home.roomNo = prm->room_no;
        }

        actor->old = actor->home;
        actor->current = actor->home;
        actor->eyePos = actor->home.pos;
        actor->maxFallSpeed = -100.0f;
        actor->attention_info.distances[fopAc_Attn_TYPE_MISC_e] = 1;
        actor->attention_info.distances[fopAc_Attn_TYPE_TALK_e] = 2;
        actor->attention_info.distances[fopAc_Attn_TYPE_BATTLE_e] = 3;
        actor->attention_info.distances[fopAc_Attn_TYPE_SPEAK_e] = 7;
        actor->attention_info.distances[fopAc_Attn_TYPE_CARRY_e] = 8;
        actor->attention_info.distances[fopAc_Attn_TYPE_SHIP_e] = 15;
        actor->attention_info.distances[fopAc_Attn_TYPE_DOOR_e] = 16;
        actor->attention_info.distances[fopAc_Attn_TYPE_TREASURE_e] = 16;
        actor->attention_info.position = actor->home.pos;
        dKy_tevstr_init(&actor->tevStr, actor->home.roomNo, 0xFF);
    }

    cPhs_State status = fpcMtd_Create((process_method_class*)actor->sub_method, actor);
    if (status == cPhs_COMPLEATE_e) {
        s32 priority = fpcLf_GetPriority(actor);
        fopDwTg_ToDrawQ(&actor->draw_tag, priority);
    }

    return status;
}

actor_method_class g_fopAc_Method = {
    (process_method_func)fopAc_Create,
    (process_method_func)fopAc_Delete,
    (process_method_func)fopAc_Execute,
    (process_method_func)fopAc_IsDelete,
    (process_method_func)fopAc_Draw,
};
