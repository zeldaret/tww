//
// Generated by dtk
// Translation Unit: m_Do_graphic.cpp
//

#include "m_Do/m_Do_graphic.h"
#include "d/d_com_inf_game.h"
#include "d/d_drawlist.h"
#include "d/d_meter.h"
#include "d/d_s_play.h"
#include "f_ap/f_ap_game.h"
#include "f_op/f_op_camera_mng.h"
#include "m_Do/m_Do_controller_pad.h"
#include "m_Do/m_Do_machine.h"
#include "m_Do/m_Do_main.h"
#include "m_Do/m_Do_mtx.h"
#include "m_Do/m_Do_printf.h"
#include "JSystem/J2DGraph/J2DOrthoGraph.h"
#include "JSystem/J2DGraph/J2DPrint.h"
#include "JSystem/JFramework/JFWDisplay.h"
#include "JSystem/JFramework/JFWSystem.h"
#include "JSystem/JKernel/JKRHeap.h"
#include "JSystem/JKernel/JKRSolidHeap.h"
#include "JSystem/JParticle/JPAEmitterManager.h"
#include "JSystem/JUtility/JUTAssert.h"
#include "JSystem/JUtility/JUTConsole.h"
#include "JSystem/JUtility/JUTDbPrint.h"
#include "JSystem/JUtility/JUTGamePad.h"
#include "JSystem/JUtility/JUTProcBar.h"
#include "JSystem/JUtility/JUTVideo.h"
#include "JSystem/JUtility/JUTXfb.h"
#include "dolphin/base/PPCArch.h"

JUTFader * mDoGph_gInf_c::mFader;
ResTIMG * mDoGph_gInf_c::mFrameBufferTimg;
GXTexObj mDoGph_gInf_c::mFrameBufferTexObj;
void * mDoGph_gInf_c::mFrameBufferTex;
GXTexObj mDoGph_gInf_c::mZbufferTexObj;
void * mDoGph_gInf_c::mZbufferTex;
u8 mDoGph_gInf_c::mCurrentHeap;
Mtx mDoGph_gInf_c::mBlureMtx;
bool mDoGph_gInf_c::mBlureFlag;
u8 mDoGph_gInf_c::mBlureRate;
u8 mDoGph_gInf_c::mFade;
f32 mDoGph_gInf_c::mFadeRate;
f32 mDoGph_gInf_c::mFadeSpeed;
bool mDoGph_gInf_c::mAutoForcus;
u8 mDoGph_gInf_c::mMonotone;
s16 mDoGph_gInf_c::mMonotoneRate;
s16 mDoGph_gInf_c::mMonotoneRateSpeed;

mDoGph_gInf_c g_mDoGph_graphicInfo;

OSThread mCaptureThread;
OSAlarm mCaptureTimeOutAlarm;
s16 mCaptureStep;
bool mCaptureCansel;
bool mCaptureEnableGXSetCopyFilter;
u8* mCaptureThreadStackHead;
u8* mCaptureCaptureBuffer;
u8* mCaptureTextureBuffer;
u32 mCaptureTextureSize;
u32 mCaptureCaptureSize;
GXDrawSyncCallback mCaptureOldCB;
OSThreadQueue mCaptureThreadQueue;
u64 mCaptureTimeOutTicks = OS_TIMER_CLOCK;

JKRHeap * mDoGph_gInf_c::mHeap[2] = {};
GXColor mDoGph_gInf_c::mBackColor = {};
GXColor mDoGph_gInf_c::mFadeColor = {};

/* 80007BBC-80007DDC       .text create__13mDoGph_gInf_cFv */
void mDoGph_gInf_c::create() {
    JFWDisplay::createManager(JKRHeap::getCurrentHeap(), JUTXfb::Double, true);
    JFWDisplay::getManager()->setDrawDoneMethod(JFWDisplay::Async);
    JUTFader* faderPtr = new JUTFader(0, 0, JUTVideo::getManager()->getRenderMode()->fb_width, JUTVideo::getManager()->getRenderMode()->efb_height, JUtility::TColor(0, 0, 0, 0));
    JUT_ASSERT(0x1a0, faderPtr != NULL);
    setFader(faderPtr);
    JFWDisplay::getManager()->setFader(faderPtr);
    JUTProcBar::getManager()->setVisibleHeapBar(false);
    JUTProcBar::getManager()->setVisible(false);
    JUTDbPrint::getManager()->setVisible(false);
    createHeap();

    u32 framebufferSize = GXGetTexBufferSize(320, 240, GX_TF_RGBA8, GX_FALSE, GX_FALSE) + 0x20;
    mFrameBufferTimg = (ResTIMG*) JKRAllocFromHeap(NULL, framebufferSize, 0x20);
    mFrameBufferTex = (void*)(&mFrameBufferTimg[1]);
    cLib_memSet(mFrameBufferTimg, 0, framebufferSize);
    mFrameBufferTimg->format = GX_TF_RGBA8;
    mFrameBufferTimg->alphaEnabled = false;
    mFrameBufferTimg->width = 320;
    mFrameBufferTimg->height = 240;
    mFrameBufferTimg->minFilter = GX_LINEAR;
    mFrameBufferTimg->magFilter = GX_LINEAR;
    mFrameBufferTimg->imageOffset = sizeof(ResTIMG);

    u32 zbufferSize = GXGetTexBufferSize(320, 240, GX_TF_IA8, GX_FALSE, GX_FALSE);
    mZbufferTex = JKRAllocFromHeap(NULL, zbufferSize, 0x20);
    cLib_memSet(mZbufferTex, 0, zbufferSize);

    J2DPrint::setBuffer(0x400);
    mBlureFlag = 0;
    mFade = 0;
    mBackColor = g_clearColor;
    mFadeColor = g_clearColor;
    VISetBlack(TRUE);
}

/* 80007DDC-80007EA8       .text createHeap__13mDoGph_gInf_cFv */
void mDoGph_gInf_c::createHeap() {
    JKRHeap* parentHeap = JKRHeap::getCurrentHeap();

    mHeap[0] = JKRSolidHeap::create(0x10000, parentHeap, false);
    JUT_ASSERT(0x1eb, mHeap[0] != NULL);

    mHeap[1] = JKRSolidHeap::create(0x10000, parentHeap, false);
    JUT_ASSERT(0x1ed, mHeap[1] != NULL);

    mCurrentHeap = 0;
}

/* 80007EA8-80007EE4       .text alloc__13mDoGph_gInf_cFUli */
void* mDoGph_gInf_c::alloc(u32 size, int align) {
    return mHeap[mCurrentHeap]->alloc(size, align);
}

/* 80007EE4-80007F1C       .text free__13mDoGph_gInf_cFv */
void mDoGph_gInf_c::free() {
    mHeap[mCurrentHeap ^= 1]->freeAll();
}

/* 80007F1C-80007F6C       .text fadeOut__13mDoGph_gInf_cFfR8_GXColor */
void mDoGph_gInf_c::fadeOut(f32 speed, GXColor& color) {
    mFade = true;
    mFadeSpeed = speed;
    mFadeColor = color;
    mFadeRate = speed >= 0.0f ? 0.0f : 1.0f;
}

/* 80007F6C-80007F94       .text onBlure__13mDoGph_gInf_cFv */
void mDoGph_gInf_c::onBlure() {
    onBlure(mDoMtx_getIdentity());
}

/* 80007F94-80007FC4       .text onBlure__13mDoGph_gInf_cFPA4_Cf */
void mDoGph_gInf_c::onBlure(const Mtx mtx) {
    mBlureFlag = true;
    mDoMtx_copy(mtx, mBlureMtx);
}

/* 80007FC4-80007FE8       .text fadeOut__13mDoGph_gInf_cFf */
void mDoGph_gInf_c::fadeOut(f32 speed) {
    fadeOut(speed, g_clearColor);
}

/* 80007FE8-800082D8       .text calcFade__13mDoGph_gInf_cFv */
void mDoGph_gInf_c::calcFade() {
    if (mFade) {
        mFadeRate += mFadeSpeed;
        if (mFadeRate < 0.0f) {
            mFadeRate = 0.0f;
            mFade = false;
        } else if (mFadeRate > 1.0f) {
            mFadeRate = 1.0f;
        }

        mFadeColor.a = mFadeRate * 255.0f;
    } else {
        if (dComIfG_getBrightness() != 0xFF) {
            mFadeColor.r = 0;
            mFadeColor.g = 0;
            mFadeColor.b = 0;
            mFadeColor.a = 0xFF - dComIfG_getBrightness();
        } else {
            mFadeColor.a = 0;
        }
    }

    if (mFadeColor.a != 0) {
        GXSetNumChans(1);
        GXSetChanCtrl(GX_COLOR0A0, false, GX_SRC_REG, GX_SRC_REG, 0, GX_DF_NONE, GX_AF_NONE);
        GXSetChanMatColor(GX_COLOR0A0, mFadeColor);
        GXSetNumTexGens(0);
        GXSetNumTevStages(1);
        GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD_NULL, GX_TEXMAP_NULL, GX_COLOR0A0);
        GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_RASC);
        GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_RASA);
        GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetZCompLoc(GX_TRUE);
        GXSetZMode(GX_FALSE, GX_ALWAYS, GX_FALSE);
        GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_OR);
        GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);
        GXSetFog(GX_FOG_NONE, 0.0f, 0.0f, 0.0f, 0.0f, g_clearColor);
        GXSetFogRangeAdj(GX_FALSE, 0, NULL);
        GXSetCullMode(GX_CULL_NONE);
        GXSetDither(GX_TRUE);
        GXSetNumIndStages(0);
        Mtx44 mtx;
        C_MTXOrtho(mtx, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 10.0f);
        GXSetProjection(mtx, GX_ORTHOGRAPHIC);
        GXLoadPosMtxImm(mDoMtx_getIdentity(), GX_PNMTX0);
        GXSetCurrentMtx(GX_PNMTX0);
        GXClearVtxDesc();
        GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S8, 0);
        GXBegin(GX_QUADS, GX_VTXFMT0, 4);
        GXPosition3s8(0, 0, -5);
        GXPosition3s8(1, 0, -5);
        GXPosition3s8(1, 1, -5);
        GXPosition3s8(0, 1, -5);
        GXEnd();
    }
}

/* 800082D8-80008314       .text onMonotone__13mDoGph_gInf_cFv */
void mDoGph_gInf_c::onMonotone() {
    mMonotone = true;
    mFrameBufferTimg->format = GX_TF_I8;
    dComIfGp_particle_swapFrameBufferTexture();
}

/* 80008314-80008354       .text offMonotone__13mDoGph_gInf_cFv */
void mDoGph_gInf_c::offMonotone() {
    mMonotone = false;
    mFrameBufferTimg->format = GX_TF_RGBA8;
    dComIfGp_particle_swapFrameBufferTexture();
}

/* 80008354-800083B8       .text calcMonotone__13mDoGph_gInf_cFv */
void mDoGph_gInf_c::calcMonotone() {
    if (cLib_chaseS(&mMonotoneRate, mMonotoneRateSpeed < 0 ? 400 : -600, abs(mMonotoneRateSpeed)) != 0 && mMonotoneRateSpeed > 0)
        offMonotone();
}

/* 800083B8-800083BC       .text mDoGph_BlankingON__Fv */
void mDoGph_BlankingON() {
}

/* 800083BC-800083C0       .text mDoGph_BlankingOFF__Fv */
void mDoGph_BlankingOFF() {
}

/* 800083C0-800083EC       .text dScnPly_BeforeOfPaint__Fv */
void dScnPly_BeforeOfPaint() {
    dComIfGd_reset();
}

/* 800083EC-80008410       .text mDoGph_BeforeOfDraw__Fv */
bool mDoGph_BeforeOfDraw() {
    dScnPly_BeforeOfPaint();
    return true;
}

/* 80008410-80008600       .text mDoGph_AfterOfDraw__Fv */
bool mDoGph_AfterOfDraw() {
    if (fapGmHIO_isMenu()) {
        JUTProcBar::getManager()->setVisible(false);
        JUTProcBar::getManager()->setVisibleHeapBar(false);
        JUTDbPrint::getManager()->setVisible(true);
    } else {
        BOOL consoleVisible = JFWSystem::getSystemConsole()->isVisible();
        BOOL pad3Connected = JUTGamePad::getPortStatus(JUTGamePad::Port_3).error == 0;
        BOOL procVisible = pad3Connected && fapGmHIO_getMeter() && !consoleVisible;
        BOOL printVisible = pad3Connected && fapGmHIO_isPrint();
        if (mDoMain::developmentMode == 0) {
            procVisible = FALSE;
            printVisible = FALSE;
        }
        JUTProcBar::getManager()->setVisible(procVisible);
        JUTProcBar::getManager()->setVisibleHeapBar(procVisible);
        JUTDbPrint::getManager()->setVisible(printVisible);
    }

    GXSetZCompLoc(GX_TRUE);
    GXSetZMode(GX_FALSE, GX_ALWAYS, GX_FALSE);
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_CLEAR);
    GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
    GXSetFog(GX_FOG_NONE, 0.0f, 0.0f, 0.0f, 0.0f, g_clearColor);
    GXSetFogRangeAdj(GX_FALSE, 0, NULL);
    GXSetCoPlanar(GX_FALSE);
    GXSetZTexture(GX_ZT_DISABLE, GX_TF_Z8, 0);
    GXSetDither(GX_TRUE);
    GXSetClipMode(GX_CLIP_ENABLE);
    GXSetCullMode(GX_CULL_NONE);
    mDoMch_render_c::setFbWidth(fapGmHIO_getFbWidth());
    mDoMch_render_c::setEfbHeight(fapGmHIO_getEfbHeight());
    JUTVideo::getManager()->setRenderMode(mDoMch_render_c::getRenderModeObj());
    dComIfGd_peekZdata();
    mDoGph_gInf_c::endFrame();
    return true;
}

/* 80008600-80008880       .text clearAlphaBuffer__FP10view_classUc */
void clearAlphaBuffer(view_class* view, u8 alpha) {
    GXSetNumChans(1);
    GXSetChanCtrl(GX_COLOR0A0, false, GX_SRC_REG, GX_SRC_REG, 0, GX_DF_NONE, GX_AF_NONE);
    GXSetNumTexGens(0);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD_NULL, GX_TEXMAP_NULL, GX_COLOR0A0);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_A0);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetZCompLoc(GX_TRUE);
    GXSetZMode(GX_FALSE, GX_ALWAYS, GX_FALSE);
    GXSetBlendMode(GX_BM_NONE, GX_BL_ZERO, GX_BL_ZERO, GX_LO_OR);
    GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);
    GXSetFog(GX_FOG_NONE, 0.0f, 0.0f, 0.0f, 0.0f, g_clearColor);
    GXSetFogRangeAdj(GX_FALSE, 0, NULL);
    GXSetCullMode(GX_CULL_NONE);
    GXSetDither(GX_TRUE);
    GXSetColorUpdate(GX_FALSE);
    GXSetAlphaUpdate(GX_TRUE);
    GXSetNumIndStages(0);
    GXColor color = { 0x00, 0x00, 0x00, 0x00 };
    color.a = alpha;
    GXSetTevColor(GX_TEVREG0, color);
    Mtx44 mtx;
    C_MTXOrtho(mtx, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 10.0f);
    GXSetProjection(mtx, GX_ORTHOGRAPHIC);
    GXLoadPosMtxImm(mDoMtx_getIdentity(), GX_PNMTX0);
    GXSetCurrentMtx(GX_PNMTX0);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S8, 0);
    GXBegin(GX_QUADS, GX_VTXFMT0, 4);
    GXPosition3s8(0, 0, -5);
    GXPosition3s8(1, 0, -5);
    GXPosition3s8(1, 1, -5);
    GXPosition3s8(0, 1, -5);
    GXEnd();
    GXSetColorUpdate(GX_TRUE);
    GXSetAlphaUpdate(GX_FALSE);
    GXSetProjection(view->mProjMtx, GX_PERSPECTIVE);
}

/* 80008880-80008B0C       .text drawAlphaBuffer__FP10view_class8_GXColor */
void drawAlphaBuffer(view_class* view, GXColor color) {
    GXSetNumChans(1);
    GXSetChanCtrl(GX_COLOR0A0, false, GX_SRC_REG, GX_SRC_REG, 0, GX_DF_NONE, GX_AF_NONE);
    GXSetChanMatColor(GX_COLOR0, color);
    GXSetNumTexGens(0);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD_NULL, GX_TEXMAP_NULL, GX_COLOR0A0);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_RASC);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetZCompLoc(GX_TRUE);
    GXSetZMode(GX_FALSE, GX_ALWAYS, GX_FALSE);
    GXSetBlendMode(GX_BM_BLEND, GX_BL_DST_ALPHA, GX_BL_ONE, GX_LO_OR);
    GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);
    GXSetFog(GX_FOG_NONE, 0.0f, 0.0f, 0.0f, 0.0f, g_clearColor);
    GXSetFogRangeAdj(GX_FALSE, 0, NULL);
    GXSetCullMode(GX_CULL_NONE);
    GXSetDstAlpha(GX_TRUE, 0);
    GXSetDither(GX_TRUE);
    GXSetColorUpdate(GX_TRUE);
    GXSetAlphaUpdate(GX_TRUE);
    GXSetNumIndStages(0);
    Mtx44 mtx;
    C_MTXOrtho(mtx, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 10.0f);
    GXSetProjection(mtx, GX_ORTHOGRAPHIC);
    GXLoadPosMtxImm(mDoMtx_getIdentity(), GX_PNMTX0);
    GXSetCurrentMtx(GX_PNMTX0);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S8, 0);
    GXBegin(GX_QUADS, GX_VTXFMT0, 4);
    GXPosition3s8(0, 0, -5);
    GXPosition3s8(1, 0, -5);
    GXPosition3s8(1, 1, -5);
    GXPosition3s8(0, 1, -5);
    GXEnd();
    GXSetColorUpdate(GX_TRUE);
    GXSetAlphaUpdate(GX_FALSE);
    GXSetDstAlpha(GX_FALSE, 0);
    GXSetProjection(view->mProjMtx, GX_PERSPECTIVE);
}

/* 80008B0C-80008F34       .text drawSpot__FP10view_class */
void drawSpot(view_class* view) {
    GXSetNumChans(1);
    GXSetChanCtrl(GX_COLOR0A0, false, GX_SRC_REG, GX_SRC_REG, 0, GX_DF_NONE, GX_AF_NONE);
    GXSetChanAmbColor(GX_COLOR0A0, g_clearColor);
    GXSetChanMatColor(GX_COLOR0A0, g_clearColor);
    GXSetNumTexGens(0);
    GXSetNumTevStages(1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD_NULL, GX_TEXMAP_NULL, GX_COLOR0A0);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_A0);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevColor(GX_TEVREG0, g_whiteColor);
    GXSetZCompLoc(GX_TRUE);
    GXSetZMode(GX_FALSE, GX_ALWAYS, GX_FALSE);
    GXSetBlendMode(GX_BM_BLEND, GX_BL_DST_ALPHA, GX_BL_ONE, GX_LO_OR);
    GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);
    GXSetFog(GX_FOG_NONE, 0.0f, 0.0f, 0.0f, 0.0f, g_clearColor);
    GXSetFogRangeAdj(GX_FALSE, 0, NULL);
    GXSetCullMode(GX_CULL_NONE);
    GXSetDither(GX_TRUE);
    GXSetColorUpdate(GX_FALSE);
    GXSetAlphaUpdate(GX_TRUE);
    Mtx44 mtx;
    C_MTXOrtho(mtx, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 10.0f);
    GXSetProjection(mtx, GX_ORTHOGRAPHIC);
    GXLoadPosMtxImm(mDoMtx_getIdentity(), GX_PNMTX0);
    GXSetCurrentMtx(GX_PNMTX0);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S8, 0);
    GXBegin(GX_QUADS, GX_VTXFMT0, 4);
    GXPosition3s8(0, 0, -5);
    GXPosition3s8(1, 0, -5);
    GXPosition3s8(1, 1, -5);
    GXPosition3s8(0, 1, -5);
    GXEnd();
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_RASA);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetBlendMode(GX_BM_BLEND, GX_BL_ONE, GX_BL_ONE, GX_LO_OR);
    GXBegin(GX_QUADS, GX_VTXFMT0, 4);
    GXPosition3s8(0, 0, -5);
    GXPosition3s8(1, 0, -5);
    GXPosition3s8(1, 1, -5);
    GXPosition3s8(0, 1, -5);
    GXEnd();
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_RASC);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetBlendMode(GX_BM_BLEND, GX_BL_DST_ALPHA, GX_BL_DST_ALPHA, GX_LO_OR);
    GXSetNumIndStages(0);
    GXSetColorUpdate(GX_TRUE);
    GXSetAlphaUpdate(GX_FALSE);
    GXBegin(GX_QUADS, GX_VTXFMT0, 4);
    GXPosition3s8(0, 0, -5);
    GXPosition3s8(1, 0, -5);
    GXPosition3s8(1, 1, -5);
    GXPosition3s8(0, 1, -5);
    GXEnd();
    GXSetProjection(view->mProjMtx, GX_PERSPECTIVE);
}

/* 80008F34-8000990C       .text drawDepth__FP10view_classP15view_port_classi */
void drawDepth(view_class* view, view_port_class* viewport, int depth) {
    /* Nonmatching */
    if (mDoGph_gInf_c::isAutoForcus()) {
        f32 projv[7];
        f32 viewv[6];
        f32 x, y, z;

        GXGetProjectionv(projv);
        GXGetViewportv(viewv);
        GXProject(view->mLookat.mCenter.x, view->mLookat.mCenter.y, view->mLookat.mCenter.z, view->mViewMtx, projv, viewv, &x, &y, &z);

        int temp = z * 0xFFFFFF;
        depth = (0xFF0000 - temp) >> 8;
        if (depth < -0x400) {
            temp = -0x400;
        } else {
            temp = -depth & ~depth;
            temp = ~(temp >> 31) & depth;
        }
        depth = temp;
    }

    static GXColorS10 l_tevColor0 = { 0, 0, 0, 0 };
    if (mDoGph_gInf_c::isMonotone()) {
        mDoGph_gInf_c::calcMonotone();
        l_tevColor0.a = mDoGph_gInf_c::mMonotoneRate;
    } else {
        dStage_FileList_dt_c * fili_p = NULL;
        s32 roomNo = dComIfGp_roomControl_getStayNo();
        if (roomNo >= 0)
            fili_p = dComIfGp_roomControl_getStatusRoomDt(roomNo)->getFileListInfo();

        if (fili_p == NULL) {
            if (!mDoGph_gInf_c::isAutoForcus()) {
                l_tevColor0.a = depth - g_envHIO.mOther.field_0x40;
            } else {
                s16 photoDepth = -g_envHIO.mOther.field_0x40;
                if (photoDepth > (s16)depth)
                    photoDepth = depth;
                l_tevColor0.a = photoDepth;
            }
        } else {
            if (!mDoGph_gInf_c::isAutoForcus()) {
                l_tevColor0.a = depth - dStage_FileList_dt_PhotoDepth(fili_p);
            } else {
                int photoDepth = -dStage_FileList_dt_PhotoDepth(fili_p);
                if (photoDepth > depth)
                    photoDepth = depth;
                l_tevColor0.a = photoDepth;
            }
        }
    }

    s16 x = (s16)viewport->mXOrig & ~0x07;
    s16 y = (s16)viewport->mYOrig & ~0x07;
    s16 y2 = (y < 0) ? 0 : y;
    s16 w = (s16)viewport->mWidth & ~0x07;
    s16 h = (s16)viewport->mHeight & ~0x07;

    char* zbuf = (char*)mDoGph_gInf_c::getZbufferTex();
    char* fbbuf = (char*)mDoGph_gInf_c::getFrameBufferTex();
    if (y < 0) {
        h += y;
        s16 hh = -y >> 1;
        zbuf += GXGetTexBufferSize(320, hh, GX_TF_IA8, GX_FALSE, 0);
        fbbuf += GXGetTexBufferSize(320, hh, mDoGph_gInf_c::getFrameBufferTimg()->format, GX_FALSE, 0);
    }
    y = y2;

    u16 hw = w >> 1;
    u16 hh = h >> 1;
    GXSetCopyFilter(GX_FALSE, NULL, GX_TRUE, JUTVideo::getManager()->getRenderMode()->vfilter);

    GXSetTexCopySrc(x, y, w, h);
    GXSetTexCopyDst(hw, hh, GX_TF_Z16, GX_TRUE);
    GXCopyTex(zbuf, GX_FALSE);

    GXSetTexCopySrc(x, y, w, h);
    GXSetTexCopyDst(hw, hh, (GXTexFmt)mDoGph_gInf_c::getFrameBufferTimg()->format, GX_TRUE);
    GXCopyTex(fbbuf, GX_FALSE);

    GXInitTexObj(mDoGph_gInf_c::getZbufferTexObj(), zbuf, w, h, GX_TF_IA8, GX_CLAMP, GX_CLAMP, GX_FALSE);
    GXInitTexObjLOD(mDoGph_gInf_c::getZbufferTexObj(), GX_NEAR, GX_NEAR, 0.0f, 0.0f, 0.0f, GX_FALSE, GX_FALSE, GX_ANISO_1);

    GXInitTexObj(mDoGph_gInf_c::getFrameBufferTexObj(), fbbuf, w, h, (GXTexFmt)mDoGph_gInf_c::getFrameBufferTimg()->format, GX_CLAMP, GX_CLAMP, GX_FALSE);
    GXInitTexObjLOD(mDoGph_gInf_c::getFrameBufferTexObj(), GX_LINEAR, GX_LINEAR, 0.0f, 0.0f, 0.0f, GX_FALSE, GX_FALSE, GX_ANISO_1);
    GXPixModeSync();
    GXLoadTexObj(mDoGph_gInf_c::getFrameBufferTexObj(), GX_TEXMAP1);
    GXLoadTexObj(mDoGph_gInf_c::getZbufferTexObj(), GX_TEXMAP0);
    GXSetNumChans(0);
    GXSetNumTexGens(2);                         
    GXSetTexCoordGen2(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY, GX_FALSE, GX_PTIDENTITY);
    GXSetTexCoordGen2(GX_TEXCOORD1, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY, GX_FALSE, GX_PTIDENTITY);
    GXSetNumTevStages(3);                                  
    GXSetTevColorS10(GX_TEVREG0, l_tevColor0);
    GXSetTevSwapModeTable(GX_TEV_SWAP3, GX_CH_ALPHA, GX_CH_GREEN, GX_CH_BLUE, GX_CH_RED);
    GXSetTevSwapMode(GX_TEVSTAGE0, GX_TEV_SWAP0, GX_TEV_SWAP3);
    GXSetTevKAlphaSel(GX_TEVSTAGE0, GX_TEV_KASEL_1);
    GXSetTevKAlphaSel(GX_TEVSTAGE2, GX_TEV_KASEL_1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_KONST, GX_CA_TEXA, GX_CA_KONST, GX_CA_ZERO);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_COMP_RGB8_EQ, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE1, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE1, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE1, GX_CA_ZERO, GX_CA_APREV, GX_CA_TEXA, GX_CA_A0);
    GXSetTevAlphaOp(GX_TEVSTAGE1, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_4, GX_TRUE, GX_TEVPREV);
    GXSetTevOrder(GX_TEVSTAGE2, GX_TEXCOORD1, GX_TEXMAP1, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE2, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_TEXC);
    GXSetTevColorOp(GX_TEVSTAGE2, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE2, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_APREV);
    GXSetTevAlphaOp(GX_TEVSTAGE2, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetZCompLoc(GX_TRUE);
    GXSetZMode(GX_FALSE, GX_ALWAYS, GX_FALSE);
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_CLEAR);
    GXSetAlphaCompare(GX_GREATER, 0, GX_AOP_OR, GX_GREATER, 0);
    GXSetFog(GX_FOG_NONE, 0.0f, 0.0f, 0.0f, 0.0f, g_clearColor);
    GXSetCullMode(GX_CULL_NONE);
    GXSetDither(GX_TRUE);
    GXSetNumIndStages(0);
    Mtx44 mtx;
    C_MTXOrtho(mtx, viewport->mYOrig, viewport->mYOrig + viewport->mHeight, viewport->mXOrig, viewport->mXOrig + viewport->mWidth, 0.0, 10.0f);
    GXSetProjection(mtx, GX_ORTHOGRAPHIC);
    GXLoadPosMtxImm(mDoMtx_getIdentity(), GX_PNMTX0);
    GXSetCurrentMtx(GX_PNMTX0);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S8, 0);

    GXBegin(GX_QUADS, GX_VTXFMT0, 4);
        GXPosition3s16(x, y, -5);
        GXTexCoord2s8(0, 0);

        GXPosition3s16(w, y, -5);
        GXTexCoord2s8(1, 0);

        GXPosition3s16(w, h, -5);
        GXTexCoord2s8(1, 1);

        GXPosition3s16(x, h, -5);
        GXTexCoord2s8(0, 1);
    GXEnd();

    GXSetTevSwapModeTable(GX_TEV_SWAP3, GX_CH_BLUE, GX_CH_BLUE, GX_CH_BLUE, GX_CH_ALPHA);
    GXSetTevSwapMode(GX_TEVSTAGE0, GX_TEV_SWAP0, GX_TEV_SWAP0);

    if (y == 0) {
        s16 h = (s16)viewport->mScissor.mYOrig;
        if (h != 0) {
            h += (f32)viewport->mScissor.mHeight;
            GXSetNumChans(1);
            GXSetChanCtrl(GX_ALPHA0, false, GX_SRC_REG, GX_SRC_REG, 0, GX_DF_NONE, GX_AF_NONE);
            GXSetNumTexGens(0);
            GXSetNumTevStages(1);
            GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD_NULL, GX_TEXMAP_NULL, GX_COLOR0A0);
            GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO);
            GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
            GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO);
            GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
            GXSetBlendMode(GX_BM_NONE, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_CLEAR);
            GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);
            GXClearVtxDesc();
            GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
            GXBegin(GX_QUADS, GX_VTXFMT0, 8);
                GXPosition3s16(0, 0, -5);
                GXPosition3s16(640, 0, -5);
                GXPosition3s16(640, y, -5);
                GXPosition3s16(0, y, -5);

                GXPosition3s16(0, h, -5);
                GXPosition3s16(640, h, -5);
                GXPosition3s16(640, 480, -5);
                GXPosition3s16(0, 480, -5);
            GXEnd();
        }
    }

    GXSetScissor(viewport->mScissor.mXOrig, viewport->mScissor.mYOrig, viewport->mScissor.mWidth, viewport->mScissor.mHeight);
    GXSetProjection(view->mProjMtx, GX_PERSPECTIVE);
}

/* 80009914-80009BBC       .text motionBlure__FP10view_class */
void motionBlure(view_class* view) {
    if (mDoGph_gInf_c::isBlure()) {
        GXLoadTexObj(mDoGph_gInf_c::getFrameBufferTexObj(), GX_TEXMAP0);
        GXColor color;
        color.a = mDoGph_gInf_c::getBlureRate();
        GXSetNumChans(0);
        GXSetNumTexGens(1);
        GXSetTexCoordGen2(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_TEXMTX0, GX_FALSE, GX_PTIDENTITY);
        GXLoadTexMtxImm(mDoGph_gInf_c::getBlureMtx(), GX_TEXMTX0, GX_MTX2x4);
        GXSetNumTevStages(1);
        GXSetTevColor(GX_TEVREG0, color);
        GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
        GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_TEXC);
        GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_A0);
        GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
        GXSetZCompLoc(GX_TRUE);
        GXSetZMode(GX_FALSE, GX_ALWAYS, GX_FALSE);
        GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_CLEAR);
        GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);
        GXSetFog(GX_FOG_NONE, 0.0f, 0.0f, 0.0f, 0.0f, g_clearColor);
        GXSetCullMode(GX_CULL_NONE);
        GXSetDither(GX_TRUE);
        Mtx44 mtx;
        C_MTXOrtho(mtx, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 10.0f);
        GXSetProjection(mtx, GX_ORTHOGRAPHIC);
        GXLoadPosMtxImm(mDoMtx_getIdentity(), GX_PNMTX0);
        GXSetCurrentMtx(GX_PNMTX0);
        GXClearVtxDesc();
        GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
        GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S8, 0);
        GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S8, 0);
        GXBegin(GX_QUADS, GX_VTXFMT0, 4);
        GXPosition3s8(0, 0, -5);
        GXTexCoord2s8(0, 0);
        GXPosition3s8(1, 0, -5);
        GXTexCoord2s8(1, 0);
        GXPosition3s8(1, 1, -5);
        GXTexCoord2s8(1, 1);
        GXPosition3s8(0, 1, -5);
        GXTexCoord2s8(0, 1);
        GXEnd();
        GXSetProjection(view->mProjMtx, GX_PERSPECTIVE);
    }
}

u8 mCaptureDraw = 1;
u8 mCaptureTextureFormat = GX_TF_CMPR;
u8 mCaptureCaptureFormat = GX_TF_RGB565;
u8 mCaptureSizeWidth = 152;
u8 mCaptureSizeHeight = 104;
s16 mCaptureCenterX = 320;
s16 mCaptureCenterY = 180;
GXColor mCaptureMonoColor0 = { 0x00, 0x00, 0x00, 0x00 };
GXColor mCaptureMonoColor1 = { 0xFF, 0xFF, 0xFF, 0xFF };
u32 mCaptureThreadStackSize = 0x2000;
u32 mCaptureThreadPriority = 30;

/* 80009BBC-80009BE0       .text mCaptureAlarmHandler__FP7OSAlarmP9OSContext */
void mCaptureAlarmHandler(OSAlarm*, OSContext*) {
    OSWakeupThread(&mCaptureThreadQueue);
}

/* 80009BE0-80009BE8       .text mDoGph_setCaptureStep__Fs */
void mDoGph_setCaptureStep(s16 step) {
    mCaptureStep = step;
}

/* 80009BE8-80009BF0       .text mDoGph_getCaptureStep__Fv */
s16 mDoGph_getCaptureStep() {
    return mCaptureStep;
}

/* 80009BF0-80009BF8       .text mDoGph_getCaptureTextureBuffer__Fv */
void* mDoGph_getCaptureTextureBuffer() {
    return mCaptureTextureBuffer;
}

/* 80009BF8-80009C00       .text mDoGph_setCaptureTextureFormat__FUc */
void mDoGph_setCaptureTextureFormat(u8 fmt) {
    mCaptureTextureFormat = fmt;
}

/* 80009C00-80009C08       .text mDoGph_setCaptureCaptureFormat__FUc */
void mDoGph_setCaptureCaptureFormat(u8 fmt) {
    mCaptureCaptureFormat = fmt;
}

/* 80009C08-80009C38       .text mDoGph_CaptureCansel__Fv */
void mDoGph_CaptureCansel() {
    if (mCaptureStep < 0) {
        mCaptureStep = 0;
        mCaptureCansel = false;
    } else if (mCaptureStep != 0) {
        mCaptureCansel = true;
    }
}

#define COLOR_SQUARE_MAG(r0, g0, b0, r1, g1, b1) (r0 - r1)*(r0 - r1) + (g0 - g1)*(g0 - g1) + (b0 - b1)*(b0 - b1)

/* 80009C38-8000A180       .text blockenc__FPUc */
void blockenc(u8* block) {
    /* Nonmatching */
    u8 colors[16*3]; // sp18
    u32 color_mags[4]; // sp08
    u32 pix_idx;
    u32 color_num = 0; // r11
    u32 i = 0; // r8
    pix_idx = 0; // r10
    for (; i < 0x30; i += 3, pix_idx += 4) {
        u32 r9 = 0; // r9
        u8* pix = &block[pix_idx];
        for (int j = 0; j < color_num; j++) {
            u8* temp = &colors[r9*3];
            if (temp[0] == pix[0] && temp[1] == pix[1] && temp[2] == pix[2]) {
                break;
            }
            r9++;
        }
        if (r9 == color_num) {
            colors[r9*3 + 0] = pix[0];
            colors[r9*3 + 1] = pix[1];
            colors[r9*3 + 2] = pix[2];
            color_num += 1;
        }
    }
    
    u32 color_0_idx = 0; // r17
    u32 color_1_idx = 0; // r16
    if (color_num > 1) {
        u32 r23 = 0;
        u32 r18 = INT32_MAX;
        for (; r23 < color_num*3 - 3; r23 += 3) {
            u32 r0 = colors[r23+0] * 30;
            u32 g0 = colors[r23+1] * 59;
            u32 b0 = colors[r23+2] * 11;
            for (u32 r21 = r23+3; r21 < color_num*3 - 3; r21 += 3) {
                u32 r1 = colors[r21+0] * 30;
                u32 g1 = colors[r21+1] * 59;
                u32 b1 = colors[r21+2] * 11;
                u32 r20 = 0; // r20
                u32 pix_idx = 0; // r19
                u32 r22 = 0; // r22
                for (; r22 < 0x10; r22++, pix_idx += 4) {
                    // u32 b2 = block[pix_idx + 2] * 11;
                    // u32 r2 = block[pix_idx + 0] * 30;
                    // u32 g2 = block[pix_idx + 1] * 59;
                    color_mags[0] = COLOR_SQUARE_MAG(r0, g0, b0, block[pix_idx+0] * 30, block[pix_idx+1] * 59, block[pix_idx+2] * 11);
                    color_mags[1] = COLOR_SQUARE_MAG(r1, g1, b1, block[pix_idx+0] * 30, block[pix_idx+1] * 59, block[pix_idx+2] * 11);
                    u32 r3 = (r0 * 5 + r1 * 3) / 8;
                    u32 g3 = (g0 * 5 + g1 * 3) / 8;
                    u32 b3 = (b0 * 5 + b1 * 3) / 8;
                    color_mags[2] = COLOR_SQUARE_MAG(r3, g3, b3, block[pix_idx+0] * 30, block[pix_idx+1] * 59, block[pix_idx+2] * 11);
                    u32 r4 = (r1 * 5 + r0 * 3) / 8;
                    u32 g4 = (g1 * 5 + g0 * 3) / 8;
                    u32 b4 = (b1 * 5 + b0 * 3) / 8;
                    color_mags[3] = COLOR_SQUARE_MAG(r4, g4, b4, block[pix_idx+0] * 30, block[pix_idx+1] * 59, block[pix_idx+2] * 11);
                    
                    u32 r5 = 0;
                    u32 r6 = INT32_MAX;
                    for (; r5 < ARRAY_SIZE(color_mags); r5++) {
                        if (color_mags[r5] < r6) {
                            r6 = color_mags[r5];
                        }
                    }
                    
                    r20 += r6;
                }
                
                if (r20 < r18) {
                    r18 = r20;
                    color_0_idx = r23;
                    color_1_idx = r21;
                }
            }
        }
    }
    
    u32 r11 = (colors[color_0_idx + 0] & 0xF8) << 8 |
              (colors[color_0_idx + 1] & 0xFC) << 3 |
              (colors[color_0_idx + 2] & 0xF8) >> 3;
    u32 r4  = (colors[color_1_idx + 0] & 0xF8) << 8 |
              (colors[color_1_idx + 1] & 0xFC) << 3 |
              (colors[color_1_idx + 2] & 0xF8) >> 3;
    if (r11 < r4) {
        u32 temp = r11;
        r11 = r4;
        r4 = temp;
    } else if (r11 == r4) {
        r4 = 0;
    }
    block[0x40] = r11 >> 8;
    block[0x41] = r11 & 0xFF;
    block[0x42] = r4 >> 8;
    block[0x43] = r4 & 0xFF;
    
    u32 r0 = ((r11 >> 8) & 0xF8) * 30;
    u32 g0 = ((r11 >> 3) & 0xFC) * 59;
    u32 b0 = ((r11 << 3) & 0xFC) * 11;
    u32 r1 = ((r4 >> 8) & 0xF8) * 30;
    u32 g1 = ((r4 >> 3) & 0xFC) * 59;
    u32 b1 = ((r4 << 3) & 0xFC) * 11;
    u32 r6 = 30; // r6 (bit offset within r8)
    u32 r8 = 0; // r8 (bitfield of color indexes)
    for (pix_idx = 0; pix_idx < 0x40; pix_idx += 4) {
        // u32 b2 = block[pix_idx + 2] * 11;
        // u32 r2 = block[pix_idx + 0] * 30;
        // u32 g2 = block[pix_idx + 1] * 59;
        color_mags[0] = COLOR_SQUARE_MAG(r0, g0, b0, block[pix_idx+0] * 30, block[pix_idx+1] * 59, block[pix_idx+2] * 11);
        color_mags[1] = COLOR_SQUARE_MAG(r1, g1, b1, block[pix_idx+0] * 30, block[pix_idx+1] * 59, block[pix_idx+2] * 11);
        u32 r3 = (r0 * 5 + r1 * 3) / 8;
        u32 g3 = (g0 * 5 + g1 * 3) / 8;
        u32 b3 = (b0 * 5 + b1 * 3) / 8;
        color_mags[2] = COLOR_SQUARE_MAG(r3, g3, b3, block[pix_idx+0] * 30, block[pix_idx+1] * 59, block[pix_idx+2] * 11);
        u32 r4 = (r1 * 5 + r0 * 3) / 8;
        u32 g4 = (g1 * 5 + g0 * 3) / 8;
        u32 b4 = (b1 * 5 + b0 * 3) / 8;
        color_mags[3] = COLOR_SQUARE_MAG(r4, g4, b4, block[pix_idx+0] * 30, block[pix_idx+1] * 59, block[pix_idx+2] * 11);
        
        u32 r5 = 0;
        u32 r24;
        u32 r25 = INT32_MAX;
        for (; r5 < ARRAY_SIZE(color_mags); r5++) {
            if (color_mags[r5] < r25) {
                r25 = color_mags[r5];
                r24 = r5;
            }
        }
        
        r8 |= (r24 & 0x03) << r6;
        r6 -= 2;
    }
    
    block[0x44] = r8 >> 24;
    block[0x45] = r8 >> 16;
    block[0x46] = r8 >> 8;
    block[0x47] = r8 & 0xFF;
}

/* 8000A180-8000A530       .text encode_s3tc__FPUcPUcii9_GXTexFmt */
u32 encode_s3tc(u8* r25, u8* r26, int r27, int r28, GXTexFmt fmt) {
    /* Nonmatching */
    // params: capture_buffer, texture_buffer, width, height, fmt
    u8 block[0x40 + 0x8]; // sp08;
    u32 r31 = 0;
    if (fmt == GX_TF_I8) {
        u32 i8low = 255; // r30
        u32 i8high = 0; // r29
        for (int r18 = 0; r18 < r28; r18 += 8) {
            for (int r19 = 0, r24 = 0; r19 < r27; r19 += 8, r24 += 0x20) {
                for (int r20 = 0; r20 < 8; r20 += 4) {
                    int r21 = 0;
                    u32 r23 = r24 + r27 * (r18 + r20);
                    for (; r21 < 8; r21 += 4) {
                        u32 r5 = 0;
                        int r3 = 0;
                        u32 r10 = r21 + r23;
                        for (; r3 < 4; r3++) {
                            u32 r4 = r3*8 + r10;
                            u32 r9 = 219;
                            u32 r8 = 255; // r8 (alpha)
                            u8* r7 = &r25[r4];
                            for (int i = 0; i < 4; r5++, i++) {
                                u32 r11 = r7[i];
                                if (i8low > r11) {
                                    i8low = r11;
                                }
                                if (i8high < r11) {
                                    i8high = r11;
                                }
                                u32 r0 = ((r11 - 16) * 255) / r9;
                                block[r5*4+0] = r0 & 0xF8;
                                block[r5*4+1] = r0 & 0xFC;
                                block[r5*4+2] = r0 & 0xF8;
                                block[r5*4+3] = r8;
                            }
                        }
                        blockenc(block);
                        memcpy(&r26[r31], &block[0x40], 8);
                        r31 += 8;
                    }
                }
            }
        }
        JUT_ASSERT(0x8A7, 16 <= i8low && i8high <= 235);
    } else if (fmt == GX_TF_RGB565) {
        for (int r24 = 0; r24 < r28; r24 += 8) {
            for (int r29 = 0; r29 < r27; r29 += 8) {
                for (int r30 = 0; r30 < 8; r30 += 4) {
                    int r21 = 0;
                    u32 r22 = 2 * (r27 * (r24 + r30));
                    for (; r21 < 8; r21 += 4) {
                        u32 r8 = 0;
                        int r9 = 0;
                        // u32 r3 = 0;
                        u32 r6 = r22 + 8 * (r29 + r21);
                        u32 r5 = 255; // r5 (alpha)
                        for (; r9 < 4; r9++) {//, r3 += 8) {
                            u32 r10 = r9*8 + r6;
                            u16* r4 = (u16*)&r25[r10];
                            for (int i = 0; i < 4; i++, r8++, r10 += 2, r4++) {
                                u32 r11 = *r4;
                                block[r8*4+0] = (r11 >> 8) & 0xF8;
                                block[r8*4+1] = (r11 >> 3) & 0xFC;
                                block[r8*4+2] = (r11 << 3) & 0xF8;
                                block[r8*4+3] = r5;
                            }
                        }
                        blockenc(block);
                        memcpy(&r26[r31], &block[0x40], 8);
                        r31 += 8;
                    }
                }
            }
        }
    } else if (fmt == GX_TF_RGBA8) {
        for (int r24 = 0; r24 < r28; r24 += 8) {
            for (int r29 = 0; r29 < r27; r29 += 8) {
                for (int r30 = 0; r30 < 8; r30 += 4) {
                    int r21 = 0;
                    u32 r22 = 4 * (r27 * (r24 + r30));
                    for (; r21 < 8; r21 += 4) {
                        u32 r4 = 0;
                        for (int r5 = 0; r5 < 4; r5++) {
                            u32 r6 = r5 * 8 + r22 + 16 * (r29 + r21);
                            u32 r7 = r6 + 0x20;
                            u32 r9 = 255; // r9 (alpha)
                            for (int i = 0; i < 4; i++, r4++, r6 += 2, r7 += 2) {
                                u8* r3 = &r25[r6];
                                block[r4*4+0] = r3[1] & 0xF8;
                                u8* r12 = &r25[r7];
                                block[r4*4+1] = r12[0] & 0xFC;
                                block[r4*4+2] = r12[1] & 0xF8;
                                block[r4*4+3] = r3[0];
                                block[r4*4+3] = r9;
                            }
                        }
                        blockenc(block);
                        memcpy(&r26[r31], &block[0x40], 8);
                        r31 += 8;
                    }
                }
            }
        }
    }
    return r31;
}

/* 8000A530-8000A744       .text setUpRectangle__Fv */
void setUpRectangle() {
    GXSetNumChans(0);
    GXSetNumTexGens(1);
    GXSetTexCoordGen2(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY, GX_FALSE, GX_PTIDENTITY);
    GXSetNumTevStages(1);
    GXSetTevColor(GX_TEVREG0, mCaptureMonoColor0);
    GXSetTevColor(GX_TEVREG1, mCaptureMonoColor1);
    GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);
    GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C0, GX_CC_C1, GX_CC_TEXC, GX_CC_ZERO);
    GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_KONST);
    GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
    GXSetZCompLoc(GX_TRUE);
    GXSetZMode(GX_FALSE, GX_ALWAYS, GX_FALSE);
    GXSetBlendMode(GX_BM_BLEND, GX_BL_SRC_ALPHA, GX_BL_INV_SRC_ALPHA, GX_LO_COPY);
    GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);
    GXSetFog(GX_FOG_NONE, 0.0f, 0.0f, 0.0f, 0.0f, g_clearColor);
    GXSetClipMode(GX_CLIP_DISABLE);
    GXSetCullMode(GX_CULL_NONE);
    GXSetDither(GX_TRUE);
    GXSetNumIndStages(0);
    GXSetTevDirect(GX_TEVSTAGE0);
    Mtx44 mtx;
    C_MTXOrtho(mtx, -21.0f, 503.0f, -9.0f, 650.0f, 0.0f, 10.0f);
    GXSetProjection(mtx, GX_ORTHOGRAPHIC);
    GXLoadPosMtxImm(mDoMtx_getIdentity(), GX_PNMTX0);
    GXSetCurrentMtx(GX_PNMTX0);
    GXClearVtxDesc();
    GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
    GXSetVtxDesc(GX_VA_TEX0, GX_DIRECT);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
    GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_S8, 0);
}

/* 8000A744-8000A7F0       .text drawRectangle__Fiiii */
void drawRectangle(int x0, int y0, int x1, int y1) {
    GXBegin(GX_QUADS, GX_VTXFMT0, 4);
    GXPosition3s16(x0, y0, -5);
    GXTexCoord2s8(0, 0);
    GXPosition3s16(x1, y0, -5);
    GXTexCoord2s8(1, 0);
    GXPosition3s16(x1, y1, -5);
    GXTexCoord2s8(1, 1);
    GXPosition3s16(x0, y1, -5);
    GXTexCoord2s8(0, 1);
    GXEnd();
}

/* 8000A7F0-8000A8B8       .text mDoGph_allocFromAny__FUli */
u8* mDoGph_allocFromAny(u32 size, int align) {
    void* mem = JKRAllocFromHeap(mDoExt_getZeldaHeap(), size, align);
    if (mem == NULL)
        mem = JKRAllocFromHeap(mDoExt_getGameHeap(), size, align);
    if (mem == NULL)
        mem = JKRAllocFromHeap(mDoExt_getArchiveHeap(), size, align);
    if (mem == NULL)
        mem = JKRAllocFromSysHeap(size, align);
    if (mem == NULL)
        mem = mDoGph_gInf_c::getZbufferTex();
    memset(mem, 0, size);
    return (u8*)mem;
}

/* 8000A8B8-8000AAC4       .text mDoGph_screenCaptureDraw__Fv */
void mDoGph_screenCaptureDraw() {
    s32 sizeW = mCaptureSizeWidth;
    s32 sizeH = mCaptureSizeHeight;
    s32 sizeW_double = sizeW * 2;
    s32 sizeH_double = sizeH * 2;
    s32 sizeW_half = sizeW / 2;
    s32 sizeH_half = sizeH / 2;
    s32 centerX = mCaptureCenterX;
    s32 centerY = mCaptureCenterY;

    f32 projv[7];
    f32 viewv[6];
    u32 left, top, width, height;
    GXTexObj texObj;

    GXGetProjectionv(projv);
    GXGetViewportv(viewv);
    GXGetScissor(&left, &top, &width, &height);
    GXSetViewport(0.0f, 0.0f, 640.0f, 480.0f, 0.0f, 1.0f);
    setUpRectangle();

    if (mCaptureCaptureBuffer != NULL) {
        GXInitTexObj(&texObj, mCaptureCaptureBuffer, sizeW, sizeH, (GXTexFmt)mCaptureCaptureFormat, GX_CLAMP, GX_CLAMP, GX_FALSE);
    } else if (mCaptureTextureBuffer != NULL) {
        GXInitTexObj(&texObj, mCaptureTextureBuffer, sizeW, sizeH, (GXTexFmt)mCaptureTextureFormat, GX_CLAMP, GX_CLAMP, GX_FALSE);
    } else {
        goto out;
    }

    GXLoadTexObj(&texObj, GX_TEXMAP0);

    if (mCaptureDraw == 1) {
        drawRectangle(centerX - sizeW, centerY - sizeH, centerX + sizeW, centerY + sizeH);
    } else if (mCaptureDraw == 2) {
        drawRectangle(centerX - sizeW_half, centerY - sizeH_half, centerX + sizeW_half, centerY + sizeH_half);
    } else if (mCaptureDraw == 3) {
        drawRectangle(centerX - sizeW_double, centerY - sizeH_double, centerX + sizeW_double, centerY + sizeH_double);
    } else if (mCaptureDraw == 4) {
        drawRectangle(centerX - sizeW, centerY - sizeH, centerX, centerY);
        drawRectangle(centerX, centerY - sizeH, centerX + sizeW, centerY);
        drawRectangle(centerX - sizeW, centerY, centerX, centerY + sizeH);
        drawRectangle(centerX, centerY, centerX + sizeW, centerY + sizeH);
    }

out:
    GXSetProjectionv(projv);
    GXSetViewport(viewv[0], viewv[1], viewv[2], viewv[3], viewv[4], viewv[5]);
    GXSetScissor(left, top, width, height);
    GXSetClipMode(GX_CLIP_ENABLE);
}

/* 8000AAC4-8000AB1C       .text mCaptureProc__FPv */
void* mCaptureProc(void* thd) {
    encode_s3tc(mCaptureCaptureBuffer, mCaptureTextureBuffer, mCaptureSizeWidth, mCaptureSizeHeight, (GXTexFmt)mCaptureCaptureFormat);
    DCStoreRange(mCaptureTextureBuffer, mCaptureTextureSize);
    OSExitThread(thd);
    return thd;
}

/* 8000AB1C-8000ABC4       .text mCaptureGXDrawSyncCallback__FUs */
void mCaptureGXDrawSyncCallback(u16) {
    OSCancelAlarm(&mCaptureTimeOutAlarm);
    BOOL interrupt = OSDisableInterrupts();
    if (mCaptureStep == 2) {
        void* oldcb = (void*)GXSetDrawSyncCallback(mCaptureOldCB);
        JUT_ASSERT(0xa5f, oldcb == mCaptureGXDrawSyncCallback);
        mCaptureOldCB = NULL;
        mCaptureStep++;
    }
    OSRestoreInterrupts(interrupt);
}

/* 8000ABC4-8000AC3C       .text mCaptureGXDrawSyncTimeOut__FP7OSAlarmP9OSContext */
void mCaptureGXDrawSyncTimeOut(OSAlarm*, OSContext*) {
    OSReport_Error("キャプチャタイムアウト\n");
    mCaptureGXDrawSyncCallback(0);
    if (mCaptureCaptureBuffer != NULL) {
        JKRFreeToHeap(NULL, mCaptureCaptureBuffer);
        mCaptureCaptureBuffer = NULL;
    }
    if (mCaptureTextureBuffer != NULL) {
        JKRFreeToHeap(NULL, mCaptureTextureBuffer);
        mCaptureTextureBuffer = NULL;
    }
    mCaptureStep = -1;
}

/* 8000AC3C-8000AEA4       .text mDoGph_screenCapture__Fv */
bool mDoGph_screenCapture() {
    s32 sizeW = mCaptureSizeWidth;
    s32 sizeH = mCaptureSizeHeight;
    s32 sizeW2 = sizeW << 1;
    s32 sizeH2 = sizeH << 1;
    s32 centerX = mCaptureCenterX;
    s32 centerY = mCaptureCenterY;

    f32 projv[7];
    f32 viewv[6];
    u32 left, top, width, height;

    mCaptureTextureSize = GXGetTexBufferSize(sizeW, sizeH, mCaptureTextureFormat, GX_FALSE, 0);
    mCaptureTextureBuffer = mDoGph_allocFromAny(mCaptureTextureSize, 0x20);
    if (mCaptureTextureBuffer == NULL) {
        mCaptureStep = -1;
        return false;
    }

    if (mCaptureTextureFormat == GX_TF_CMPR) {
        mCaptureCaptureSize = GXGetTexBufferSize(sizeW, sizeH, mCaptureCaptureFormat, GX_FALSE, 0);
        mCaptureCaptureBuffer = mDoGph_allocFromAny(mCaptureCaptureSize, 0x20);
        if (mCaptureCaptureBuffer == NULL) {
            JKRFreeToHeap(NULL, mCaptureTextureBuffer);
            mCaptureTextureBuffer = NULL;
            mCaptureStep = -1;
            return false;
        }
    } else {
        mCaptureCaptureFormat = mCaptureTextureFormat;
        mCaptureCaptureBuffer = mCaptureTextureBuffer;
    }

    GXGetProjectionv(projv);
    GXGetViewportv(viewv);
    GXGetScissor(&left, &top, &width, &height);
    GXSetViewport(0.0f, 0.0f, 640.0f, 480.0f, 0.0f, 1.0f);

    if (mCaptureEnableGXSetCopyFilter)
        GXSetCopyFilter(GX_FALSE, NULL, GX_FALSE, NULL);

    setUpRectangle();
    GXSetTexCopySrc(centerX - sizeW, centerY - sizeH, sizeW2, sizeH2);
    GXSetTexCopyDst(sizeW, sizeH, (GXTexFmt)mCaptureCaptureFormat, GX_TRUE);
    DCInvalidateRange(mCaptureCaptureBuffer, mCaptureCaptureSize);
    GXCopyTex(mCaptureCaptureBuffer, GX_FALSE);
    GXPixModeSync();

    JUT_ASSERT(0xac1, mCaptureOldCB == NULL);
    mCaptureOldCB = GXSetDrawSyncCallback(mCaptureGXDrawSyncCallback);
    OSCreateAlarm(&mCaptureTimeOutAlarm);
    OSSetAlarm(&mCaptureTimeOutAlarm, mCaptureTimeOutTicks, mCaptureGXDrawSyncTimeOut);
    mCaptureStep++;
    GXSetDrawSync(GX_FALSE);
    GXSetProjectionv(projv);
    GXSetViewport(viewv[0], viewv[1], viewv[2], viewv[3], viewv[4], viewv[5]);
    GXSetScissor(left, top, width, height);
    GXSetClipMode(GX_CLIP_ENABLE);
    return true;
}

/* 8000AEA4-8000AF2C       .text setLight__Fv */
void setLight() {
    GXLightObj lightObj;
    GXInitLightPos(&lightObj, -35000.0f, 0.0f,-30000.0f);
    GXInitLightDir(&lightObj, 0.0f, 0.0f, 0.0f);
    GXInitLightColor(&lightObj, g_whiteColor);
    GXInitLightDistAttn(&lightObj, 0.0f, 0.0f, GX_DA_GENTLE);
    GXInitLightSpot(&lightObj, 0.0f, GX_SP_FLAT);
    GXLoadLightObjImm(&lightObj, GX_LIGHT0);
}

/* 8000AF2C-8000BC38       .text mDoGph_Painter__Fv */
bool mDoGph_Painter() {
    JFWDisplay::getManager()->setFader(mDoGph_gInf_c::mFader);
    mDoGph_gInf_c::setClearColor(mDoGph_gInf_c::getBackColor());
    mDoGph_gInf_c::beginRender();

    GXSetAlphaUpdate(GX_FALSE);
    mDoGph_gInf_c::setBackColor(g_clearColor);
    mDoGph_gInf_c::free();

    if (mCaptureEnableGXSetCopyFilter)
        GXSetCopyFilter(GX_FALSE, NULL, GX_FALSE, NULL);

    j3dSys.drawInit();
    GXSetDither(GX_TRUE);

    J2DOrthoGraph graf(0.0f, 0.0f, 640.0f, 480.0f, -1.0f, 1.0f);
    graf.setOrtho(JGeometry::TBox2<f32>(-9.0f, -21.0f, 650.0f, 503.0f), -1.0f, 1.0f);
    graf.setPort();

    dComIfGp_setCurrentGrafPort(&graf);
    dComIfGd_drawCopy2D();
    if (dComIfGp_getWindowNum() != 0) {
        dDlst_window_c* window = dComIfGp_getWindow(0);
        s32 cameraID = window->getCameraID();
        camera_class* camera = (camera_class*)dComIfGp_getCamera(cameraID);

        if (camera != NULL) {
            dComIfGd_imageDrawShadow(camera->mViewMtx);

            view_port_class viewport_crop;
            view_port_class* viewport_p = window->getViewPort();
            if (viewport_p->mXOrig != 0.0f || viewport_p->mYOrig != 0.0f) {
                viewport_crop.mXOrig = 0.5f * (viewport_p->mXOrig * 2.0f + viewport_p->mWidth) - 320.0f;
                viewport_crop.mYOrig = 0.5f * (viewport_p->mYOrig * 2.0f + viewport_p->mHeight) - 240.0f;
                viewport_crop.mWidth = 640.0f;
                viewport_crop.mHeight = 480.0f;
                viewport_crop.mNearZ = viewport_p->mNearZ;
                viewport_crop.mFarZ = viewport_p->mFarZ;
                viewport_crop.mScissor = viewport_p->mScissor;
                viewport_p = &viewport_crop;
            }

            GXSetViewport(viewport_p->mXOrig, viewport_p->mYOrig, viewport_p->mWidth, viewport_p->mHeight, viewport_p->mNearZ, viewport_p->mFarZ);
            GXSetScissor(viewport_p->mXOrig, viewport_p->mYOrig, viewport_p->mWidth, viewport_p->mHeight);

            JPADrawInfo jpaDrawInfo(camera->mViewMtx, 45.0f, 1.218f);
            jpaDrawInfo.setFovy(camera->mFovy);
            jpaDrawInfo.setAspect(camera->mAspect);

            BOOL isTower9 = FALSE;
            if (strcmp(dComIfGp_getStartStageName(), "GTower") == 0 && dComIfGp_getStartStageLayer() == 9)
                isTower9 = TRUE;
            dComIfGp_setCurrentWindow(window);
            dComIfGp_setCurrentView(camera);
            dComIfGp_setCurrentViewport(viewport_p);
            GXSetProjection(camera->mProjMtx, GX_PERSPECTIVE);
            PPCSync();
            j3dSys.setViewMtx(camera->mViewMtx);
            dKy_setLight();
            dComIfGd_drawOpaListSky();
            dComIfGd_drawXluListSky();

            if (!dMenu_flag() && dPa_control_c::isStatus(0x01))
                dComIfGp_particle_drawShipTail(&jpaDrawInfo);

            GXSetClipMode(GX_CLIP_ENABLE);
            dComIfGd_drawOpaListBG();
            dComIfGd_drawShadow(camera->mViewMtx);
            dComIfGd_drawAlphaModel(camera->mViewMtx);
            drawAlphaBuffer(camera, dComIfGd_getAlphaModelColor());
            if (dComIfGd_getLightModelNum() != 0) {
                clearAlphaBuffer(camera, 0);
                dComIfGd_drawLightModel(camera->mViewMtx);
                drawAlphaBuffer(camera, dComIfGd_getLightModelColor());
            }

            if (!mDoGph_gInf_c::isMonotone()) {
                dComIfGd_drawOpaListP0();
                dComIfGd_drawOpaListP1();
            }

            dComIfGd_drawOpaList();
            dComIfGd_drawXluListBG();

            if (dComIfGd_getSpotModelNum() != 0)
                clearAlphaBuffer(camera, dComIfGd_getSpotModelColor().a);

            if (!dMenu_flag() && !dPa_control_c::isStatus(0x01))
                dComIfGp_particle_drawShipTail(&jpaDrawInfo);

            if (!mDoGph_gInf_c::isMonotone())
                dComIfGd_drawXluListP1();

            dComIfGd_drawXluList();

            if (!dMenu_flag()) {
                dComIfGp_particle_draw(&jpaDrawInfo);

                if (!mDoGph_gInf_c::isMonotone())
                    dComIfGp_particle_drawP1(&jpaDrawInfo);

                JPADrawInfo windDrawInfo(dPa_control_c::getWindViewMatrix(), 45.0f, 1.218f);
                windDrawInfo.setFovy(camera->mFovy);
                windDrawInfo.setAspect(camera->mAspect);
                dComIfGp_particle_drawWind(&windDrawInfo);

                dComIfGp_particle_drawToon(&jpaDrawInfo);

                if (!mDoGph_gInf_c::isMonotone())
                    dComIfGp_particle_drawToonP1(&jpaDrawInfo);

                GXSetClipMode(GX_CLIP_ENABLE);
            }

            dComIfGd_drawOpaListFilter();

            j3dSys.reinitGX();
            GXSetNumIndStages(0);

            if (dComIfGd_getSpotModelNum() != 0) {
                dComIfGd_drawAlphaModel(camera->mViewMtx);
                dComIfGd_drawSpotModel(camera->mViewMtx);
                drawSpot(camera);
            }

            GXSetClipMode(GX_CLIP_ENABLE);
            dComIfGd_drawOpaListMaskOff();
            dComIfGd_drawXluListMaskOff();

            if (!dMenu_flag()) {
                motionBlure(camera);
                drawDepth(camera, viewport_p, dComIfGp_getCamZoomForcus(cameraID));
                dComIfGp_particle_drawProjection(&jpaDrawInfo);

                GXSetClipMode(GX_CLIP_ENABLE);
                dComIfGd_drawOpaListInvisible();
                dComIfGd_drawXluListInvisible();

                j3dSys.reinitGX();
                GXSetNumIndStages(0);

                if (isTower9)
                    dComIfGp_particle_draw(&jpaDrawInfo);

                if (mDoGph_gInf_c::isMonotone()) {
                    clearAlphaBuffer(camera, 0);
                    dComIfGd_drawOpaListP0();
                    dComIfGd_drawOpaListP1();
                    dComIfGd_drawXluListP1();
                    dComIfGp_particle_drawP1(&jpaDrawInfo);
                    dComIfGp_particle_drawToonP1(&jpaDrawInfo);
                }

                mDoGph_gInf_c::calcFade();
                if (mCaptureStep == 1) {
                    if (!mCaptureCansel)
                        mDoGph_screenCapture();
                    else
                        mCaptureStep = 0;
                }
            }
        }
    }

    if (mCaptureStep == 3) {
        if (mCaptureCansel) {
            if (mCaptureCaptureBuffer != NULL) {
                JKRFreeToHeap(NULL, mCaptureCaptureBuffer);
                mCaptureCaptureBuffer = NULL;
            }
            if (mCaptureTextureBuffer != NULL) {
                JKRFreeToHeap(NULL, mCaptureTextureBuffer);
                mCaptureTextureBuffer = NULL;
            }
            mCaptureStep = 0;
        } else {
            if (mCaptureTextureFormat == GX_TF_CMPR) {
                mCaptureThreadStackHead = mDoGph_allocFromAny(mCaptureThreadStackSize, 0x20);
                if (mCaptureThreadStackHead == NULL) {
                    mCaptureProc(NULL);
                    if (mCaptureCaptureBuffer != NULL) {
                        JKRFreeToHeap(NULL, mCaptureCaptureBuffer);
                        mCaptureCaptureBuffer = NULL;
                    }
                    mCaptureStep = 5;
                } else {
                    OSCreateThread(&mCaptureThread, (void*)mCaptureProc, NULL, mCaptureThreadStackHead + mCaptureThreadStackSize, mCaptureThreadStackSize, mCaptureThreadPriority, 0);
                    OSResumeThread(&mCaptureThread);
                    mCaptureStep++;
                }
            } else {
                mCaptureCaptureBuffer = NULL;
                mCaptureStep = 5;
            }
        }
    }

    if (mCaptureStep == 4) {
        if (mCaptureCansel) {
            OSCancelThread(&mCaptureThread);
        }

        if (OSIsThreadTerminated(&mCaptureThread)) {
            if (mCaptureCaptureBuffer != NULL) {
                JKRFreeToHeap(NULL, mCaptureCaptureBuffer);
                mCaptureCaptureBuffer = NULL;
            }

            if (mCaptureThreadStackHead != NULL) {
                JKRFreeToHeap(NULL, mCaptureThreadStackHead);
                mCaptureThreadStackHead = NULL;
            }

            void *exitVal;
            OSJoinThread(&mCaptureThread, &exitVal);
            mCaptureStep++;
        } else {
            OSAlarm alarm;
            u64 tickNum = OSMillisecondsToTicks(10);
            OSCreateAlarm(&alarm);
            OSInitThreadQueue(&mCaptureThreadQueue);
            OSSetAlarm(&alarm, tickNum, mCaptureAlarmHandler);
            OSSleepThread(&mCaptureThreadQueue);
            OSCancelAlarm(&alarm);
        }
    }

    if ((mCaptureStep == 3 || mCaptureStep == 4 || mCaptureStep == 5) && mCaptureDraw != 0 && !mCaptureCansel) {
        mDoGph_screenCaptureDraw();
    }

    if (mCaptureStep == 5 && mCaptureCansel) {
        mCaptureStep = 6;
    }

    if (mCaptureStep == 6) {
        if (mCaptureTextureBuffer != NULL) {
            JKRFreeToHeap(NULL, mCaptureTextureBuffer);
            mCaptureTextureBuffer = NULL;
        }

        mCaptureStep = 0;
        mCaptureCansel = false;
    }

    dDlst_list_c::calcWipe();
    j3dSys.reinitGX();
    GXSetNumIndStages(0);

    graf.setOrtho(JGeometry::TBox2<f32>(-9.0f, -21.0f, 650.0f, 503.0f), 100000.0f, -100000.0f);
    graf.setPort();
    Mtx viewMtx;
    mDoMtx_trans(viewMtx, 320.0f, 240.0f, 0.0f);
    JPADrawInfo jpaDrawInfo2D(viewMtx, 45.0f, 1.218f);
    jpaDrawInfo2D.setFovy(0.0f);
    jpaDrawInfo2D.setAspect(1.33333333f);
    if (!dMenu_flag())
        dComIfGp_particle_draw2Dback(&jpaDrawInfo2D);
    dComIfGp_particle_draw2DmenuBack(&jpaDrawInfo2D);

    if (dComIfGd_getList2D()->getEntryPacket(0) != NULL) {
        Mtx viewMtx;
        mDoMtx_copy(j3dSys.getViewMtx(), viewMtx);
        setLight();
        mDoMtx_stack_c::transS(320.0f, 240.0f, 1000.0f);
        mDoMtx_stack_c::ZrotM(-0x8000);
        j3dSys.setViewMtx(mDoMtx_stack_c::get());
        dComIfGd_drawOpaList2D();
        j3dSys.reinitGX();
        GXSetNumIndStages(0);
        j3dSys.setViewMtx(viewMtx);
    }

    dComIfGd_draw2DOpa();
    dComIfGd_draw2DOpaTop();
    dComIfGd_draw2DXlu();

    if (!dMenu_flag())
        dComIfGp_particle_draw2Dfore(&jpaDrawInfo2D);
    dComIfGp_particle_draw2DmenuFore(&jpaDrawInfo2D);

    mDoGph_gInf_c::endRender();

    return true;
}

/* 8000BC94-8000BD08       .text mDoGph_Create__Fv */
bool mDoGph_Create() {
    JKRSolidHeap * solidHeap = mDoExt_createSolidHeapToCurrent(0, NULL, 0);
    mDoGph_gInf_c::create();
    dComIfGd_init();
    mDoExt_adjustSolidHeap(solidHeap);
    mDoExt_restoreCurrentHeap();
    JFWAutoAbortGfx = mDoMain::developmentMode ? 0x02 : 0x01;
    return true;
}
